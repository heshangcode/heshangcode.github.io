<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis学习笔记（七）遇见的坑]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E9%81%87%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在学习过程中，遇见数据库中中文乱码，mybatis常见的异常和如何调试，idea不知道如何创建xml文件，idea中project和module的关系，如何把一个module复制成另外一个module，每次一个新的mybatis项目，有很多地方记得要修改 1.解决数据库中文乱码问题 方法一(推荐)：把数据库的配置文件编码设置成UTF-8或utf8mb4，两者区别就是UTF-8最大三字节，后者最大四字节 操作： 之前自己在网上找了一些教程说在mysql的安装目录下一个配置文件里修改，结果自己找了半天了，都没有找到，然后用everything搜索，找到了配置文件，结果不是安装目录下…… 找到如下文件，如果没有找到，用everything搜索 在最后添加下面代码 若要设置成utf-8，把utf8mb4修改成utf-8即可 123456789[client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect=&apos;SET NAMES utf8mb4&apos; 保存文件，重启mysql服务 方法二：在每次连接数据库的url最后面加入 1?useUnicode=true&amp;characterEncoding=UTF-8 2.mybatis常见的异常 控制台或者其他位置报MyBatisUtils工具类的异常 95%以上：是映射文件你写错了 5%：是核心配置文件写错了 因为mybatis-config.xml是入口，会加载很多的映射文件，把他们融合在一起，如果其中有任何一个映射文件出错，所有的定制的SQL语句都将无法运行 如何调试？ 把自己的，，，这一行代码注释掉，然后再运行看控制台，错误从下往上看，Caused byxx 3.idea如何创建xml文件 1&lt;?xml version="1.0" encoding="UTF-8"?&gt; 4.idea中project和module的关系之前刚用idea，以为一个project，就是一个项目，结果并不是 5.如何把一个module复制成另外一个module直接像eclipse那样复制一个module，图标只会这样： 这不是一个module，要让他变成module，如下操作： 6.一个新的mybatis项目重点一些地方需要修改或者添加 核心配置文件的映射文件里 日志框架里写上你的命名空间 到此，目前的MyBatis小结到此结束，下一个学习SpringMvc，只希望自己能坚持下去，世界诱惑很多，只希望自己能一路走下去，加油！！！]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（六）一对多的关联查询和传递多个参数]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本文讲解一对多的关联查询，传递多个参数。 1.传递多个参数 当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 #{值}，默认为arg0，arg1…..或param1，param2，，， 若在接口中注解了@Param(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值 2.结构 3.数据库属性文件同之前 4.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;mapper resource="com/hs/model/RoleMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5.持久化类Role.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.hs.model;import java.util.List;public class Role &#123; private Integer role_id; private String role_name; private String role_key; private Integer status; //关联对象,一对多，一个角色可以有多个用户 private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public Integer getRole_id() &#123; return role_id; &#125; public void setRole_id(Integer role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_key() &#123; return role_key; &#125; public void setRole_key(String role_key) &#123; this.role_key = role_key; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_id=" + role_id + ", role_name='" + role_name + '\'' + ", role_key='" + role_key + '\'' + ", status=" + status + ", userList=" + userList + '&#125;'; &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.model;import java.util.Date;public class User &#123; private Integer user_id; private String account; private String password; private String user_name; private Integer status; private Date login_time; private String ip; private Integer fk_role_id; //关联对象 一对一或多对一 private Role role; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getLogin_time() &#123; return login_time; &#125; public void setLogin_time(Date login_time) &#123; this.login_time = login_time; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public Integer getFk_role_id() &#123; return fk_role_id; &#125; public void setFk_role_id(Integer fk_role_id) &#123; this.fk_role_id = fk_role_id; &#125; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", account='" + account + '\'' + ", password='" + password + '\'' + ", user_name='" + user_name + '\'' + ", status=" + status + ", login_time=" + login_time + ", ip='" + ip + '\'' + ", fk_role_id=" + fk_role_id + ", role=" + role + '&#125;'; &#125;&#125; 6.XML映射文件RoleMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.RoleDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;resultMap type="Role" id="BaseResultMapper"&gt; &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_role_columns"&gt; role_id,role_name,role_key,status &lt;/sql&gt; &lt;sql id="sys_role_columns_alias"&gt; $&#123;alias&#125;.role_id,$&#123;alias&#125;.role_name,$&#123;alias&#125;.role_key,$&#123;alias&#125;.status &lt;/sql&gt; &lt;resultMap id="SimpleResultMapper" type="Role" extends="BaseResultMapper"&gt; &lt;!--配置集合List&lt;User&gt;,javaType一般可以不写--&gt; &lt;!--在结果集中找到role_id这个字段，然后传给命名空间com.hs.dao.UserDao下id为getUserByFk的语句， 返回的结果集字段为userList，类型为java.util.List，里面装的类型是com.he.model.User这个类型 --&gt; &lt;collection property="userList" javaType="java.util.List" ofType="User" column="role_id" select="com.hs.dao.UserDao.getUserByFk"/&gt; &lt;/resultMap&gt; &lt;select id="getRoleByPk" parameterType="_int" resultMap="SimpleResultMapper"&gt; select &lt;include refid="sys_role_columns"/&gt; from sys_role where role_id = #&#123;role_id&#125; &lt;/select&gt; &lt;resultMap id="JoinResultMapper" type="Role" extends="BaseResultMapper"&gt; &lt;!--配置集合，查询出来的User里的结果集找com.hs.dao.UserDao.BaseResultMapper处理--&gt; &lt;collection property="userList" javaType="list" ofType="com.hs.model.User" resultMap="com.hs.dao.UserDao.BaseResultMapper"/&gt; &lt;!--&lt;id/&gt; &lt;result/&gt;--&gt; &lt;/resultMap&gt; &lt;select id="getRoleByLeftJoin" parameterType="_int" resultMap="JoinResultMapper"&gt; SELECT &lt;include refid="com.hs.dao.UserDao.sys_user_colums_alias"&gt; &lt;property name="alias" value="su"/&gt; &lt;/include&gt; , &lt;include refid="sys_role_columns_alias"&gt; &lt;property name="alias" value="sr"/&gt; &lt;/include&gt; FROM sys_role sr LEFT JOIN sys_user su ON sr.role_id = su.fk_role_id WHERE sr.role_id =#&#123;role_id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap id="BaseResultMapper" type="User"&gt; &lt;id column="user_id" property="user_id" /&gt; &lt;result column="account" property="account" /&gt; &lt;result column="passwrod" property="pasword" /&gt; &lt;result column="user_name" property="user_name" /&gt; &lt;result column="status" property="status" /&gt; &lt;result column="login_time" property="login_time" /&gt; &lt;result column="ip" property="ip" /&gt; &lt;result column="fk_role_id" property="fk_role_id" /&gt; &lt;/resultMap&gt; &lt;resultMap id="SimpleResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!-- extends继承了BaseResultMapper，同java继承一样 --&gt; &lt;!--关联对象--&gt; &lt;!--在结果集中找到fk_role_id字段，然后再传值给命名空间com.hs.dao.RoleDao下的getRoleByPk语句进行查询(找到要执行的SQL语句)，最后返回role，它的类型是com.hs.model.Role--&gt; &lt;association property="role" javaType="Role" column="fk_role_id" select="com.hs.dao.RoleDao.getRoleByPk"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_user_colums"&gt; user_id,account,password,user_name,status,login_time,ip,fk_role_id &lt;/sql&gt; &lt;sql id="sys_user_colums_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.account,$&#123;alias&#125;.password,$&#123;alias&#125;.user_name,$&#123;alias&#125;.status,$&#123;alias&#125;.login_time,$&#123;alias&#125;.ip,$&#123;alias&#125;.fk_role_id &lt;/sql&gt; &lt;select id="getUserByFk" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where fk_role_id = #&#123;role_id&#125; &lt;/select&gt; &lt;!--1.当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 2.#&#123;值&#125;，默认为arg0，arg1.....或param1，param2，，， 若在dao注解了@xxx(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值--&gt; &lt;select id="getUser" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where account=#&#123;account&#125; and password=#&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 7.接口RoleDao.java 12345678910111213141516171819202122package com.hs.dao;import com.hs.model.Role;public interface RoleDao &#123; /** * select方式，先在role表查出主键，然后传给user表当做条件，查询出user的信息 * * @param role_id * @return */ Role getRoleByPk(int role_id); /** * 利用连接查询方式，查询结果集 * * @param role_id * @return */ Role getRoleByLeftJoin(int role_id);&#125; UserDao.java 123456789101112131415package com.hs.dao;import com.hs.model.User;import org.apache.ibatis.annotations.Param;public interface UserDao &#123; /** * 传递多个参数 * 1.当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 * 2.#&#123;值&#125;，默认为arg0，arg1.....或param1，param2，，， * 若在dao注解了@xxx(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值 */ User getUser(@Param("account") String account, @Param("password") String password);&#125; 8.日志配置文件mybatis-config.xml 12345678910# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.UserDao=TRACElog4j.logger.com.hs.dao.RoleDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 9.测试类MyBatisTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hs.test;import com.hs.dao.RoleDao;import com.hs.dao.UserDao;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 利用select方式， */ @Test public void getUserByPk()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); RoleDao roleDao = sqlSession.getMapper(RoleDao.class); System.out.println(roleDao.getRoleByPk(-100)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 利用连接方式查询 */ @Test public void getUserByFk()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); RoleDao roleDao = sqlSession.getMapper(RoleDao.class); System.out.println(roleDao.getRoleByLeftJoin(-100)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递多个参数 */ @Test public void getUser()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); String account = "admin"; String password = "admin"; System.out.println(userDao.getUser(account,password)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（五）一对一或多对一的关联查询]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%80%E5%AF%B9%E4%B8%80%E6%88%96%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[本文讲解，mybatis中一对一、多对一的关联查询，类名的别名方式应用 1.关系型数据库中表和表之间的关系 一对一：外键唯一 一对多和多对一：只是站在角度不同而已，但是外键一定在多方 自身一对多和多对一 外键： 逻辑关联 物理关联 多对多：一定是通过中间表维护 2.java类中如何表示上述几种关系UML：依赖/关联/组合 eg：用户和角色的关系 一个用户对应一个角色，一个角色可以多个用户 用户ID 用户 角色ID 100 悟空 999 200 八戒 999 查询100的用户信息，那么它一定对 一个角色信息 List 1234public class User&#123;//关联对象 public Role role;//一对一,多对一 &#125; 123public class Role&#123; private List&lt;User&gt; userList; //一个角色里可以对应很多用户&#125; 3.三种方式 传统模式：两个SQL语句，先在一个表查出数据，然后把其中的id作为另外一个表的where，再查数据 select方式：在映射文件中，一个查出的结果集中，调用另外一个select语句实现查询 连接查询：也就是SQL语句连接查询(个人还是喜欢这种) 4.知识小点 配置关联对象用&lt;association&gt;这样查出来的就是一个对象 配置集合就用&lt;collection&gt; 5.目录结构 6.数据库属性文件jdbc.properties 1代码同上篇 7.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;mapper resource="com/hs/model/RoleMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 8.封装好的工具类MyBatisUtils.java 1同上篇 9.持久化类Role.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hs.model;public class Role &#123; private Integer role_id; private String role_name; private String role_key; private Integer status; public Integer getRole_id() &#123; return role_id; &#125; public void setRole_id(Integer role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_key() &#123; return role_key; &#125; public void setRole_key(String role_key) &#123; this.role_key = role_key; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_id=" + role_id + ", role_name='" + role_name + '\'' + ", role_key='" + role_key + '\'' + ", status=" + status + '&#125;'; &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.model;import java.util.Date;public class User &#123; private Integer user_id; private String account; private String password; private String user_name; private Integer status; private Date login_time; private String ip; private Integer fk_role_id; //关联对象 一对一或多对一，一个用户对应一个角色 private Role role; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getLogin_time() &#123; return login_time; &#125; public void setLogin_time(Date login_time) &#123; this.login_time = login_time; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public Integer getFk_role_id() &#123; return fk_role_id; &#125; public void setFk_role_id(Integer fk_role_id) &#123; this.fk_role_id = fk_role_id; &#125; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", account='" + account + '\'' + ", password='" + password + '\'' + ", user_name='" + user_name + '\'' + ", status=" + status + ", login_time=" + login_time + ", ip='" + ip + '\'' + ", fk_role_id=" + fk_role_id + ", role=" + role + '&#125;'; &#125;&#125; 10.XML映射文件RoleMapper.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.RoleDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的类名别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap type="Role" id="BaseResultMapper"&gt; &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_role_columns"&gt; role_id,role_name,role_key,status &lt;/sql&gt; &lt;sql id="sys_role_columns_alias"&gt; $&#123;alias&#125;.role_id,$&#123;alias&#125;.role_name,$&#123;alias&#125;.role_key,$&#123;alias&#125;.status &lt;/sql&gt; &lt;select id="getRoleByPk" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_role_columns"/&gt; from sys_role where role_id = #&#123;role_id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的类名别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap id="BaseResultMapper" type="User"&gt; &lt;id column="user_id" property="user_id" /&gt; &lt;result column="account" property="account" /&gt; &lt;result column="passwrod" property="pasword" /&gt; &lt;result column="user_name" property="user_name" /&gt; &lt;result column="status" property="status" /&gt; &lt;result column="login_time" property="login_time" /&gt; &lt;result column="ip" property="ip" /&gt; &lt;result column="fk_role_id" property="fk_role_id" /&gt; &lt;/resultMap&gt; &lt;resultMap id="SimpleResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!-- extends继承了BaseResultMapper，同java继承一样 --&gt; &lt;!--配置关联对象--&gt; &lt;!--在结果集中找到fk_role_id字段，然后再传值给命名空间com.hs.dao.RoleDao下的getRoleByPk语句进行查询(找到要执行的SQL语句)，最后返回role(对象的属性)，它的类型是com.hs.model.Role--&gt; &lt;association property="role" javaType="Role" column="fk_role_id" select="com.hs.dao.RoleDao.getRoleByPk"/&gt; &lt;collection property="" &lt;/resultMap&gt; &lt;sql id="sys_user_colums"&gt; user_id,account,password,user_name,status,login_time,ip,fk_role_id &lt;/sql&gt; &lt;sql id="sys_user_colums_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.account,$&#123;alias&#125;.password,$&#123;alias&#125;.user_name,$&#123;alias&#125;.status,$&#123;alias&#125;.login_time,$&#123;alias&#125;.ip,$&#123;alias&#125;.fk_role_id &lt;/sql&gt; &lt;select id="getUserByPk01" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where user_id = #&#123;user_id&#125; &lt;/select&gt; &lt;select id="getUserByPk02" parameterType="_int" resultMap="SimpleResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where user_id = #&#123;user_id&#125; &lt;/select&gt; &lt;resultMap id="JoinResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!--关联对象--&gt; &lt;!--resultMap引用别人的结果集(命名空间+"."+id)，或者自己在下面写结果集处理--&gt; &lt;association property="role" javaType="Role" resultMap="com.hs.dao.RoleDao.BaseResultMapper"&gt; &lt;!-- &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; --&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="getUserByLeftJoin" parameterType="_int" resultMap="JoinResultMapper"&gt; select &lt;!-- 调用别名式的SQL代码，给alias赋值为u --&gt; &lt;include refid="sys_user_colums_alias"&gt; &lt;property name="alias" value="u"/&gt; &lt;/include&gt; , &lt;include refid="com.hs.dao.RoleDao.sys_role_columns_alias"&gt; &lt;property name="alias" value="r"/&gt; &lt;/include&gt; from sys_user u left join sys_role r on u.fk_role_id = r.role_id where u.user_id = #&#123;user_id&#125; &lt;/select&gt;&lt;/mapper&gt; 11.接口UserDao.java 123456789101112131415161718192021222324252627package com.hs.dao;import com.hs.model.User;public interface UserDao &#123; /** * 通过id查询user表的所有信息，再用它的外键传递给另外一个表进行查询数据 * @param user_id * @return */ User getUserByPk01(int user_id); /** * 用关联对象方式、select方式代取传统的模式 * @param user_id * @return */ User getUserByPk02(int user_id); /** * 在SQL语句写连接方式的查询 * @param user_id * @return */ User getUserByLeftJoin(int user_id);&#125; RoleDao.java 1234567891011121314package com.hs.dao;import com.hs.model.Role;public interface RoleDao &#123; /** * 通过role_id查询role表信息 * @param role_id * @return */ Role getRoleByPk(int role_id);&#125; 12.测试类MyBatisTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.hs.test;import com.hs.dao.RoleDao;import com.hs.dao.UserDao;import com.hs.model.Role;import com.hs.model.User;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 一对一的三种方式 */ /** * 方式一：利用两个SQL语句，先在user查出外键，然后再在role表进行查询 */ @Test public void getAllByFk01()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByPk01(-999);// 获取对应的外键信息 if (user.getFk_role_id()!=null) &#123; RoleDao roleDao = sqlSession.getMapper(RoleDao.class); Role role = roleDao.getRoleByPk(user.getFk_role_id()); //建立关系 user.setRole(role); &#125; System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 用关联对象方式、select方式代取传统的模式 */ @Test public void getAllBySelect()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByPk02(-999); System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * SQL语句连接方式查询 */ @Test public void getUserByLeftJoin()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByLeftJoin(-999); System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（四）动态SQL语句专题]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文讲解动态的SQL操作，CRUD中，CUD都需要自己手动提交事务，动态的添加语句，批量删除的三种处理方式，提取公共的sql代码，if标签，where标签，trim标签，set标签，choose标签，foreach标签，批量添加 1.trim标签12345&lt;trim prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容"&gt; &lt;/trim&gt; 2.set标签当你发现有内容的时候,在内容的最前面加入 set 当你放下有内容的时候,检查内容的最后面是否有逗号”,” 如果将其抹掉 3.where标签 如果发现标签內有内容,那么会在内容的最前面加入关键字 where 如果有内容,会检查内容的最前面是否含有 AND空格 或者 OR空格 ,自动将其抹掉 4.foreach标签 如果只传了一个数组或者一个集合 collection=”array 或者 list” 如果传的是一个Map里装了list 就写map的key，如果是对象里setList，就写对象的list属性,这个属性就对应一个集合 item相当于，他的遍历的一个值，open=”开始加入” close=”最后加入” separator=”以什么间隔”–&gt; 4.choose标签类似java中的switch5.代码结构 6.数据库配置文件同前几天笔记 7.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 8.持久化类User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hs.model;import java.util.Date;public class User &#123; /*本字段名字跟数据库的字段一样*/ private Integer user_id; private String user_name; private String sex; private Double money; private Date birthday; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", user_name='" + user_name + '\'' + ", sex='" + sex + '\'' + ", money=" + money + ", birthday=" + birthday + '&#125;'; &#125;&#125; 9.映射文件UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--见帮助文档http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html--&gt; &lt;resultMap id="BaseResultMap" type="com.hs.model.User"&gt; &lt;id column="user_id" property="user_id"/&gt; &lt;result column="user_name" property="user_name"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="money" property="money"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;/resultMap&gt; &lt;!--提取公共的SQL代码--&gt; &lt;sql id="oa_user_columns"&gt; user_id,user_name,sex,money,birthday &lt;/sql&gt; &lt;!--别名方式的SQL代码--&gt; &lt;sql id="oa_user_columns_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.user_name,$&#123;alias&#125;.sex,$&#123;alias&#125;.money,$&#123;alias&#125;.birthday &lt;/sql&gt; &lt;!-- A.通过恒等式完成动态SQL语句 --&gt; &lt;select id="getUserListIf01" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user where 1=1 &lt;!-- 恒等式 ，但是影响效率--&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/select&gt; &lt;!-- B.通过where标签完成动态SQL语句，没有1=1 --&gt; &lt;select id="getUserListIf02" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- C.trim标签实现&lt;trim prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容" --&gt; &lt;select id="getUserListIf03" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user &lt;trim prefix="where " prefixOverrides="and || or"&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 见xml转义字符 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!--利用set标签 当你发现有内容的时候,在内容的最前面加入 set 当你发现有内容的时候,检查内容的最后面是否有逗号"," 如果有将其抹掉 --&gt; &lt;update id="updateUser01ByPk" parameterType="com.hs.model.User"&gt; update oa_user &lt;set&gt; &lt;if test="user_name !=null and user_name != ''"&gt; user_name = #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex != ''"&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money != null"&gt; &lt;!--不是字符串就不要判断是否为空 ='' --&gt; money = #&#123;money&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;user_id&#125; &lt;/update&gt; &lt;!--利用trim标签，，，，但是不推荐 --&gt; &lt;update id="updateUser02ByPk" parameterType="com.hs.model.User"&gt; update oa_user &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name != ''"&gt; user_name = #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex != ''"&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money != null"&gt; &lt;!--不是字符串就不要判断是否为空 ='' --&gt; money = #&#123;money&#125;, &lt;/if&gt; &lt;/trim&gt; where user_id = #&#123;user_id&#125; &lt;/update&gt; &lt;!--利用choose标签，类似switch--&gt; &lt;select id="getSkillByChoose" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user where &lt;choose&gt;&lt;!--注意单双引号,when里test='' --&gt; &lt;when test='sex!=null and sex=="男"'&gt; money &gt; 700 &lt;/when&gt; &lt;!--&lt;when test='sex!=null and sex=="女"'&gt; money &amp;lt;= 700 &amp;lt;!&amp;ndash;见xml转义字符 小于号(因为小于号&lt;是标签的开头)的解决问题，或者这样写 &amp;ndash;&amp;gt; &lt;/when&gt;--&gt; &lt;when test='sex!=null and sex="女"'&gt; &lt;![CDATA[ money &lt;= 700 ]]&gt; &lt;/when&gt; &lt;!--里面不能包含标签，把&lt;，不当做标签的开头 --&gt; &lt;otherwise&gt; &lt;!--switch中的default--&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; &lt;!--后面两个属性，前者可以不用写，后者是使用该属性，接收这个新添加的数据的主键--&gt; &lt;insert id="addSkill01" parameterType="com.hs.model.User" useGeneratedKeys="true" keyProperty="user_id"&gt; insert into oa_user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name!=''"&gt; user_name, &lt;/if&gt; &lt;if test="sex !=null and sex!=''"&gt; sex, &lt;/if&gt; &lt;if test="money !=null"&gt; money, &lt;/if&gt; &lt;if test="birthday !=null"&gt; birthday, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values(" suffix=")" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name!=''"&gt; #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex!=''"&gt; #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money !=null"&gt; #&#123;money&#125;, &lt;/if&gt; &lt;if test="birthday !=null"&gt; #&#123;birthday&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;!--数组删除，如果数组的话，请不要去设置parameterType,让其自动识别 --&gt; &lt;delete id="deleteSkillByArray" &gt; delete from oa_user where user_id in &lt;!--对数组进行遍历， 如果只传了一个数组或者一个集合 collection="array 或者 list 如果传的是一个Map里装了list 就写map的key，如果是对象里setList，就写对象的list属性,这个属性就对应一个集合 item相当于，他的遍历的一个值，open="开始加入" close="最后加入" separator="以什么间隔"--&gt; &lt;foreach collection="array" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!--List集合删除 --&gt; &lt;delete id="deleteSkillByList" parameterType="list"&gt; delete from oa_user where user_id in &lt;foreach collection="list" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;delete id="deleteSkillByMap" parameterType="map"&gt; delete from oa_user where user_id in &lt;foreach collection="id_array" item="id" open="(" close=")" separator=","&gt; &lt;!-- 等于遍历，id_array对应一个list，item就是这个list里的值 --&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!--批量添加--&gt; &lt;insert id="addSkillByAll" parameterType="list"&gt; insert into oa_user(user_name,sex,money) values &lt;foreach collection="list" item="user" separator=","&gt; (#&#123;user.user_name&#125;,#&#123;user.sex&#125;,#&#123;user.money&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;/mapper&gt; 10.封装好的工具类同之前的笔记 11.接口UserDao.java 12345678910111213141516171819202122232425262728293031package com.hs.dao;import com.hs.model.User;import java.util.List;import java.util.Map;public interface UserDao &#123; List&lt;User&gt; getUserListIf01(Map&lt;String, Object&gt; map); List&lt;User&gt; getUserListIf02(Map&lt;String, Object&gt; map); List&lt;User&gt; getUserListIf03(Map&lt;String, Object&gt; map); int updateUser01ByPk(User user); int updateUser02ByPk(User user); List&lt;User&gt; getSkillByChoose(Map&lt;String, Object&gt; map); int addSkill01(User user); int deleteSkillByArray(int[] array); int deleteSkillByList(List&lt;Integer&gt; list); int deleteSkillByMap(Map&lt;String, Object&gt; map); int addSkillByAll(List&lt;User&gt; list);&#125; 12.日志框架配置log4j.properties.xml 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.UserDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 13.测试类MyBatisTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package com.hs.test;import com.hs.dao.UserDao;import com.hs.model.User;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * if标签，进行两个姓名和性别的条件查询，通过恒等式完成动态SQL语句 */ @Test public void getUserListIf01() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf01(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * if标签，进行两个姓名和性别的条件查询，通过where标签（推荐！！！）： * 如果发现标签內有内容,那么会在内容的最前面加入关键字 where * 如果有内容,会检查内容的最前面是否含有 AND空格 或者 OR空格 ,自动将其抹 */ @Test public void getUserListIf02() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf02(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * if标签，进行两个姓名和性别的条件查询，通过trim标签： * &lt;trim * prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" * prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" * suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" * suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容" * &gt; &lt;/trim&gt; */ @Test public void getUserListIf03() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf03(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 更新操作—变更数据库 * 利用set标签 * 当你发现有内容的时候,在内容的最前面加入 set * 当你发现有内容的时候,检查内容的最后面是否有逗号"," 如果有将其抹掉 */ @Test public void updateUser01ByPk() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); //数据 User user = new User(); user.setUser_id(3); user.setUser_name("天蓬元帅"); //日期的转换 String date = "2018-8-3"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.updateUser01ByPk(user)); //重点！！！，CRUD中，除了R（查询），不用提交事务，其余全的自己提交事务，传统和接口模式提交事务都是一样的 sqlSession.commit(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 更新操作—变更数据库 * 利用trim标签 * * @throws ParseException */ @Test public void updateUser02ByPk() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); //数据 User user = new User(); user.setUser_id(3); user.setUser_name("天蓬元帅"); user.setMoney(1000.0); //日期的转换 String date = "2018-8-3"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.updateUser02ByPk(user)); //重点！！！，CRUD中，除了R（查询），不用提交事务，其余全的自己提交事务，传统和接口模式提交事务都是一样的 sqlSession.commit(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 查询通过choose标签 * 解决小于号的问题 */ @Test public void getSkillByChoose() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("sex", "女"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getSkillByChoose(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 添加一个数据，然后返回这个数据自增长的主键信息 */ @Test public void addSkill01() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); User user = new User(); user.setUser_name("沙僧"); user.setSex("男"); user.setMoney(455.0); String date = "2018-8-5"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println("影响行数"+userDao.addSkill01(user)); sqlSession.commit(); System.out.println("user_id:"+user.getUser_id()); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递传递数组删除规则 */ @Test public void deleteSkillByArray()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByArray(new int[]&#123;6,8&#125;)); //静态初始化 //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递List集合删除规则 */ @Test public void deleteSkillByList()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(9); list.add(11); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByList(list)); //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递Map里装list删除规则 */ @Test public void deleteSkillByMap()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(8); list.add(10); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("id_array",list); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByMap(map)); //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 通过list里装User实现批量添加 */ @Test public void addSkillByAll()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); User user1 = new User(); user1.setUser_name("嫦娥"); user1.setSex("女"); user1.setMoney(1213.0); User user2 = new User(); user2.setUser_name("月兔"); user2.setSex("女"); user2.setMoney(2113.0); list.add(user1); list.add(user2); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.addSkillByAll(list)); sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三）模糊查询专题]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文讲解，用接口代理模式实现mybatis的模糊查询，讲解#{}和${}两个的区别，XML文件中五个特殊字符串不允许使用，小于号的解决问题。 1.关于接口代理模式和传统模式的区别 传统模式：在笔记（二）就是采用的这个模式： 需要写接口，接口实现类，测试类， 映射文件命名空间为持久化类的全路径 接口代理模式：本笔记之后所有采用这个模式： 只需要写接口，在测试类中调用，接口编程: 什么是接口? 简单理解:接口就是定义规范 接口返回类型跟你设置的resultMap或者resultType对应上即可,但是会根据你返回的类型完成selectone或者selectList操作 接口里方法如何写：sql语句返回的结果集类型 sql语句的id(要传的值); eg:List getSkillLike02(String name); List为SQL语句返回的结果集类型，getSkillLike02为映射文件中SQL语句的id，String name是传给映射文件的值 映射文件命名空间为接口的全路径 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是List，如果是List，也是List 2.MyBatis框架中获取数据的形式有两种方案 #{}和${}的区别? #{} 取值： 方案一： 如果你是一个简单的数据类型,那么我们使用#{任意标识符} 方案二: 对象或者Map #{属性或者KEY} 如果使用#{}那么它的模式方式为预处理模式 ${} 你需要必须指明KEY或者属性 对数据不会进行转义 直接拼接到SQL语句上 3.XML文件中有五个特殊字符串不允许使用 方法一：用了转义字符把&gt;和&lt;替换掉，然后就没有问题了。 附:XML转义字符 方法二： 因为这个是xml格式的，所以不允许出现类似“&gt;”这样的字符，但是都可以使用&lt;![CDATA[ 内容 ]]&gt;符号进行说明，将此类符号不进行解析 4.代码结构 5.数据库属性文件jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mssjdbc.mysql.username=rootjdbc.mysql.password=root 6.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 7.接口代码SkillDao.java 12345678910111213141516171819202122232425package com.hs.dao;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */import com.hs.model.Skill;import java.util.List;import java.util.Map;public interface SkillDao &#123; List&lt;Skill&gt; getSkillLike01(); List&lt;Skill&gt; getSkillLike02(String name); List&lt;Skill&gt; getSkillLike03(String name); List&lt;Skill&gt; getSkillLike04(Map&lt;String,Object&gt; map); List&lt;Skill&gt; getSkillLike05(Map&lt;String,Object&gt; map);&#125; 8.持久化类Skill.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.hs.model;public class Skill &#123; private Integer skillid; private String skillname; private Integer num; public Integer getSkillid() &#123; return skillid; &#125; public void setSkillid(Integer skillid) &#123; this.skillid = skillid; &#125; public String getSkillname() &#123; return skillname; &#125; public void setSkillname(String skillname) &#123; this.skillname = skillname; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public String toString() &#123; return "Skill&#123;" + "skillid=" + skillid + ", skillname='" + skillname + '\'' + ", num=" + num + '&#125;'; &#125;&#125; 9.映射文件SkillMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.SkillDao"&gt; &lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径--&gt; &lt;resultMap id="BaseResultMap" type="com.hs.model.Skill"&gt; &lt;id column="skill_id" property="skillid"/&gt; &lt;!--若有主键，主键用id标签，其余用result标签--&gt; &lt;result column="skill_name" property="skillname"/&gt; &lt;result column="num" property="num"/&gt; &lt;/resultMap&gt; &lt;!--1.模糊条件查询是固定的，写死在sql语句里了--&gt; &lt;select id="getSkillLike01" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like '%s%' &lt;/select&gt; &lt;!--2.模糊条件是一个简单的数据类型 当你传递的为一个简单的数据类型，那么我们可以通过#&#123;任意写&#125;进行传值， #&#123;xx&#125;是一种预处理模式，先sql语句里是？ 然后接收到值了，再写进去,会给你默认加 '',即为'#&#123;&#125;' --&gt; &lt;!--A、通过java代码拼接字符串--&gt; &lt;select id="getSkillLike02" parameterType="string" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like #&#123;name&#125; &lt;/select&gt; &lt;!--B、通过SQL语句函数拼接字符串 concat函数指字符串拼接，--&gt; &lt;select id="getSkillLike03" parameterType="string" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like concat('%',#&#123;name&#125;,'%') &lt;/select&gt; &lt;!--C、通过$&#123;&#125;完成模糊查询！！！但是不太推荐，$&#123;&#125;不会默认加 '' ，也不是预处理模式，是直接在把值写在了sql语句中， 一般用于order by $&#123;key或者属性&#125;,一般只接受map或者对象 --&gt; &lt;select id="getSkillLike04" parameterType="map" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like concat('%','$&#123;name&#125;','%') &lt;/select&gt; &lt;!--$&#123;&#125;的应用，排序--&gt; &lt;select id="getSkillLike05" parameterType="map" resultMap="BaseResultMap"&gt; select * from skill order by skill_id $&#123;fs&#125; &lt;/select&gt;&lt;/mapper&gt; 10.封装好的工具类MyBatis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; inputStream = Resources.getResourceAsStream(PATH); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; public static SqlSession getSqlsession() &#123; return sqlSessionFactory.openSession(); &#125; public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 11.日志框架配置log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.SkillDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 12.测试类MyBatis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.test;import com.hs.dao.SkillDao;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.HashMap;import java.util.Map;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 1.模糊条件查询是固定的，写死在sql语句里了 */ @Test public void getSkillLike01() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession();// 根据xml映射文件，接口创建实现类代理 有点类似传统模式的new UserMapperImpl() SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike01()); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 2.通过java代码拼接字符串进行模糊查询 */ @Test public void getSkillLike02() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); String name = "%a%"; SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike02(name)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 3.通过sql语句函数拼接字符串进行模糊查询 */ @Test public void getSkillLike03() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); String name = "s"; SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike03(name)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 4.通过$&#123;&#125;拼接字符串进行模糊查询 */ @Test public void getSkillLike04() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "s"); SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike04(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 4.通过$&#123;&#125;进行排序操作 */ @Test public void getSkillLike05() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("fs", "DESC"); SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike05(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）CRUD操作（查询操作基础）]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇主要讲解查询操作的结果集处理、映射文件里命名空间设置，SQL语句中resultMap，resultType等属性意思、MyBatis的传统和接口代理模式。 1.整体结构目录 SkillDao.java接口含一些方法 SkillDaoImpl.java是SkillDao的实现类 Skill.java是持久化类（实体Bean） SkillMapper.xml是Skill持久化类的映射文件（含SQL语句操作等） MyBatisTest.java测试类 jdbc.properties数据库的属性文件 log4j.properties日志框架配置(在控制台显示sql语句等信息) mybatis-config.xml核心配置文件 2.数据库属性文件jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mssjdbc.mysql.username=rootjdbc.mysql.password=root 3.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 --&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.封装好的工具类MyBatisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; //输入流 读文件 //1.读取核心配置文件 inputStream = Resources.getResourceAsStream(PATH); //2.创建SqlSession工厂(SqlSessionFactory)相当于Connection sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; /** * 获取sqlsession * @return */ public static SqlSession getSqlsession() &#123; //3.获取SqlSession 相当于执行SQL语句对象PreparedStament预处理对象 //***** SqlSession完成所有的持久化操作CRUD return sqlSessionFactory.openSession(); &#125; /** * 关闭资源 * @param sqlSession */ public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 5.持久化类为了讲出来一些知识点，持久化类的属性名没有和数据库的字段名一样，正常应该是一样的 Skill.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.hs.model;public class Skill &#123; private Integer skillid; private String skillname; private Integer num; public Integer getSkillid() &#123; return skillid; &#125; public void setSkillid(Integer skillid) &#123; this.skillid = skillid; &#125; public String getSkillname() &#123; return skillname; &#125; public void setSkillname(String skillname) &#123; this.skillname = skillname; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public String toString() &#123; return "Skill&#123;" + "skillid=" + skillid + ", skillname='" + skillname + '\'' + ", num=" + num + '&#125;'; &#125;&#125; 6.XML映射文件SQL映射文件经常含一些元素 parameterType—-接收的参数类型，简写方式见mybatis官方文档中，别名和映射的类型那块 parameterMap没有人用了！！！！！ resultType—-语句执行完毕返回的结果集类型 resultMap—-语句执行完毕返回的结果集，这是一个标签，找它对应的标签，对这个结果集进行处理，里面的type就是相应的返回类型 sql—-提取公共的SQL代码 insert—-映射插入语句 update—-映射更新语句 delete—-映射删除语句 select—-映射查询语句 SkillMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.model.Skill"&gt; &lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径--&gt; &lt;!--查询的字段，并没有优化，下个专题进行优化--&gt; &lt;!--当你传递的是“一个”简单的数据类型的形参的时候，那么你的$&#123;任意名字&#125;,sql语句后面不要加 ; --&gt; &lt;select id="getMap01ByPk" parameterType="_int" resultType="map"&gt; select skill_id,skill_name,num from skill where skill_id = #&#123;sadsa&#125; &lt;/select&gt; &lt;select id="getMap02ByPk" parameterType="_int" resultType="map"&gt; select skill_id skillid,skill_name skill_name ,num number from skill where skill_id = #&#123;skill_id&#125; &lt;/select&gt; &lt;!--只能对结果集的结果操作进行处理，autoMapping="true"默认映射，默认为true，重写字段名会覆盖默认的，若false就不会映射默认字段（只映射出自己写的别名）--&gt; &lt;resultMap id="MapResultMapper" type="map" autoMapping="true"&gt; &lt;result column="skill_id" property="id"/&gt; &lt;!--column为结果集里的字段名，property为自己要映射(变成)的字段名--&gt; &lt;result column="skill_name" property="name"/&gt; &lt;result column="num" property="number"/&gt; &lt;/resultMap&gt; &lt;select id="getMap03ByPk" parameterType="_int" resultMap="MapResultMapper"&gt; select skill_id,skill_name ,num from skill where skill_id = #&#123;skill_id&#125; &lt;/select&gt; &lt;!--1.别名方法，属性和字段名一致，可以完成自动映射--&gt; &lt;select id="getSkill01ByPk" parameterType="int" resultType="com.hs.model.Skill"&gt; select skill_id skillid,skill_name skillname,num from skill where skill_id = #&#123;adsa&#125; &lt;/select&gt; &lt;!--2.resultMap标签找对应id的标签，利用结果集，进行转换，jdbcType和javaType可以不用写，名字见jdbc类型和Java 类型对应http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases--&gt; &lt;resultMap id="SkillResultMapper" type="com.hs.model.Skill"&gt; &lt;id column="skill_id" jdbcType="INTEGER" property="skillid" javaType="java.lang.Integer"/&gt; &lt;result column="skill_name" jdbcType="VARCHAR" property="skillname" javaType="java.lang.String"/&gt; &lt;result column="num" property="num"/&gt; &lt;/resultMap&gt; &lt;select id="getSkill02ByPk" parameterType="int" resultMap="SkillResultMapper"&gt; select skill_id,skill_name,num from skill where skill_id = #&#123;adsa&#125; &lt;/select&gt; &lt;!--一条一条的为map--&gt; &lt;select id="getSkillList01ByAll" resultType="map"&gt; select skill_id,skill_name,num from skill &lt;/select&gt; &lt;select id="getSkillList02ByAll" resultMap="SkillResultMapper"&gt; select skill_id,skill_name,num from skill &lt;/select&gt;&lt;/mapper&gt; 7.接口SkillDao.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.dao;import com.hs.model.Skill;import java.util.List;import java.util.Map;public interface SkillDao &#123; /** * 处理结果集为Map类型 * @param skillid * @return */ Map&lt;String, Object&gt; getMap01ByPk(int skillid); /** * 处理结果集为Map类型—通过给字段取别名方式 * @param skillid * @return */ Map&lt;String, Object&gt; getMap02ByPk(int skillid); /** * 处理结果集为Map类型—通过resultMap标签处理 * @param skillid * @return */ Map&lt;String, Object&gt; getMap03ByPk(int skillid); /** * 处理结果集为自定义的类Skill—通过给字段取别名方式 * @param skillid * @return */ Skill getSkill01ByPk(int skillid); /** * 处理结果集为自定义的类Skill—resultMap标签处理 * @param skillid * @return */ Skill getSkill02ByPk(int skillid); /** * 处理结果集为集合（list） * @param skillid * @return */ List&lt;Map&lt;String, Object&gt;&gt; getSkillList01ByAll(); /** * 处理结果集为集合（list）—通过resultMap * @param skillid * @return */ List&lt;Map&lt;String, Object&gt;&gt; getSkillList02ByAll();&#125; 8.接口实现类SkillDaoImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.hs.dao;import com.hs.model.Skill;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import java.util.List;import java.util.Map;public class SkillDaoImpl implements SkillDao &#123; /* * 关键步骤：定位执行SQL语句***如何定位 (namespace+"."+id) * 因为命名空间是Bean的路径，所以下面的 命名空间.sql语句的id === 类.class.getName()+" ." +id * 后面就是要传过去的值 * */ @Override public Map&lt;String, Object&gt; getMap01ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); System.out.println(Skill.class.getName()+"----com.he.model.Skill"); //关键步骤 return sqlSession.selectOne(Skill.class.getName() + ".getMap01ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Map&lt;String, Object&gt; getMap02ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getMap02ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Map&lt;String, Object&gt; getMap03ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getMap03ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Skill getSkill01ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getSkill01ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Skill getSkill02ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getSkill02ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; getSkillList01ByAll() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectList(Skill.class.getName() + ".getSkillList01ByAll"); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; getSkillList02ByAll() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectList(Skill.class.getName() + ".getSkillList02ByAll"); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125; 9.日志配置文件log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.model.Skill=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 10.测试类MyBatisTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.hs.test;/** * 本测试全是采用传统模式：dao层里dao接口写方法，daoImpl实现方法，然后写测试类 */import com.hs.dao.SkillDao;import com.hs.dao.SkillDaoImpl;import org.junit.Test;public class MyBatisTest &#123; /** * 处理结果集为Map类型 */ @Test public void getMap01ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap01ByPk(2)); &#125; /** * 处理结果集为Map类型—通过给字段取别名方式 */ @Test public void getMap02ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap02ByPk(2)); &#125; /** * 处理结果集为Map类型—通过resultMap标签处理 */ @Test public void getMap03ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap03ByPk(2)); &#125; /** * 处理结果集为自定义的类Skill—通过给字段取别名方式 */ @Test public void getSkill01ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkill01ByPk(2)); &#125; /** * 处理结果集为自定义的类Skill—resultMap标签处理 */ @Test public void getSkill02ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkill02ByPk(2)); &#125; /** * 处理结果集为集合（list） */ @Test public void getSkillList01ByAll() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkillList01ByAll()); &#125; /** * 处理结果集为集合（list）—通过resultMap */ @Test public void getSkillList02ByAll() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkillList02ByAll()); &#125;&#125; 11.在测试类中运行相应的测试]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）mybatis介绍、环境搭建]]></title>
    <url>%2F2018%2F08%2F04%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89mybatis%E4%BB%8B%E7%BB%8D%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文主要讲什么是框架、如何学习框架、mybatis介绍、如何用idea搭建mybatis的环境(非maven) 1.什么是框架？你可以理解为就是别人写好的工具类，为我们提供一种解决方案，最后为了提高开发效率 2.为什么学习框架？个人：对你底层开发无任何帮助意义，但是如果看源码，可以学到如何设计的 公司：效益，提高了开发效率 3.怎么去学习框架？需要遵循框架规则： 找到jar包 class文件（java文件） 入口：核心配置文件 通过官方给定的帮助文档，使用其提供API接口 测试 在这段时间里，我将学习ssm框架：MyBatis + SpringMvc + Spring 把它在我学jsp，servlet那段时间学的mvc模式，和我将要学的ssm框架，做一个小小的改动： 4.MyBatis框架是一个什么框架？MyBatis是一个持久层框架 什么是持久化： 狭义：把数据永久性的保存到数据库或者存储器都是持久化 广义：针对于数据库所有的操作，都是持久化操作 Create：增加 Read：读取查询 Update：更新 Delete：删除 MyBatis是一个ORM框架： Object：对象 java对象 Relationship：关系（关系型数据库） Mapping：映射 5.什么是MyBatis？MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis避免了几乎所有的JDBC代码(1.加载驱动2.获取连接3.执行语句对象4.处理结果集5.关闭资源)和手动设置参数以及获取结果集(ResultSet). 就是之前学习的时候，自己封装的数据Dao，需要自己处理数据转换成自己想要的对象 MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 6.idea搭建MyBatis环境（非maven）1).所需要的jar包: mybatis-3.4.6.jar mybatis的包 mysql-connector-java-5.1.45-bin.jar 数据库访问 log4j-1.2.17.jar 日志框架包(在控制台显示sql语句信息等) junit-4.12.jar 单元测试框架 hamcrest-core-1.3.jar junit-4.12所依赖的包 都可以在maven仓库中搜索下载 2).创建一个javase project3).在项目目录下创建一个lib放jar包，然后导入jar包：教程4).idea中项目结构如下： lib放jar包 com.hs.dao放接口，和接口实现类(MyBatis又分为传统模式(需要写接口和接口实现类)和接口代理模式(只需要写接口)) com.hs.model放持久化类(实体Bean、数据库表对应的对象)、XML映射文件(含SQL语句) com.hs.test放测试类 com.hs.util放封装好的工具类 jdbc.properties放连接数据库的信息，在mybatis-config.xml中加载 log4j.properties这是日志框架配置 mybatis-config.xml核心配置文件 5).代码内容1.创建数据库(含后几篇文章的数据表)cy42_mss.sql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283DROP TABLE IF EXISTS `oa_user`;CREATE TABLE `oa_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `sex` varchar(255) DEFAULT NULL, `money` decimal(7,2) DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of oa_user-- ----------------------------INSERT INTO `oa_user` VALUES (&apos;1&apos;, &apos;悟空&apos;, &apos;男&apos;, &apos;888.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;2&apos;, &apos;八戒&apos;, &apos;男&apos;, &apos;999.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;3&apos;, &apos;天蓬元帅&apos;, &apos;女&apos;, &apos;1000.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;4&apos;, &apos;悟能&apos;, &apos;男&apos;, &apos;666.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;5&apos;, &apos;法悟法&apos;, &apos;女&apos;, &apos;544.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;6&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;7&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;14&apos;, &apos;嫦娥&apos;, &apos;女&apos;, &apos;1213.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;15&apos;, &apos;月兔&apos;, &apos;女&apos;, &apos;2113.00&apos;, null);-- ------------------------------ Table structure for skill-- ----------------------------DROP TABLE IF EXISTS `skill`;CREATE TABLE `skill` ( `skill_id` int(11) NOT NULL AUTO_INCREMENT, `skill_name` varchar(255) DEFAULT NULL, `num` int(11) DEFAULT NULL, `fk_teacher_id` int(11) DEFAULT NULL, PRIMARY KEY (`skill_id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of skill-- ----------------------------INSERT INTO `skill` VALUES (&apos;2&apos;, &apos;JS&apos;, &apos;75&apos;, null);INSERT INTO `skill` VALUES (&apos;7&apos;, &apos;CSS&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;8&apos;, &apos;java&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;9&apos;, &apos;vue&apos;, &apos;56&apos;, &apos;9999&apos;);-- ------------------------------ Table structure for sys_role-- ----------------------------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `role_id` int(11) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) DEFAULT NULL, `role_key` varchar(32) DEFAULT NULL, `status` int(1) DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1禁用&apos;, PRIMARY KEY (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of sys_role-- ----------------------------INSERT INTO `sys_role` VALUES (&apos;-100&apos;, &apos;超级管理员&apos;, &apos;ADMIN&apos;, &apos;1&apos;);-- ------------------------------ Table structure for sys_user-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(32) NOT NULL, `password` varchar(128) NOT NULL, `user_name` varchar(32) DEFAULT &apos;&apos;, `status` int(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1删除 2禁用&apos;, `login_time` datetime DEFAULT CURRENT_TIMESTAMP, `ip` varchar(128) DEFAULT NULL, `fk_role_id` int(11) DEFAULT NULL, PRIMARY KEY (`user_id`), KEY `fk_role_id` (`fk_role_id`), CONSTRAINT `sys_user_ibfk_1` FOREIGN KEY (`fk_role_id`) REFERENCES `sys_role` (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of sys_user-- ----------------------------INSERT INTO `sys_user` VALUES (&apos;-999&apos;, &apos;super&apos;, &apos;super&apos;, &apos;唐僧&apos;, &apos;1&apos;, &apos;2018-07-28 18:47:39&apos;, null, &apos;-100&apos;);INSERT INTO `sys_user` VALUES (&apos;-888&apos;, &apos;admin&apos;, &apos;admin&apos;, &apos;悟空&apos;, &apos;1&apos;, &apos;2018-07-03 18:48:21&apos;, null, &apos;-100&apos;); 2.数据库属性文件为了解决中文乱码问题： 自己的mysql编码要设置成utf-8或utf8mb4 如果mysql编码没有设置以上的，需要再url后面加?useUnicode=true&amp;characterEncoding=UTF-8 jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mss?useUnicode=true&amp;characterEncoding=UTF-8jdbc.mysql.username=rootjdbc.mysql.password=root 3.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.dao层SkillDao.java 1具体代码见第二篇 SkillDaoImpl.java 1具体代码见第二篇 5.model层Skill.java(持久化类含对象的属性，get、set方法、toSting方法) 1具体代码见第二篇 SkillMapper.xml(映射文件) 1具体代码见第二篇 6.test层MyBatisTest.java(写测试方法) 12 7.util层(封装好的工具类、可以直接调用)MyBatisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; //输入流 读文件 //1.读取核心配置文件 inputStream = Resources.getResourceAsStream(PATH); //2.创建SqlSession工厂(SqlSessionFactory)相当于Connection sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; /** * 获取sqlsession * @return */ public static SqlSession getSqlsession() &#123; //3.获取SqlSession 相当于执行SQL语句对象PreparedStament预处理对象 //***** SqlSession完成所有的持久化操作CRUD return sqlSessionFactory.openSession(); &#125; /** * 关闭资源 * @param sqlSession */ public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 8.日志框架配置log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.model.Skill=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea导入/移除jar包方式（三种）]]></title>
    <url>%2F2018%2F08%2F04%2Fidea%E5%AF%BC%E5%85%A5-%E7%A7%BB%E9%99%A4jar%E5%8C%85%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[eclipse导入jar只需要简单的右键addxxx就可以，本篇关于idea导入jar的3种方式，用GIF展示 1.添加jar包 方法一：添加lib目录下的所有jar包 方法二：右键jar，选择addxxx 方法三：在方法一的基础上，点击lib下面的相应的jar包 2.删除jar包]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea的jar添加和删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql忘记账号密码]]></title>
    <url>%2F2018%2F07%2F24%2Fmysql%E5%BF%98%E8%AE%B0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如果突然忘记了mysql的账号密码，或者拿着别人的电脑忘记了mysql的账号密码该咋办？？？ 打开mysql.exe和mysqld.exe所在的文件夹,复制路径地址; 打开cmd命令提示符，进入上一步mysql.exe所在的文件夹; 输入命令 mysqld –skip-grant-tables 回车，此时就跳过了mysql的用户验证。注意输入此命令之后命令行就无法操作了，此时可以再打开一个新的命令行。 注意：在输入此命令之前先在任务管理器中结束mysqld.exe进程，确保mysql服务器端已结束运行; 同样也在步骤2之后，然后直接输入mysql，不需要带任何登录参数直接回车就可以登陆上数据库; 输入show databases; 可以看到所有数据库说明成功登陆; 其中mysql库就是保存用户名的地方。输入 use mysql; 选择mysql数据库; 输入show tables;查看所有表，会发现有个user表，这里存放的就是用户名，密码，权限等等账户信息; 输入select user,host,password from user; 来查看账户信息; 更改root密码，输入update user set password=password(‘root’) where user=’root’ and host=’localhost’; 再次查看账户信息，select user,host,password from user; 可以看到密码已被修改。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea初体验和设置]]></title>
    <url>%2F2018%2F07%2F22%2Fidea%E5%88%9D%E4%BD%93%E9%AA%8C%E5%92%8C%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[换了电脑，idea也能跑起来了，软件也需要设置很多地方 设置有很多啊，比如字体，UTF-8，jdk，maven，git，javawebB站视频教程]]></content>
      <categories>
        <category>编程软件</category>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hero+Github搭建个人博客（加优化设置）]]></title>
    <url>%2F2018%2F07%2F21%2FHero-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[哈哈哈哈，自己的博客终于搭好了！！还是写个博客记录一下自己如何搭建的吧 首先来首音乐压压惊吧 &emsp;&emsp;其实自己很久之前就想搭个博客，自己写点东西，但是可能就认为搭个博客很难，自己也懒，就没有搭建，结果今天周六，想给自己休息休息，然后找了教程，用Github+hero搭建了这个博客，一个小时就可以完成的，其实并没有那么难，傻瓜式操作，搭建完之后，发现一些优缺点： 重点是免费的，只需要你注册一个GitHub账号，自己一台电脑，然后就ojbk的事。 自带免费的域名，如果自己有其他需求，也可以购买其他的域名。 但是由于Github是国外的，搭建的博客服务器是在Github上，所有没有VPN访问，是很慢的 搭建的教程B站视频教程&emsp;&emsp;&emsp;&emsp;知乎文字教程&emsp;&emsp;&emsp;&emsp;简书文字教程 搭建成功后主题优化教程B站视频教程&emsp;&emsp;&emsp;&emsp;next主题官方文档&emsp;&emsp;&emsp;&emsp;CSDN个性化设置 写博客markdown语法CSDNmarkdown文字教程&emsp;&emsp;&emsp;&emsp;简书作者教程&emsp;&emsp;&emsp;&emsp;简书官方教程 发现一个比较详细的各种设置的博客博客链接 为了解决博客部署在GitHub，访问博客速度慢的问题，把博客同时部署在coding上简书教程 自己总结的一些点新建一个博客文章hexo n 文章名字tags: - 标签名 ##注意 -后面有空格，还有些markdown语句后也要有空格，修改主题文件时，:后面也有空格categories: ​ - 分类名字 ​ - 子分类名字 头像设置旋转找到本地博客目录下themes\next\source\css\common\components\sidebar\sidebar-author.styl加入：1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; opacity: hexo-config('avatar.opacity') is a 'unit' ? hexo-config('avatar.opacity') : 1; border-radius: 50%; transition: 2s all;&#125;.site-author-image：hover &#123; transform: rotate(360deg);&#125; 侧栏的音乐设置在网易云音乐找到歌，然后点击生成外链播放器，复制代码到blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 代码高亮在markdown中的三个点后加代码语言 页面右上角Github图标设置在这里找到想要的设置 http://tholman.com/github-corners/ 复制代码到themes\next\layout文件_layout.swig 修改文章内链接样式文件themes\next\source\css_common\components\post\post.styl下12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: blue; text-decoration: underline; &#125;&#125; next6.0以上文字字数和阅读时间统计见GitHub：https://github.com/theme-next/hexo-symbols-count-time 动态背景设置在主题文件中 搜素canvas 四个主题 next6.0以上版本，动画背景无效果，见Github：1.https://github.com/theme-next/theme-next-canvas-nest2.https://github.com/theme-next/theme-next-three在主题样式里有注释说明 每次本地写完博客，上传的代码hexo claenhexo ghexo d在博客的根目录下进行 大概就写这些吧，只希望自己博客搭建起来，自己要勤快的写东西！！！！！！]]></content>
      <categories>
        <category>hero</category>
      </categories>
      <tags>
        <tag>hero</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
