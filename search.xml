<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven项目找不到resources下的资源文件]]></title>
    <url>%2F2018%2F09%2F14%2Fmaven%E9%A1%B9%E7%9B%AE%E6%89%BE%E4%B8%8D%E5%88%B0resources%E4%B8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天在写SSM整合，测试的时候，发现resources下的SpringMvc.xml没有扫描到。 首先在web.xml中springmvc.xml的路径如下 12345678910111213141516&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--核心配置文件的位置和名称--&gt; &lt;param-value&gt;/WEB-INF/springmvc.xml&lt;/param-value&gt; &lt;!--&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;--&gt; &lt;/init-param&gt; &lt;!--启动服务器的时候就对DispatcherServlet进行实例化操作--&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 我写的/WEB-INF/springmvc.xml，把springmvc.xml放在WEB-INF下，也依然不能访问，报的错误也很奇怪， 1Handler processing failed; nested exception is java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/Config 自己百度了，都说是少了jstl的包，但是我pom.xml依赖里加了jstl的依赖的，太奇怪了，最后一个解决办法，在pom.xml中加入 123456789101112131415161718192021&lt;build&gt; &lt;!--扫描到resources下的xml等资源文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 加入这个代码，不管xml文件放在resources下还是WEB-INF下，都能扫描到。 但是还是比较纠结报错的问题，为什么报那个错误！？？？？]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>SpringMvc</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VM安装、Ubuntu的安装、Ubuntu设置为中文]]></title>
    <url>%2F2018%2F09%2F14%2FVM%E5%AE%89%E8%A3%85%E3%80%81Ubuntu%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81Ubuntu%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[vm下载及破解：链接: https://pan.baidu.com/s/1znunnWwNIdgrmmd_LGm0-g 密码: d23j Ubuntu镜像下载：https://cn.ubuntu.com/desktop/ 重点！！！，安装Ubuntu的时候，千万不能联网，自己吃了一个大亏！！！！！，其他步骤都可以联网操作，安装Ubuntu有些地方会很慢，请耐心等待 1.安装vm下载好了vm软件，双击 选择安装位置 把这两个√去掉，避免更新 点击这个输入许可证即ok 2.安装Ubuntu官网下载Ubuntu的镜像，然后在打开虚拟机，两种方式新建虚拟机。 这个关键，一定勾选这个，如果选择了第二个，在后面可能会出错，卡住， 这里选择你需要装的系统 选择你系统装的位置和名称 选择你系统的配置大小 给虚拟机分配的磁盘空间大小 然后点击完成，接下来放入系统镜像 然后点击确定，然后开启此虚拟机电源，慢慢等待出现， 这里输入你的虚拟机系统名称和密码，然后continue，最后会提醒你重启，即重启，然后再次打开虚拟机，即安装完成 3.设置Ubuntu系统为中文打开虚拟机 这里会提醒你下载语言包，然后等待下载，可能会很慢。下载成功之后，在里面勾选Chinese。 如果这里出现汉语，但是却是灰色，鼠标把他拖上面去，就变黑了，然后即ok。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu安装</tag>
        <tag>VM安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架总结—学习路线]]></title>
    <url>%2F2018%2F09%2F04%2FSSM%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E2%80%94%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[MyBatis,Spring,SpringMvc,单元测试框架，日志框架Log4J 思维导图源文件获取，用xmind 8 打开github [TOC] MyBatis框架概述 MyBatis是一个持久层框架/ORM框架，会对结果集(查询)映射，对JDBC简单的封装 insert update delete selectOne selectList 持久化 狭义：将数据永久的保存到数据库/磁盘等媒介 广义：针对于数据的操作都称之持久化操作 实体Bean == 持久化类 需要的jar包 mybatis-3.4.6.jar mysql-connector-java-5.1.45-bin.jar CRUD操作 针对于CUD操作，MyBatis需要手动提交事务 MyBatis的API调用过程 package com.hs.util; /** 知识点： final修饰类：不能被继承 修饰方法：不能被重写 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */ import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MyBatisUtils { private MyBatisUtils() { } //不允许实例化 private static final String PATH = “mybatis-config.xml”; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static { //1.静态代码块，只是加载一次 try { //输入流 读文件 //1.读取核心配置文件 inputStream = Resources.getResourceAsStream(PATH); //2.创建SqlSession工厂(SqlSessionFactory)相当于Connection sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); throw new RuntimeException(“加载核心配置文件失败”); } } /** *3.获取SqlSession 相当于 执行SQL语句对象PreparedStament预处理对象 SqlSession完成所有的持久化操作CRUD */ public static SqlSession getSqlsession() { return sqlSessionFactory.openSession(); } /** *6.关闭资源 */ public static void closeSqlSession(SqlSession sqlSession) { if (sqlSession != null) { sqlSession.close(); } } } 1.读取核心配置文件 classpath(src)/mybatis-config.xml 加载数据库信息属性文件jdbc.properties，${key}获取值 自定义设置类型的别名 配置数据库的环境 加载映射文件 2.创建SqlSession工厂 == SqlSessionFactory 3.获取SqlSession 连接数据库 完成针对于数据的CRUD操作 4.执行定制的SQL语句 传统方式 命名空间namespace持久化类的全路径 . 映射文件的ID 接口代理模式——推荐 命名空间namespace固定必须为接口的全路径 映射文件中的ID需要跟接口中的方法名保持一致 查询操作：根据你的接口的返回值 selectOne selectList 5.事务的提交 Spring框架中有事务的管理 6.关闭资源 提取公共的字段代码 无别名 role_id,role_name,role_key,status 有别名 ${alias}.role_id,${alias}.role_name,${alias}.role_key,${alias}.status 概要: 如何用 查询操作 结果集的处理方式 resultType resultMap 结果集可以处理成什么方式？ 返回Map类型 resultType=”map”或者resultType=”java.util.Map” resultMap属性去找resultMap标签 默认情况是自动映射 可以设置别名 返回List类型–&gt;依旧使用Map处理结果 只是在调用方法的时候使用selectList即可 返回对象 可以使用别名方式，保证查询的字段名称和类中的属性名称一致即可使用resultType完成对象的映射 重点resultMap属性 一对一和多对一的关联标签association select方式 结果集映射方式 resultMap id=”JoinResultMapper” type=”User” extends=”BaseResultMapper”&gt; &lt;!– –&gt; 一对多的关联标签collection 方式 select方式 &lt;!–在结果集中找到role_id这个字段，然后传给命名空间com.hs.dao.UserDao下id为getUserByFk的语句， 返回的结果集字段为userList，类型为java.util.List，里面装的类型是com.he.model.User这个类型 –&gt; &lt;collection property=”userList” javaType=”java.util.List” ofType=”User” column=”role_id” select=”com.hs.dao.UserDao.getUserByFk”/&gt; 结果集映射方式 &lt;collection property=”userList” javaType=”list” ofType=”com.hs.model.User” resultMap=”com.hs.dao.UserDao.BaseResultMapper”/&gt; &lt;!– –&gt; 注意：ofType属性是必须要填写 模糊查询 concat(‘%’,#{name},’%’) 动态的SQL语句 在映射文件中获取数据的方式 #() #()默认是预处理模式 $() $()默认是直接拼接到SQL语句当中，并且需要提供KEY值，推荐在排序使用 if标签 test属性 test=”类中属性或者Map中的KEY或者使用@Param指定KEY” where标签 如果有内容，在内容的最前面加入where关键字，并且去掉内容最前面的and或者or and user_name like concat(‘%’,#{name},’%’) and sex = #{sex} set标签 如果有内容，在内容的最前面加入set关键字，并且去掉内容最后面的逗号 user_name = #{user_name}, sex = #{sex}, money = #{money}, trim标签 主要的目的是完成对动态添加SQL的拼写— 一般可以用来完成set和where功能 &lt;trim prefix=”当发现有内容的时候,你在内容的最前面想加入什么内容” prefixOverrides=”当发现有内容的时候,你在内容的最前面想抹掉什么内容” suffix=”当发现有内容的时候,你在内容的最后面面想加入什么内容” suffixOverrides=”当发现有内容的时候,你在内容的最后面想抹掉什么内容”&gt; foreach标签 如果你传递的数据的形参为一个数据，并且数据类型是数组或者List collection属性只能取array || list 如果你传递的是Map或者对象(都有一个存储集合的属性或者KEY) collection=”集合对应的Map中的KEY或者类中的属性” 传递多个参数 /** 传递多个参数 1.当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 2.#{值}，默认为arg0，arg1…..或param1，param2，，， 若在dao注解了@xxx(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值 */ User getUser(@Param(“account”) String account, @Param(“password”) String password); 接口代理模式和传统模式 接口代理模式 只需要写接口，在测试类中调用，接口编程: 什么是接口? 简单理解:接口就是定义规范 接口返回类型跟你设置的resultMap或者resultType对应上即可,但是会根据你返回的类型完成selectone或者selectList操作 接口里方法如何写：sql语句返回的结果集类型 sql语句的id(要传的值); eg:List getSkillLike02(String name); List为SQL语句返回的结果集类型，getSkillLike02为映射文件中SQL语句的id，String name是传给映射文件的值 映射文件命名空间为接口的全路径 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是List，如果是List，也是List 传统模式 需要写接口，接口实现类，测试类， 映射文件命名空间为持久化类的全路径 单元测试框架概述 单元(方法)就是对类中方法的测试 命名规则 类名 UserDaoTest 方法 testLoadMethod 需要的jar包 hamcrest-core-1.3.jar junit-4.12.jar 如何使用 @Before @Before //再每个单元测试运行之前都要进行这个方法 public void init() { this.arithmeticService = new ArithmeticServiceImpl(); //想用哪个功能就实例化哪个 } @Test @Test //测试这个方法 public void test01() {} 日志框架Log4J概述 在MyBatis中显示出SQL语句，信息等，放在classpath路径下log4j.properties 需要的jar包 log4j-1.2.17.jar 如何使用 Global logging configuration log4j.rootLogger=ERROR, stdout MyBatis logging configuration… 如果要显示SQL语句，那么这个位置需要配置为命名空间 log4j.logger.com.shxt.model.Skill=TRACE Console output… log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n SpringMVC框架概述 核心配置文件DispatcherServlet的规则 默认情况下：WEB-INF/[servlet-name]-servlet.xml springmvc org.springframework.web.servlet.DispatcherServlet 2 springmvc &lt;!– / 所有的资源访问都需要经过 DispatcherServlet处理 路径 href src….. 区分 /* 和 / –&gt; / 自定义规则 springmvc org.springframework.web.servlet.DispatcherServlet contextConfigLocation /WEB-INF/springmvc.xml 1 springmvc / 需要的jar包 spring-aop-4.3.6.RELEASE.jar spring-beans-4.3.6.RELEASE.jar spring-context-4.3.6.RELEASE.jar spring-context-support-4.3.6.RELEASE.jar spring-core-4.3.6.RELEASE.jar spring-expression-4.3.6.RELEASE.jar spring-web-4.3.6.RELEASE.jar spring-webmvc-4.3.6.RELEASE.jar commons-logging-1.2.jar 控制器专题 控制传递的参数 @RequestMapping(path = “/param02”,params = {“hs!=tomcat”,”method=add”}) 形参 默认会对形参中的类进行自动的实例化操作 页面跳转方式 默认请求转发，能访问WEB-INF下 重定向，不能访问WEB-INF下 概要: 指明前缀，请求转发”forward:/hs011.jsp”,重定向redirect:/xxx 返回类型 ModelAndView JSP的请求转发的视图解析器 &lt;!–jsp请求转发视图解析器 请求转发jsp页面的时候，在路径上加入前缀和后缀 –&gt; void 默认情况下是按照路径去请求转发找到对应的JSP页面_不推荐使用 String 推荐使用，跳转到页面或者另外的Controller，也满足JSP的请求转发的视图解析器如果使用了前缀的标识那么一定是从Controller跳转到另一个Controller 任意 ResponseEntity @ResponseBody—推荐，常用于JSON串的处理 针对于你返回的数据的类型进行转换，可以转换任意类型，但是需要第三方库的支持 情况说明 字符串默认可以自动转换为文本 如果是其他类型需要使用第三方Jackson的支持，将返回的数据转换成JSON格式的字符串 Jackson的jar包 jackson-annotations-2.8.1.jar jackson-core-2.8.1.jar jackson-databind-2.8.1.jar 访问路径 路径的设置 /sys/user /sys/*或者/sys/**—不推荐使用 /sys/user/{hs}占位符路径 使用占位符，一般只是传递主键和简单的字符串，完成REST风格的路径，优先级比通配符高，hs接收传过的值 请求方式的说明 HTML页面中有且只有GET/POST请求 通过设置过滤器完成了8种请求方式 &lt;!–http的请求转换过滤器 过滤器使html中支持除了get、post，的其他请求put，delete，patch–&gt; httpMethodFilter org.springframework.web.filter.HiddenHttpMethodFilter httpMethodFilter springmvc 为了支持其他的请求方式，把method都改为post，然后加入一个 value不分大小写，name=xxx固定 get：查询 post：添加 put：更新 delete：删除 静态资源(图片、js、css)排除方案，不经过DispatcherServlet &lt;!–4.静态资源(图片、js、css之类的)(让这些资源不经过servlet处理)的 处理方式一 推荐方式–&gt; &lt;mvc:default-servlet-handler default-servlet-name=”default”/&gt; 客户端传递数据转换成服务端对应的数据类型 @RequestParam注解 public ModelAndView test02(@RequestParam(value = “user_name”, required = false) String name, @RequestParam(name = “user_id”, required = false, defaultValue = “1111”) Integer id) { System.out.println(“姓名” + name); System.out.println(“ID” + id); return null; } name=”” | value=””对应传递数据的名称 required=”true”默认值 defaultValue=”设置默认值” 简写方式 推荐：传递的name和形参中的名称保持一致即可 数组 超链接获取数组 传递数组 @GetMapping(“/client04”) public ModelAndView test01(@RequestParam(name = “role_id”) Integer[] roles) { System.out.println(Arrays.asList(roles)); return null; } 复选框传递数组 篮球 足球 看书 简写方式 @GetMapping(“/client05”) public ModelAndView test02(String[] hobby) { if (hobby != null) { System.out.println(Arrays.asList(hobby)); } else { System.out.println(“您没有爱好！”); } return null; } 文本框传递数据 简写方式 @GetMapping(“/client06”) public ModelAndView test03(String[] hobby) { System.out.println(Arrays.asList(hobby)); return null; } 多选列表传递数组 音乐 看书 足球 简写方式 @GetMapping(“/client07”) public ModelAndView test04(String[] hobby) { if (hobby != null) { System.out.println(Arrays.asList(hobby)); } else { System.out.println(“您没有爱好！！”); } return null; } 对象 简单对象，只是需要你传递的名称跟类中的属性名保持一致即可 @GetMapping(“/client08”) public ModelAndView test01(User user, String user_name, String sex) { System.out.println(user); System.out.println(“—–依然可以使用简单方式—-“); System.out.println(user_name); System.out.println(sex); return null; } 多个对象如果属性不相同，那么SpringMvc框架会帮我们自动完成转换 @GetMapping(“/client09”) public ModelAndView test02(User user, Role role) { System.out.println(user); System.out.println(“—–角色—-“); System.out.println(role); return null; } 关联对象，一个对象里有另外一个对象 public class User { private Role role; 后台处理 @GetMapping(“/client10”) public ModelAndView test03(User user, Role role) { //设置关联关系 user.setRole(role); System.out.println(user); return null; } 前台处理 多个对象进行关联方式二：前台处理 姓名： 性别： 角色名称：&lt;%–name=类中.属性–%&gt; 提交数据 @GetMapping(“/client11”) public ModelAndView test04(User user) { System.out.println(user); return null; } 多个对象如果出现同属性问题，需要借助第三方类来区分数据的归属情况 不同对象同属性传递借助第三方类 用户 姓名： 性别： 角色信息： 学生 姓名： 性别： 提交数据 @GetMapping(“/client12”) public ModelAndView test05(HsModel hsModel) { System.out.println(hsModel.getStudent()); System.out.println(hsModel.getUser()); return null; } 第三方类含这些类 public class HsModel { private User user; private Student student; Map 姓名：&lt;input type=”text” name=”query[‘user_name’]”&lt;%–属性[‘需要设置的key值’]–%&gt;&gt; 性别： 提交数据 @GetMapping(“/client13”) public ModelAndView test01(HsModel hsModel) { System.out.println(hsModel.getQuery()); return null; } 需要借助第三方类的支持 public class HsModel { private Map&lt;String,Object&gt; query; 一般做分页查询的时候使用 query[“设置Map中的KEY”] List 姓名： &lt;%–设置第1条数据的user_name–%&gt; 性别：&lt;%–设置第1条数据的sex–%&gt; 姓名： &lt;%–设置第2条数据的user_name–%&gt; 性别： 姓名： &lt;%–设置第6条数据的user_name,同时也设置了这个list长度是6–%&gt; 性别： 提交数据 @Controller public class ListTypeDemoController { @GetMapping(“/client14”) public ModelAndView test01(HsModel hsModel) { System.out.println(hsModel.getStudentList()); return null; } } 需要借助第三方类的支持 public class HsModel { private List studentList; 一般做批量添加 占位符传递数据 占位符传递数据 普通接收数据 @GetMapping(“/client15/{id}/{name}”) public ModelAndView test01( @PathVariable(“id”) int user_id,/占位符的名字和形参不一样，在PathVariable中需要写占位符的名字/ @PathVariable String name,/一样则可以省略/ String sex /@RequestParam的简写方式/ ) { System.out.println(user_id); System.out.println(name); System.out.println(sex); return null; } Map接收数据 @GetMapping(“/client16/{id}/{name}”) public ModelAndView test01( @PathVariable Map&lt;String,Object&gt; map,/占位符的名字作为key值/ String sex /@RequestParam的简写方式/ ) { System.out.println(map); System.out.println(sex); return null; } JSON数据 服务端使用@RequestBody接收数据 JSON数据—Java对象互转 Map @Test public void test01() throws IOException { Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(“user_name”,”悟空”); map.put(“age”, 500); map.put(“hobby”,/静态初始化数据/ new String[]{“music”,”book”}); System.out.println(“转换之前的Map:”+map); //1.java对象转JSON格式的字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(map); System.out.println(“java对象转JSON格式的字符串:”+jsonString); //2.JSON字符串转换为java对象 Map&lt;String, Object&gt; hsMap = objectMapper.readValue(jsonString, Map.class); System.out.println(“JSON字符串转换为java对象:”+hsMap); } 集合 @Test public void test03() throws Exception { List userList = new ArrayList&lt;&gt;(); User user = new User(); user.setUser_id(100); user.setUser_name(“八戒”); user.setSex(“男”); Role role = new Role(); role.setRole_name(“超级管理员”); user.setRole(role); userList.add(user); user = new User(); user.setUser_id(100); user.setUser_name(“悟空”); user.setSex(“男”); role = new Role(); role.setRole_name(“管理员”); user.setRole(role); userList.add(user); System.out.println(“转换之前的List:”+userList); //1.java对象转json字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(userList); System.out.println(“java对象转json字符串:”+jsonString); //2.json字符串转java对象 System.out.println(“组成的List:”+objectMapper.readValue(jsonString, List.class)); //组成的是List JavaType t = objectMapper.getTypeFactory().constructParametricType(List.class, User.class); List tempList = objectMapper.readValue(jsonString, t); System.out.println(“json字符串转java对象:”+tempList); } 自定义对象 @Test public void test02() throws Exception { User user = new User(); user.setUser_id(100); user.setUser_name(“八戒”); user.setSex(“男”); Role role = new Role(); role.setRole_name(“超级管理员”); //建立联系 user.setRole(role); System.out.println(“转换之前的User:”+user); //1.java对象转json字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(user); System.out.println(“java对象转json字符串:”+jsonString); //2.json字符串转java对象 User hsUser = objectMapper.readValue(jsonString, User.class); System.out.println(“json字符串转java对象:”+hsUser); } JavaScript对象—JSON格式字符互转 //给对象赋值的几种方 式 //javascript中，var 对象 = {}大括号，数组[] var obj = { user_name: “悟空”, sex: “男”, hobby: [“basktball”, “football”], classInfo: { class_name: “计算机”, number:8 } }; obj.nickname = “齐天大圣”; obj[“age”] = 500; console.log(obj); //1.将JavaScript对象转换为JSON格式的字符串 var jsonStr = JSON.stringify(obj); console.log(jsonStr); //2.将JSON格式的字符串转换为JavaScript对象 var hs = JSON.parse(jsonStr); console.log(hs); 文件上传 配置上传文件的解析器，如果发现你是二进制流的方式传递数据，那么会使用该解析器处理数据 数据类型的转换 日期类型的转换@@DateTimeFormat /** 接收日期类型的客户端传递数据，简写方式 没有写注解，就写 2018/8/14 15:31:20 写了注解就按照他的格式来，如果没有写时间，你输入了时间也不会认 如果一个类中也有这样的属性，同时接收这个时间，注解里也要写格式 * @return */ @GetMapping(“/client01”) public ModelAndView test01( @DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”) Date mydate, User user) { System.out.println(mydate); System.out.println(user); return null; } @InitBinder @InitBinder public void init01(WebDataBinder binder) { //监控要转换(String)的数据类型 binder.registerCustomEditor(String.class, /匿名对象/new PropertyEditorSupport() { //重写了setAsText方法 @Override public void setAsText(String text) throws IllegalArgumentException { System.out.println(“之前接收的值—-“ + text); //对数据重新处理赋值，赋值给形参user_name this.setValue(“对数据处理之后的值—-“ + text + “悟空”); } }); //监控Integer类型 binder.registerCustomEditor(Integer.class, new PropertyEditorSupport() { @Override public void setAsText(String text) throws IllegalArgumentException { System.out.println(text); this.setValue(“999”); } }); } 客户端传递数据中文乱码 get请求 tomcat7 全局设置 在tomcat里的sever.xml中修改 这一行加入URIEncoding=”UTF-8” 单项目设置 user_name = new String(user_name.getBytes(“ISO8859-1”),”UTF-8”); tomcat8 默认为UTF-8，不需要修改 post请求 在web.xml中配置过滤器 characterEncodingFilter org.springframework.web.filter.CharacterEncodingFilter encoding UTF-8 forceRequestEncoding true forceResponseEncoding true characterEncodingFilter /* 服务端传递数据到客户端 返回类型ModelAndView传递数据 指明KEY @GetMapping(“/server02”) public ModelAndView test02() { ModelAndView mav = new ModelAndView(); // mav.addObject() 没有指明KEY //一步一步的追源码，发现一个ModelMap的类实例化对象.用它的addAttribute方法添加，ModelMap又是继承了HashMap mav.addObject(“title”, “通过ModelAndView传递数据”); mav.addObject(“hs”, “中国和尚”); mav.addObject(“class”, “计算机计科”); mav.addObject(“number”, 11); mav.setViewName(“jsp/result02”); //请求转发，通过视图解析器 return mav; } 没有指明KEY，默认传递数据的KEY的名称为类名的首字母小写 @GetMapping(“/server03”) public ModelAndView test03() { ModelAndView mav = new ModelAndView(); mav.addObject(“integer”, 100); mav.addObject(200); mav.addObject(“string”, “字符串”); mav.addObject(“悟空”); // 规则：客户端获取没有加key的数据，默认key正常是数据对应的类型的首字母小写 Integer—integer String—string // 两个key一样的,只认最后一个 // double是关键字，不能${double},只能${requestScope[“double”] } double a = 123.123; mav.addObject(a); User user = new User(); user.setMydate(new Date()); mav.addObject(user); mav.setViewName(“jsp/result03”); //请求转发，通过视图解析器 return mav; } 返回类型String传递数据 Map @GetMapping(“/server04”) public String test01(Map&lt;String,Object&gt; map) { map.put(“title”, “Map在形参中定义，可以传递数据”); map.put(“hs”, “123”); map.put(“class”, “12222”); map.put(“number”, 1111); return “jsp/result04”; //通过请求转发视图解析器 } ModelMap @GetMapping(“/server05”) public String test02(ModelMap modelMap) { modelMap.addAttribute(“title”, “ModelMap进行传递数据”); modelMap.addAttribute(“hs”, “123”); modelMap.addAttribute(“class”, “12222”); modelMap.addAttribute(“number”, 1111); return “jsp/result04”; //通过请求转发视图解析器 } Model @GetMapping(“/server06”) public String test03(Model model) { model.addAttribute(“title”, “Model接口进行传递数据”); model.addAttribute(“hs”, “123”); model.addAttribute(“class”, “12222”); model.addAttribute(“number”, 1111); return “jsp/result04”; //通过请求转发视图解析器 } @ResponseBody返回JSON数据格式 返回JSON格式数据 Map @GetMapping(“/json03”) @ResponseBody //把java数据转换为JSON的字符串 存在BUG(IE浏览器不好使，解决办法在springmvc.xml配置) public Map&lt;String, Object&gt; test03() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(“name”, “马老板”); map.put(“sex”, “男”); return map; } List @GetMapping(“/json04”) public @ResponseBody List&lt;Map&lt;String, Object&gt;&gt; test04() { List&lt;Map&lt;String,Object&gt;&gt; tempList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(“name”, “马老板”); map.put(“sex”, “男”); tempList.add(map); map = new HashMap&lt;String, Object&gt;(); map.put(“name”, “悟空”); map.put(“sex”, “男”); tempList.add(map); return tempList; } IE浏览器的下载问题 text/html;charset=UTF-8 text/plan;charset=UTF-8 application/json;charset=UTF-8 返回日期格式的问题 @JsonFormat 需要在user的date属性下加注解 // 相放哪里就放哪里，pattern:格式，timezone:时区，这是设置东八区 // @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”) Date mydate; // @JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”,timezone = “GMT+8”) // @JsonFormat(pattern = “yyyy-MM-dd”,timezone = “GMT+8”) public Date getMydate() { return mydate; } 使用SpringMvc配置 前台如何接收 ${title} ${requestScope.hs} –指明范围了的 ${requestScope[“class”]} ${number} —默认情况下是从pageContext-&gt;request-&gt;session-&gt;application下开始寻找 ${requestScope.integer } ${requestScope.string } ${requestScope[“double”] }—–因为double是关键字，所以不能.double ${requestScope.user.mydate } ${requestScope[“user”][“mydate”] } 文件的上传和下载 上传 &lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt; Title 单文件上传 标题： 文件： 文件上传 $(function () { //元素选择器 $(“button”).click(function () { //1.获取上传文件的对象，是数组，获取的第一个 var myfile = $(“#myfile”).prop(“files”)[0]; //2.判断文件是否有 if (myfile) { //3.获取文件名称 var fileName = myfile.name; //4.获取文件的后缀名称 var ext = fileName.substring(fileName.lastIndexOf(“.”) + 1); //5.设置允许上传的文件后缀名称 var allowFileTypes = [“jpg”, “png”, “gif”, “jpeg”, “dmp”, “rar”]; //6.设置一个标识，用来做判断 var flag = false; //循环判断上传格式是否正确 for (var i = 0; i &lt; allowFileTypes.length; i++) { if (ext == allowFileTypes[i]) { flag = true; break; } } if (!flag) { alert(“您上传的文件格式不正确，允许的格式为：” + allowFileTypes.join(“ | “)); return false; } //7.判断文件的大小 if (myfile.size &gt; 20 1024 1024) { alert(“您上传的文件过大，请重新选择”) } return false; //8.表单提交 ${“#uploadForm”}.submit(); } else { alert(“请选择您要上传的文件”); return false; } }) }) 要求 form表单传递数据 请求必须为POST请求 使用二进制流的方式传递数据 enctype=”multipart/form-data” 文件域 工具 Servlet3.0 Commons-FileUpload @PostMapping(“/upload01”) public ModelAndView test01(String title, MultipartFile myfile, HttpServletRequest request) throws IOException { ModelAndView mav = new ModelAndView(); // System.out.println(title); //1.获取上传文件的名称 String fileName = myfile.getOriginalFilename(); mav.addObject(“fileName”, fileName); //2.判断文件名称是否有值,isEmpty是这个字符串的length=0为true if (!fileName.isEmpty()) { //3.获取服务器的绝对路径 String path = request.getServletContext().getRealPath(“/upload”); //4.建立联系 File folder = new File(path); //5.判断该文件是否存在，不存在则创建文件夹 if (!folder.exists()) { folder.mkdirs(); //创建文件夹 } //6,获取上传文件的后缀名称 String ext = FilenameUtils.getExtension(fileName); //7.创建新的文件名称 //String newFileName = UUID.randomUUID().toString() + “.” + ext; //或者用时间戳创建名称 String newFileName = new Date().getTime() + “_” + new Random().nextInt(100000) + “.” + ext; mav.addObject(“newFileName”, newFileName); // System.out.println(newFileName); //8.文件上传，File.separator为斜线 myfile.transferTo(new File(path + File.separator + newFileName)); } mav.addObject(“hs”, “和尚”); mav.setViewName(“jsp/result”); /*System.out.println(“测试是否可以获取正常的数据:”+title); System.out.println(“=====”); System.out.println(“文件的MIME类型 :”+myfile.getContentType()); System.out.println(“文件NAME属性对应的值 :”+myfile.getName()); System.out.println(“上传文件的名称 :”+myfile.getOriginalFilename()); System.out.println(“上传文件的大小 :”+myfile.getSize());*/ return mav; } commons-fileupload-1.3.1.jar 下载 @GetMapping(“/download”) public ResponseEntity&lt;byte[]&gt; test02(String newFileName, String fileName, HttpServletRequest request) throws IOException { //获取服务端的绝对路径 String path = request.getServletContext().getRealPath(“/upload/“); HttpHeaders headers = new HttpHeaders(); //设置相应的内容为流 headers.setContentType(MediaType.TEXT_EVENT_STREAM); //设置下载的名称–和中文乱码的问题 headers.setContentDispositionFormData(“attachment”, new String(fileName.getBytes(“UTF-8”), “ISO8859-1”) ); //找到文件 File file = new File(path + File.separator + newFileName); return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file),/将文件转换为byte数组/ headers, HttpStatus.CREATED); } 需要的jar包 commons-io-2.4.jar 异常处理 注解方式 局部处理@ExceptionHandler 全局处理@ControllerAdvice+@ExceptionHandler XML方式 jsp/error jsp/error jsp/error jsp/error 拦截器 拦截器有且只能拦截Controller Spring框架概述 Spring是IoC(DI)和AOP的容器框架 IoC #控制反转：白话：让别人为我们服务，帮我new对象 管理Bean的声明周期 范围Scope 默认情况下是单例模式single 多例模式prototype request session 实现方式有两种 注解方式 @Component @Controller @Service @Repository DI(注入方式) #白话：注入就是实例化，赋值 Setter方式–推荐 XML方式 com.hs.model.User类中的属性必须要提供set方法 形式如下 &lt;property name=”属性名” value=”值” ref引用对象 标准写法 缩写 p方式(p方式的引用) 各个类型如何注入 普通属性的值 value 集合 list/set/array map/props 自定义类型 内部使用 外部实例化，内部使用ref进行引用 外部实例化，使用p:xxx-ref引用 接口注入实现类(接口回调) 外部定义接口实现类实例化，内部使用进行引用 外部定义接口实现类实例化，使用p:xxx-ref引用 util:list | set | map | properties—-不常用 内部定义，内部引用 外部定义，p引用 注解方式 @Autowired–推荐 @Qualifier(“bookDaoImpl”)，指明具体的id @Resource 概要: 区别 @Autowired先按类型再按照名称查找 @Resource先按名称再按照类型查找 构造函数注入方式 XML方式 标准写法 缩写 各个类型如何注入 普通属性的值 value 集合 list/set/array map/props 自定义类型 内部使用 外部实例化，内部使用ref进行引用 接口注入实现类(接口回调) 外部定义接口实现类实例化，内部使用进行引用 注解方式 @Autowired–推荐 @Resource @Value注解注入值 @Value(“我是其他属性”) private String anotherValue; 或者写在set方法上 注入普通字符串 注入操作系统属性 注入表达式运算结果 注入其他bean的属性。 注入文件内容。 注入网址信息。 注入属性文件。 AOP #白话：在不改变原来代码的基础上，增加新的功能，AOP的底层的实现就是使用的是Java的动态代理 概念 Aspect Oriented Programming with Spring 面向切面（方面）编程 面向切面编程是面向对象编程的一个补充而已 白话：我的理解—-&gt;在不改变原来的代码的基础上增强（增加）新的功能 静态代理 动态代理 CGLIB动态代理 proxy-target-class=”true” 切面 @Aspect aop:aspect 连接点 表达式 execution( com.hs..service.Service.*(**) 切点 @PointCut &lt;aop:point-cut 通知 前置通知 不管程序是否正确都会执行 后置通知 不管程序是否正确都会执行 返回通知 只有程序是正确的时候才会执行，并且可以获取运行后的数据 异常通知 只有程序是错误的时候才会执行 环绕通知——-不推荐！！！ 代理对象 JdbcTemplate工具类 配置数据源 配置工具类 SQL语句 查询 返回Map数据 @Test public void test01() { /String sql = “select from oa_user where user_id = 3”; Map&lt;String, Object&gt; map = this.jdbcTemplate.queryForMap(sql);*/ String sql = “select * from oa_user where user_id = ?”; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 2); System.out.println(map); } 返回List数据 @Test public void test02() { String sql = “select * from oa_user”; System.out.println(jdbcTemplate.queryForList(sql)); } 返回一个值 @Test public void test03() { String sql = “select count(*) from oa_user”; System.out.println(jdbcTemplate.queryForObject(sql, Integer.class)); } 返回一个对象 @Test public void test04() { String sql = “select * from oa_user where user_id = ?”; User user = jdbcTemplate.queryForObject(sql, /匿名内部类/new RowMapper() { @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException { User user = new User(); user.setUser_id(rs.getInt(“user_id”)); user.setUser_name(rs.getString(“User_name”)); user.setSex(rs.getString(“sex”)); user.setMoney(rs.getBigDecimal(“money”)); user.setBirthday((Date) rs.getObject(“birthday”)); return user; } }, 2); System.out.println(user); } 返回一个List&lt;对象&gt; @Test public void test06() { String sql = “select * from oa_user where user_name like concat(‘%’,?,’%’)”; List userList = jdbcTemplate.query(sql,/处理一条一条的数据，，，可以不用写/new BeanPropertyRowMapper(User.class), “沙僧”); System.out.println(userList); } 增删改 @Test public void test07() { String sql1 = “insert into oa_user(user_name,sex,money,birthday) values(?,?,?,?)”; String sql2 = “update oa_user set user_name=?,sex=? where user_id = ?”; String sql3 = “delete from oa_user where user_id = ?”; int num1 = jdbcTemplate.update(sql1, “唐僧”, “男”, 220.00, “2018-8-9”); int num2 = jdbcTemplate.update(sql2, “和尚”, “男”, 16); int num3 = jdbcTemplate.update(sql3, 17); System.out.println(num1+”–”+num2+”—“+num3); } 事务 事务 概念 一个工作单元由多个动作组成，只有动作全部正确的时候才能执行成功，如果有一个动作错了，其他的动作都是无效的（回滚） 关键属性（ACID） 原子性(atomicity):事务是一一个原子操作,由一系列动作组成，事务的原子性确保动作要么全部完成要么完全不起作用 一致性(consistency):一旦所有事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的一-致性状态中. 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏 持久性(durability): 一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，通常情况下，事务的结果被写到持久化存储器中 事务管理 事务管理就是管理事务，用来确保数据的完整性和一致性. 事务管理器 就是对事务管理的实现，数据的完整性和一致性（数据库—&gt;数据源） 传播性 当你事务方法被另一个事务方法调用的时候，需要检查其事务的传播性 调用过程 XML版—推荐 #XML版本完成事务，需要跟AOP配合使用 配置事务管理器 告知哪些方法是需要被事务管理器进行管理的 &lt;!–6.告知哪些方法是需要被事务管理器进行管理的， 等价于注解版，在方法上面写@Transactional –&gt; &lt;tx:advice transaction-manager=”transactionManager” id=”serviceAdvice”&gt; tx:attributes &lt;tx:method name=”get*” read-only=”true”/&gt; &lt;tx:method name=”load*” read-only=”true”/&gt; &lt;tx:method name=”list*” read-only=”true”/&gt; &lt;tx:method name=”find*” read-only=”true”/&gt; &lt;tx:method name=”query*” read-only=”true”/&gt; &lt;tx:method name=”sel*” read-only=”true”/&gt; &lt;tx:method name=”check*” read-only=”true”/&gt; &lt;tx:method name=”valid*” read-only=”true”/&gt; &lt;tx:method name=”login*” read-only=”true”/&gt; &lt;tx:method name=”*” propagation=”REQUIRED”/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 配置AOP和tx:advice配合使用，告知我哪个层次下的方法会被事务管理器进行管理 &lt;aop:config proxy-target-class=”true”&gt; &lt;aop:pointcut id=”servicePointCut” expression=”execution( com.hs..service.Service.*(..))”/&gt; &lt;aop:advisor advice-ref=”serviceAdvice” pointcut-ref=”servicePointCut”/&gt; &lt;/aop:config&gt; 启动事务注解 &lt;tx:annotation-driven transaction-manager=”transactionManager” proxy-target-class=”true”/&gt; 注解版 配置事务管理器 启动事务注解 &lt;!–6.启动事务注解：告知该方法是事务方法(一个错，其他全部错)，而不是普通方法 transaction-manager=”transactionManager”可以省略 –&gt; &lt;tx:annotation-driven transaction-manager=”transactionManager” proxy-target-class=”true”/&gt; 在方法或者类的前面@Transactional，告之是事务方法 @Transactional的属性 @Transactional(readOnly = true) //只读，一般只做查询操作使用 @Transactional(noRollbackForClassName = “RuntimeException”) //遇见这个异常，数据就不会回滚 传播性的行为 默认：@Transactional(propagation = Propagation.REQUIRED) @Transactional(propagation = Propagation.REQUIRES_NEW) XMind: ZEN - Trial Version]]></content>
      <categories>
        <category>SSM学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十五）Spring事务XML版-推荐]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89Spring%E4%BA%8B%E5%8A%A1XML%E7%89%88-%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[在XML版中完成注解@Transactional的功能 源码获取github [TOC] 1.项目结构，数据库表跟注解版一样2.XML配置1234567891011121314151617181920212223242526272829303132333435&lt;!--5.配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt;&lt;/bean&gt;&lt;!--6.告知哪些方法是需要被事务管理器进行管理的， 等价于注解版，在方法上面写@Transactional --&gt;&lt;tx:advice transaction-manager="transactionManager" id="serviceAdvice"&gt; &lt;tx:attributes&gt; &lt;!--哪些方法，也可以设置属性，对应注解版的属性--&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;tx:method name="load*" read-only="true"/&gt; &lt;tx:method name="list*" read-only="true"/&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;tx:method name="query*" read-only="true"/&gt; &lt;tx:method name="sel*" read-only="true"/&gt; &lt;tx:method name="check*" read-only="true"/&gt; &lt;tx:method name="valid*" read-only="true"/&gt; &lt;tx:method name="login*" read-only="true"/&gt; &lt;!--这是方法都是查询的方法,设置为只读--&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--7.配置AOP和tx:advice配合使用，告知我哪个层次下的方法会被事务管理器进行管理--&gt;&lt;aop:config proxy-target-class="true"&gt; &lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt; &lt;aop:advisor advice-ref="serviceAdvice" pointcut-ref="servicePointCut"/&gt;&lt;/aop:config&gt;&lt;!--8.启动事务注解：告知该方法是事务方法(一个错，其他全部错)，而不是普通方法 transaction-manager="transactionManager"可以省略--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt; 意思就是：我监控的是com.hs..service.*Service：service层下以Service结尾的类下的：这些方法 1234567891011 &lt;tx:method name="get" read-only="true"/&gt; &lt;tx:method name="load" read-only="true"/&gt; &lt;tx:method name="list" read-only="true"/&gt; &lt;tx:method name="find" read-only="true"/&gt; &lt;tx:method name="query" read-only="true"/&gt; &lt;tx:method name="sel" read-only="true"/&gt; &lt;tx:method name="check" read-only="true"/&gt; &lt;tx:method name="valid" read-only="true"/&gt; &lt;tx:method name="login" read-only="true"/&gt; &lt;!--这是方法都是查询的方法,设置为只读--&gt;&lt;tx:method name="*" propagation="REQUIRED"/&gt; 3.其他代码跟注解版一样，只是去掉@Transactional]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十四）Spring事务]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89Spring%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Spring 事务、事务管理、事务管理器、事务的传播性、@Transactional 源码获取github [TOC] 1.实例引入和尚经理跟某个书店沟通业务，王经理有一个需求需要买书的操作(暂时只能让买一本书，使用会员卡) 需求：买一本书===&gt;需要的步骤 和尚经理思考： 查询书的价格 判断余额是否充足（获取余额的信息） 会员中的余额 — 书价格 判断库存是否充足（获取书库存数量） 库存书的数量 — 1 2.数据库表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SET FOREIGN_KEY_CHECKS=0;-------- Table structure for tx_book------DROP TABLE IF EXISTS `tx_book`;CREATE TABLE `tx_book` ( `isbn` varchar(255) NOT NULL, `book_name` varchar(255) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-------- Records of tx_book------INSERT INTO `tx_book` VALUES (&apos;1001&apos;, &apos;西游记&apos;, &apos;50&apos;);INSERT INTO `tx_book` VALUES (&apos;1002&apos;, &apos;水浒&apos;, &apos;60&apos;);INSERT INTO `tx_book` VALUES (&apos;1003&apos;, &apos;三国&apos;, &apos;70&apos;);-------- Table structure for tx_book_stock------DROP TABLE IF EXISTS `tx_book_stock`;CREATE TABLE `tx_book_stock` ( `id` int(11) NOT NULL AUTO_INCREMENT, `isbn` varchar(255) DEFAULT NULL, `stock` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-------- Records of tx_book_stock------INSERT INTO `tx_book_stock` VALUES (&apos;1&apos;, &apos;1001&apos;, &apos;10&apos;);INSERT INTO `tx_book_stock` VALUES (&apos;2&apos;, &apos;1002&apos;, &apos;10&apos;);INSERT INTO `tx_book_stock` VALUES (&apos;3&apos;, &apos;1003&apos;, &apos;10&apos;);-------- Table structure for tx_user------DROP TABLE IF EXISTS `tx_user`;CREATE TABLE `tx_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(255) DEFAULT NULL, `balance` int(255) DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-------- Records of tx_user------INSERT INTO `tx_user` VALUES (&apos;1&apos;, &apos;wukong&apos;, &apos;100&apos;);INSERT INTO `tx_user` VALUES (&apos;2&apos;, &apos;bajie&apos;, &apos;200&apos;);INSERT INTO `tx_user` VALUES (&apos;3&apos;, &apos;tangseng&apos;, &apos;100&apos;); 3.项目结构4.dao层接口 12345678910111213141516171819202122232425262728293031323334353637package com.hs.dao;public interface BookDao &#123; /** * 通过书的isbn查看这本书的价格 * @param isbn * @return */ int getBookPriceByIsbn(String isbn); /** * 减去用户里的钱 * @param account * @param price */ void updateUserBalance(String account, int price); /** * 减少书的数量 * @param isbn */ void updateBookStock(String isbn); /** * 查询用户的余额 * @param account * @return */ int getUserBalanceByAccount(String account); /** * 查询书的库存 * @param isbn * @return */ int getBookStockByIsbn(String isbn);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hs.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repository //&lt;bean id =bookDaoImpl &gt;public class BookDaoImpl implements BookDao &#123; private JdbcTemplate jdbcTemplate; @Autowired public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public int getBookPriceByIsbn(String isbn) &#123; String sql = "select price from tx_book where isbn=?"; int price = jdbcTemplate.queryForObject(sql, Integer.class, isbn); return price; &#125; @Override public void updateUserBalance(String account, int price) &#123; String sql = "update tx_user set balance = balance-? where account = ?"; jdbcTemplate.update(sql, price, account); &#125; @Override public void updateBookStock(String isbn) &#123; String sql = "update tx_book_stock set stock = stock-1 where isbn = ?"; jdbcTemplate.update(sql, isbn); &#125; @Override public int getUserBalanceByAccount(String account) &#123; String sql = "select balance from tx_user where account=?"; int balance = jdbcTemplate.queryForObject(sql, Integer.class, account); return balance; &#125; @Override public int getBookStockByIsbn(String isbn) &#123; String sql = "select stock from tx_book_stock where isbn=?"; int stock = jdbcTemplate.queryForObject(sql, Integer.class, isbn); return stock; &#125;&#125; 5.Service层接口 12345package com.hs.service;public interface OneBookService &#123; void buyOneBook(String account, String isbn);&#125; 123456789101112131415161718192021222324252627282930313233343536package com.hs.service;import com.hs.dao.BookDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Service //&lt;bean id = "oneBookServiceImpl" class="xxx"&gt;public class OneBookServiceImpl implements OneBookService &#123; //建立联系 @Autowired //直接在属性上注解setter方式，也可以在setter方法上注解 //指明具体的id @Qualifier("bookDaoImpl") //&lt;property name = "BookDao" ref="bookDaoImpl"&gt; private BookDao bookDao; @Override public void buyOneBook(String account, String isbn) &#123; //1.查询书的价格 int price = bookDao.getBookPriceByIsbn(isbn); //2.判断会员余额是否充足 int balance = bookDao.getUserBalanceByAccount(account); if (balance &lt; price) &#123; throw new RuntimeException("账号余额不足，请充值"); &#125; //3.会员中的余额 - 书价格 bookDao.updateUserBalance(account, price); //4.判断库存数量是否充足 int stock = bookDao.getBookStockByIsbn(isbn); if (stock == 0) &#123; throw new RuntimeException("书的库存数量不足"); &#125; //5.库存书的数量 - 1 bookDao.updateBookStock(isbn); &#125;&#125; 6.测试123456789101112131415161718192021222324package com.hs.test;import com.hs.service.OneBookService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class OneBookServiceTest &#123; private ApplicationContext ac; private OneBookService oneBookService; @Before public void init() &#123; ac = new ClassPathXmlApplicationContext("beans.xml"); oneBookService = ac.getBean("oneBookServiceImpl", OneBookService.class); &#125; @Test public void testBuyOneBookTest() &#123; oneBookService.buyOneBook("wukong", "1001"); &#125;&#125; 此时如果把数据库里1001的库存改为0，然后再执行测试，就会发现wukong的钱扣了，但是控制台报错，书的库存数量不足，这样就引入了事务的概念！！ 7.什么是事务？ 一个工作单元由多个动作组成，只有动作全部正确的时候才能执行成功，如果有一个动作错了，其他的动作都是无效的（回滚）(事务就是一系列的动作，它们被当做一 个单独的工作单元.这些动作要么全部完成，要么全部不起作用) 事务的四个关键属性(ACID) 原子性(atomicity):事务是一一个原子操作,由一系列动作组成，事务的原子性确保动作要么全部完成要么完全不起作用 一致性(consistency):一旦所有事务动作完成，事务就被提交，数据和资源就处于一种满足业务规则的一-致性状态中. 隔离性(isolation):可能有许多事务会同时处理相同的数据，因此每个事物都应该与其他事务隔离开来，防止数据损坏。 持久性(durability): 一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，通常情况下，事务的结果被写到持久化存储器中 8.事务管理事务管理就是管理事务，用来确保数据的完整性和一致性. 9.事务管理器就是对事务管理的实现，数据的完整性和一致性（数据库—&gt;数据源），MyBatis使用的是第一种 10.在XML配置事务，启动事务注解123456789101112&lt;!--5.配置事务管理器--&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt;&lt;/bean&gt;&lt;!--6.启动事务注解：告知该方法是事务方法(一个错，其他全部错)，而不是普通方法 transaction-manager="transactionManager"可以省略--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt;&lt;!--操作数据库了的xml版本,没注释的是注解版本--&gt;&lt;!--&lt;bean id="bookDaoImpl" class="com.hs.dao.BookDaoImpl"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt;&lt;/bean&gt;--&gt; 在方法前面加入注解@Transactional，或者类前面加这个注解，告之这个类的方法都是事务方法 12//点石成金，标识这个方法是事务方法@Transactional 再buyOneBook方法前面加入这个注解，再继续测试，就会发现，报书库存不足，但是wukong的钱没有扣。 11.@Transactional的属性12345//@Transactional //@Transactional(readOnly = true) //只读，一般只做查询操作使用 //@Transactional(noRollbackForClassName = "RuntimeException") //遇见这个异常，数据就不会回滚// @Transactional(propagation = Propagation.REQUIRES_NEW)// @Transactional(propagation = Propagation.REQUIRED) 12.事务的传播性在上面的条件下，新增加如果买多本书这个功能 事务的传播性：当你事务方法被另一个事务方法调用的时候，需要检查其事务的传播性 可能延续调用方法的事务 也可能开启新的事务 买多本书的接口： MoreBookService.java 1234567891011package com.hs.service;public interface MoreBookService &#123; /** * 买多本书 * String... 是可变长度参数列表，可以存多个 * @param account * @param isbns */ void buyMoreBook(String account, String... isbns);&#125; MoreBookServiceImpl.java 12345678910111213141516171819202122package com.hs.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class MoreBookServiceImpl implements MoreBookService &#123; @Autowired private OneBookService oneBookService; @Transactional //包含在这里面的都是事务方法,事务的传播性 @Override public void buyMoreBook(String account, String... isbns) &#123; if (isbns != null) &#123; for (String isbn : isbns) &#123; oneBookService.buyOneBook(account,isbn); &#125; &#125; &#125;&#125; buyMoreBook这个事务方法，调用了buyOneBook这个事务方法，然后检查buyOneBook这个事务方法的传播性，在这个方法上面写@Transactional，默认为延续调用方法的事务，下面的注解在被调用的事务方法上写 12//@Transactional(propagation = Propagation.REQUIRES_NEW) //本方法延续调用方法的事务// @Transactional(propagation = Propagation.REQUIRED) //本方法开启一个新的事务 测试 123456789101112131415161718192021222324package com.hs.test;import com.hs.service.MoreBookService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MoreBookServiceTest &#123; private ApplicationContext ac; private MoreBookService moreBookService; @Before public void init() &#123; ac = new ClassPathXmlApplicationContext("beans.xml"); moreBookService = ac.getBean("moreBookServiceImpl", MoreBookService.class); &#125; @Test public void testBuyMoreBookMethod() &#123; moreBookService.buyMoreBook("wukong","1003","1001"); &#125;&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十三）JdbcTemplate工具类的使用]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89JdbcTemplate%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JdbcTemplate就是Spring框架给我们封装好的简单对数据库操作的工具类，返回Map数据，返回List_Map数据，返回一个值，返回一个对象，返回一个List&lt;对象&gt;，添加修改删除 源码获取github [TOC] 1.介绍JdbcTemplate工具类Spring是一个IoC和AOP的容器框架，并且它是一站式开源框架ORM是我们学过的MyBatis，JdbcTemplate就是Spring框架给我们封装好的简单对数据库操作的工具类，需要这个spring-jdbc.jar 2.sql文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116SET FOREIGN_KEY_CHECKS=0;-------- Table structure for oa_user------DROP TABLE IF EXISTS `oa_user`;CREATE TABLE `oa_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `sex` varchar(255) DEFAULT NULL, `money` decimal(7,2) DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4;-------- Records of oa_user------INSERT INTO `oa_user` VALUES (&apos;1&apos;, &apos;悟空&apos;, &apos;男&apos;, &apos;888.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;2&apos;, &apos;八戒&apos;, &apos;男&apos;, &apos;999.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;3&apos;, &apos;天蓬元帅&apos;, &apos;女&apos;, &apos;1000.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;4&apos;, &apos;悟能&apos;, &apos;男&apos;, &apos;666.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;5&apos;, &apos;法悟法&apos;, &apos;女&apos;, &apos;544.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;6&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;7&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;14&apos;, &apos;嫦娥&apos;, &apos;女&apos;, &apos;1213.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;15&apos;, &apos;月兔&apos;, &apos;女&apos;, &apos;2113.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;16&apos;, &apos;和尚&apos;, &apos;男&apos;, &apos;455.00&apos;, &apos;2018-08-05&apos;);INSERT INTO `oa_user` VALUES (&apos;18&apos;, &apos;沙僧&apos;, &apos;男&apos;, &apos;455.00&apos;, &apos;2018-08-05&apos;);INSERT INTO `oa_user` VALUES (&apos;19&apos;, &apos;唐僧&apos;, &apos;男&apos;, &apos;220.00&apos;, &apos;2018-08-09&apos;);INSERT INTO `oa_user` VALUES (&apos;20&apos;, &apos;唐僧&apos;, &apos;男&apos;, &apos;220.00&apos;, &apos;2018-08-09&apos;);-------- Table structure for skill------DROP TABLE IF EXISTS `skill`;CREATE TABLE `skill` ( `skill_id` int(11) NOT NULL AUTO_INCREMENT, `skill_name` varchar(255) DEFAULT NULL, `num` int(11) DEFAULT NULL, `fk_teacher_id` int(11) DEFAULT NULL, PRIMARY KEY (`skill_id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;-------- Records of skill------INSERT INTO `skill` VALUES (&apos;2&apos;, &apos;JS&apos;, &apos;75&apos;, null);INSERT INTO `skill` VALUES (&apos;7&apos;, &apos;CSS&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;8&apos;, &apos;java&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;9&apos;, &apos;vue&apos;, &apos;56&apos;, &apos;9999&apos;);-------- Table structure for sys_role------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `role_id` int(11) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) DEFAULT NULL, `role_key` varchar(32) DEFAULT NULL, `status` int(1) DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1禁用&apos;, PRIMARY KEY (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-------- Records of sys_role------INSERT INTO `sys_role` VALUES (&apos;-100&apos;, &apos;超级管理员&apos;, &apos;ADMIN&apos;, &apos;1&apos;);-------- Table structure for sys_user------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(32) NOT NULL, `password` varchar(128) NOT NULL, `user_name` varchar(32) DEFAULT &apos;&apos;, `status` int(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1删除 2禁用&apos;, `login_time` datetime DEFAULT CURRENT_TIMESTAMP, `ip` varchar(128) DEFAULT NULL, `fk_role_id` int(11) DEFAULT NULL, PRIMARY KEY (`user_id`), KEY `fk_role_id` (`fk_role_id`), CONSTRAINT `sys_user_ibfk_1` FOREIGN KEY (`fk_role_id`) REFERENCES `sys_role` (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-------- Records of sys_user------INSERT INTO `sys_user` VALUES (&apos;-999&apos;, &apos;super&apos;, &apos;super&apos;, &apos;唐僧&apos;, &apos;1&apos;, &apos;2018-07-28 18:47:39&apos;, null, &apos;-100&apos;);INSERT INTO `sys_user` VALUES (&apos;-888&apos;, &apos;admin&apos;, &apos;admin&apos;, &apos;悟空&apos;, &apos;1&apos;, &apos;2018-07-03 18:48:21&apos;, null, &apos;-100&apos;); 3.实例化该工具类1234&lt;bean class="org.springframework.jdbc.core.JdbcTemplate" &gt; &lt;property name="dataSource" 赋值/&gt; ------&lt;/bean&gt; 4.配置数据源数据源就是连接数据，而以后工作当中我们推荐使用“连接池”， 什么是连接池？我的理解为预先建立好一堆Connection，使用时候从池中获取，不适应不是销毁而是把连接再次放回到池中 连接池的工作原理？Java代码如何实现–&gt;Map/List 存Connection 开源的连接池有哪些？C3p0、dbcp、德鲁伊druid(阿里巴巴的) 12345678910111213141516&lt;!-- destroy-method="close"销毁的方法--&gt;&lt;!--4.配置数据源--&gt;&lt;bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/cy42_mss"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt;&lt;!--5.配置工具类JdbcTemplate--&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!--setter注入方式--&gt; &lt;property name="dataSource" ref="druidDataSource"/&gt; &lt;!--构造函数赋值--&gt; &lt;!--&lt;constructor-arg name="dataSource" ref="druidDataSource"/&gt;--&gt;&lt;/bean&gt; 5.User.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.hs.model;import java.math.BigDecimal;import java.util.Date;public class User &#123; private Integer user_id; private String user_name; private String sex; //钱用BigDecimal private BigDecimal money; private Date birthday; public BigDecimal getMoney() &#123; return money; &#125; public void setMoney(BigDecimal money) &#123; this.money = money; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", user_name='" + user_name + '\'' + ", sex='" + sex + '\'' + ", money=" + money + ", birthday=" + birthday + '&#125;'; &#125;&#125; 6.查询操作(预处理)1.返回Map数据12345678910111213141516171819202122232425262728293031323334353637383940package com.hs.test;import com.hs.model.User;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;import java.util.Date;import java.util.List;import java.util.Map;public class JdbcTemplateTest &#123; private ApplicationContext ac; private JdbcTemplate jdbcTemplate; @Before public void init() &#123; ac = new ClassPathXmlApplicationContext("beans.xml"); jdbcTemplate = ac.getBean("jdbcTemplate", JdbcTemplate.class); &#125; /** * 返回Map数据 */ @Test public void test01() &#123; /*String sql = "select * from oa_user where user_id = 3"; Map&lt;String, Object&gt; map = this.jdbcTemplate.queryForMap(sql);*/ String sql = "select * from oa_user where user_id = ?"; Map&lt;String, Object&gt; map = jdbcTemplate.queryForMap(sql, 2); System.out.println(map); &#125;&#125; 2.返回List_Map数据12345678/** * 返回List_Map数据 */@Testpublic void test02() &#123; String sql = "select * from oa_user"; System.out.println(jdbcTemplate.queryForList(sql));&#125; 3.返回一个值123456789/** * 返回一个值 */@Testpublic void test03() &#123; String sql = "select count(*) from oa_user"; System.out.println(jdbcTemplate.queryForObject(sql, Integer.class));&#125; 4.返回一个对象1234567891011121314151617181920212223/** * 返回一个对象 */@Testpublic void test04() &#123; String sql = "select * from oa_user where user_id = ?"; User user = jdbcTemplate.queryForObject(sql, /*匿名内部类*/new RowMapper&lt;User&gt;() &#123; @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; User user = new User(); user.setUser_id(rs.getInt("user_id")); user.setUser_name(rs.getString("User_name")); user.setSex(rs.getString("sex")); user.setMoney(rs.getBigDecimal("money")); user.setBirthday((Date) rs.getObject("birthday")); return user; &#125; &#125;, 2); System.out.println(user);&#125; 5.返回一个List&lt;对象&gt;123456789/** * 返回一个List&lt;对象&gt; */@Testpublic void test05() &#123; String sql = "select * from oa_user where user_name like concat('%',?,'%')"; List&lt;User&gt; userList = jdbcTemplate.query(sql,/*处理一条一条的数据*/new UserRowMapper(), "沙僧"); System.out.println(userList);&#125; 把匿名内部类提出来 12345678910111213141516171819/** * 对于外面那个类来说，这是一个内部类，外面那个类对于这个类来说，是外部类 * 百度什么是内部类和特种？ * private使这个类只能被这个类使用 */private class UserRowMapper implements RowMapper&lt;User&gt; &#123; @Override public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123; System.out.println("---------"); User user = new User(); user.setUser_id(rs.getInt("user_id")); user.setUser_name(rs.getString("User_name")); user.setSex(rs.getString("sex")); user.setMoney(rs.getBigDecimal("money")); user.setBirthday((Date) rs.getObject("birthday")); return user; &#125;&#125; 6.返回一个List&lt;对象&gt;——自动映射，类属性和查询的字段名字一样123456789/** * 返回一个List&lt;对象&gt;——自动映射，类属性和查询的字段名字一样 */@Testpublic void test06() &#123; String sql = "select * from oa_user where user_name like concat('%',?,'%')"; List&lt;User&gt; userList = jdbcTemplate.query(sql,/*处理一条一条的数据，，，&lt;User&gt;可以不用写*/new BeanPropertyRowMapper&lt;User&gt;(User.class), "沙僧"); System.out.println(userList);&#125; 7.添加修改删除1234567891011121314/** * 添加修改删除 */@Testpublic void test07() &#123; String sql1 = "insert into oa_user(user_name,sex,money,birthday) values(?,?,?,?)"; String sql2 = "update oa_user set user_name=?,sex=? where user_id = ?"; String sql3 = "delete from oa_user where user_id = ?"; int num1 = jdbcTemplate.update(sql1, "唐僧", "男", 220.00, "2018-8-9"); int num2 = jdbcTemplate.update(sql2, "和尚", "男", 16); int num3 = jdbcTemplate.update(sql3, 17); System.out.println(num1+"--"+num2+"---"+num3);&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十二）AOP的XML方式cglib代理-重点掌握]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89AOP%E7%9A%84XML%E6%96%B9%E5%BC%8Fcglib%E4%BB%A3%E7%90%86-%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%2F</url>
    <content type="text"><![CDATA[切点，切面，如何定义切点，前置、后置、放回、异常、环绕通知的XML版 源码获取github [TOC] 1.项目结构（jar包跟上个一样） 2.核心业务代码1234567891011121314package com.hs.service;/** * 对外提供的核心业务，完成了加法/减法/乘法运算 */public interface ArithmeticService &#123; int add(int x, int y); int sub(int x, int y); int mul(int x, int y); int div(int x, int y);&#125; 1234567891011121314151617181920212223242526272829303132333435package com.hs.service.impl;import com.hs.service.ArithmeticService;import org.springframework.stereotype.Service;/** * 核心代码 */@Servicepublic class ArithmeticServiceImpl implements ArithmeticService &#123; @Override public int add(int x, int y) &#123; //核心代码 int result = x + y; return result; &#125; @Override public int sub(int x, int y) &#123; int result = x - y; return result; &#125; @Override public int mul(int x, int y) &#123; int result = x * y; return result; &#125; @Override public int div(int x, int y) &#123; int result = x / y; return result; &#125;&#125; 3.切面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.hs.service.aspect;import org.aspectj.lang.JoinPoint;import java.util.Arrays;//@Component//@Aspect //标记这是切面public class Logger &#123; public void test01() &#123; System.out.println("测试出order属性的作用"); &#125; //1.前置通知 public void test05(JoinPoint jp) &#123; //获取get System.out.println("==前置通知=="); System.out.println(Arrays.asList(jp.getArgs())); System.out.println(jp.getSignature().getName()); System.out.println(jp.getTarget().getClass().getName()); System.out.println("==前置通知=="); &#125; //2.后置通知 public void test06(JoinPoint jp) &#123; System.out.println("==后置增强=="); System.out.println(Arrays.asList(jp.getArgs())); System.out.println(jp.getSignature().getName()); System.out.println(jp.getTarget().getClass().getName()); System.out.println("==后置增强=="); &#125; //3.返回通知 public void test07(JoinPoint jp, int hs) &#123; System.out.println("==返回通知=="); System.out.println("程序正常运行，正确的运行结果为==&gt;" + hs); System.out.println("==返回通知=="); &#125; //4.异常通知 public void test08(JoinPoint jp, ArithmeticException hs) &#123; System.out.println("==异常通知=="); System.out.println("程序运行错误==&gt;" + hs); System.out.println("==异常通知=="); &#125;&#125; 4.XML里切点，切面1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:util="http://www.springframework.org/schema/util" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt; &lt;!--1.启动Spring注解--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--2.扫描--&gt; &lt;context:component-scan base-package="com.hs"/&gt; &lt;!--Spring提供了多种AOP的实现方式，但是我们只用第三方的AOP标准--&gt; &lt;!--3.启动AOP注解：false是使用默认的java代理，true是使用CGLIB代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!--4.AOP的XML配置方式,false是使用默认的java代理，true是使用CGLIB代理--&gt; &lt;!--实例化那个类，在切面引用的时候好用--&gt; &lt;bean id="logger" class="com.hs.service.aspect.Logger"/&gt; &lt;bean id="logger111" class="com.hs.service.aspect.Logger"/&gt; &lt;aop:config proxy-target-class="true"&gt; &lt;!--定义切点，可以把切点放在外面作为公共的，注意pointcut aspect的顺序，对应注解版的@PointCut(value = "execution(* com.hs..service.*Service.*(..))")--&gt; &lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt; &lt;!--定义切面，对应注解版的@Aspect,order,定义切面的执行顺序，不写默认为从上到下执行--&gt; &lt;aop:aspect ref="logger111" order="2"&gt; &lt;!--定义切点，对应注解版的@PointCut(value = "execution(* com.hs..service.*Service.*(..))")--&gt; &lt;!--&lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt;--&gt; &lt;aop:before method="test01" pointcut-ref="servicePointCut"/&gt; &lt;/aop:aspect&gt; &lt;!--定义切面，对应注解版的@Aspect--&gt; &lt;aop:aspect ref="logger" order="1"&gt; &lt;!--定义切点，对应注解版的@PointCut(value = "execution(* com.hs..service.*Service.*(..))")--&gt; &lt;!--&lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt;--&gt; &lt;aop:before method="test05" pointcut-ref="servicePointCut"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 首先得实例化 1&lt;bean id="logger" class="com.hs.service.aspect.Logger"/&gt; 切点： 1&lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt; 切面： 12345&lt;aop:aspect ref="logger111" order="2"&gt; &lt;!--定义切点，对应注解版的@PointCut(value = "execution(* com.hs..service.*Service.*(..))")--&gt; &lt;!--&lt;aop:pointcut id="servicePointCut" expression="execution(* com.hs..service.*Service.*(..))"/&gt;--&gt; &lt;aop:before method="test01" pointcut-ref="servicePointCut"/&gt;&lt;/aop:aspect&gt; 测试： 123456789101112131415161718192021222324package com.hs.test;import com.hs.service.ArithmeticService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ArithmeticServiceTest &#123; private ArithmeticService arithmeticService; private ApplicationContext ac; @Before public void init() &#123; this.ac = new ClassPathXmlApplicationContext("beans.xml"); this.arithmeticService = this.ac.getBean("arithmeticServiceImpl", ArithmeticService.class); &#125; @Test public void testAddMethod() &#123; int result = this.arithmeticService.div(2,1); System.out.println("运行的结果："+ result); &#125;&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十一）AOP的注解方式cglib代理]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89AOP%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8Fcglib%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JDK动态代理与CGLib动态代理均是实现Spring AOP的基础，切点，切面，如何定义切点，前置、后置、放回、异常、环绕通知 源码获取github [TOC] 1.切点、切面 红色的地方就是切面，增加额外的功能 连接点+增加功能的位置 = 切点 2.项目结构 3.jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--新增的jar--&gt; &lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjrt --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.核心配置文件beans.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:util="http://www.springframework.org/schema/util" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt; &lt;!--1.启动Spring注解--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--2.扫描--&gt; &lt;context:component-scan base-package="com.hs"/&gt; &lt;!--Spring提供了多种AOP的实现方式，但是我们只用第三方的AOP标准方式--&gt; &lt;!--3.启动AOP注解，false是使用默认的java代理，true是使用CGLIB代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;&lt;/beans&gt; 5.核心代码1234567891011121314package com.hs.service;/** * 对外提供的核心业务，完成了加法/减法/乘法运算 */public interface ArithmeticService &#123; int add(int x, int y); int sub(int x, int y); int mul(int x, int y); int div(int x, int y);&#125; 1234567891011121314151617181920212223242526272829303132333435package com.hs.service.impl;import com.hs.service.ArithmeticService;import org.springframework.stereotype.Service;/** * 核心代码 */@Servicepublic class ArithmeticServiceImpl implements ArithmeticService &#123; @Override public int add(int x, int y) &#123; //核心代码 int result = x + y; return result; &#125; @Override public int sub(int x, int y) &#123; int result = x - y; return result; &#125; @Override public int mul(int x, int y) &#123; int result = x * y; return result; &#125; @Override public int div(int x, int y) &#123; int result = x / y; return result; &#125;&#125; 6.定义切面12345678910111213141516171819202122package com.hs.service.aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect //标记这是切面public class Logger &#123; //在你运行方法之前执行，并且监控的是接口的执行Add方法，value可以省略 @Before(value = "execution(int com.hs.service.ArithmeticService.add(int ,int))") //这句话的意思， //执行返回类型为int，com.hs.service.ArithmeticService接口下的add方法，传递的两个参数类型为int，int //简单理解为，接口里写的方法，只是少了变量值 int add(int x, int y); public void test01() &#123; System.out.println("@Before在程序之前运行"); &#125;&#125; 测试 123456789101112131415161718192021222324package com.hs.test;import com.hs.service.ArithmeticService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ArithmeticServiceTest &#123; private ArithmeticService arithmeticService; private ApplicationContext ac; @Before public void init() &#123; this.ac = new ClassPathXmlApplicationContext("beans.xml"); this.arithmeticService = this.ac.getBean("arithmeticServiceImpl", ArithmeticService.class); &#125; @Test public void testAddMethod() &#123; int result = this.arithmeticService.add(2,1); System.out.println("运行的结果："+ result); &#125;&#125; 控制台输出： @Before在程序之前运行运行的结果：3 7.如何定义注解切点说明1.使用逻辑运算符1234@Before(value = "execution(int com.hs.service.ArithmeticService.add(int ,int)) or execution(int com.hs.service.ArithmeticService.sub(int ,int))")public void test02() &#123; System.out.println("我可以使用逻辑运算符 &amp;&amp;(and) ||(or)");&#125; 2.使用通配符——推荐12345678910111213/** * 比较推荐 * 在execution表达式中可以使用通配符，但是请注意任意的表达式是 .. * 第一个*位置：代表返回任意的数据类型 * ..表示任意的意思，而不是我们之前学习的** * 第二个* 监控的以Service结尾的类(接口) * 第三个* 监控接口或者类下的所有的方法 * ..标识任意个参数类型或者参数的个数 */@Before(value = "execution(* com.hs..*Service.*(..))")public void test03() &#123; System.out.println("我可以使用通配符");&#125; 3.如何定义切点1234567891011121314151617//如何定义切点(可以随意组合)@Pointcut(value = "execution(int com.hs.service.ArithmeticService.add(int ,int))")public void addPointCut() &#123; &#125; //切点的名称是“addPointCut()”@Pointcut(value = "execution(int com.hs.service.ArithmeticService.sub(int ,int))")public void subPointCut() &#123; &#125; //切点的名称是“subPointCut()”@Pointcut(value = "execution(int com.hs.service.ArithmeticService.mul(int ,int))")public void mulPointCut() &#123; &#125; //切点的名称是“mulPointCut()”@Pointcut(value = "addPointCut() || mulPointCut()")public void addAndMulPointCut() &#123; &#125; //切点的名称是“addAndMulPointCut()”@Pointcut(value = "execution(* com.hs..service.*Service.*(..))") public void allMethodPointCut()&#123;&#125;//@Before 叫前置通知，也叫前置增强@Before(value = "addAndMulPointCut()")public void test04() &#123; System.out.println("如何定义切点");&#125; 8.前置通知：不管程序是否正确都会执行1234567891011//1.前置通知(增强)特点：不管程序是否正确都会执行 @Before(value = "allMethodPointCut()") public void test05(JoinPoint jp) &#123; System.out.println("==前置通知=="); //获取get System.out.println(Arrays.asList(jp.getArgs())); System.out.println(jp.getSignature().getName()); System.out.println(jp.getTarget().getClass().getName()); System.out.println("==前置通知=="); &#125; 9.后置通知：不管程序是否正确都会执行1234567891011//2.后置通知(增强)特点：不管程序是否正确都会执行@After(value = "allMethodPointCut()")public void test06(JoinPoint jp) &#123; //获取get System.out.println("==后置增强=="); System.out.println(Arrays.asList(jp.getArgs())); System.out.println(jp.getSignature().getName()); System.out.println(jp.getTarget().getClass().getName()); System.out.println("==后置增强==");&#125; 10.返回通知:只有程序是正确的时候才会执行，并且可以获取运行后的数据1234567//3.返回通知(增强):只有程序是正确的时候才会执行，并且可以获取运行后的数据@AfterReturning(value = "allMethodPointCut()",returning = "hs")public void test07(JoinPoint jp,int hs) &#123; System.out.println("==返回通知=="); System.out.println("程序正常运行，正确的运行结果为==&gt;"+hs); System.out.println("==返回通知==");&#125; 11.异常通知：只有程序是错误的时候才会执行1234567//4.异常通知(增强)：只有程序是错误的时候才会执行，@AfterThrowing(value = "allMethodPointCut()",throwing = "hs")public void test08(JoinPoint jp,ArithmeticException hs) &#123; System.out.println("==异常通知=="); System.out.println("程序运行错误==&gt;"+hs); System.out.println("==异常通知==");&#125; 12.环绕通知123456789101112131415//5.环绕通知@Around("allMethodPointCut()")public Object test09(ProceedingJoinPoint pjp) &#123; System.out.println("写某个功能，前置通知"); Object result = null; try &#123; result = pjp.proceed(); //执行程序返回运行的结果 System.out.println("写某个功能，返回通知"); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println("写某个功能，异常通知"); &#125; System.out.println("写某个功能，后置通知"); return result;&#125; 测试 123456789101112131415161718192021222324package com.hs.test;import com.hs.service.ArithmeticService;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ArithmeticServiceTest &#123; private ArithmeticService arithmeticService; private ApplicationContext ac; @Before public void init() &#123; this.ac = new ClassPathXmlApplicationContext("beans.xml"); this.arithmeticService = this.ac.getBean("arithmeticServiceImpl", ArithmeticService.class); &#125; @Test public void testAddMethod() &#123; int result = this.arithmeticService.add(2,1); System.out.println("运行的结果："+ result); &#125;&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（十）AOP静态代理和动态代理说明]]></title>
    <url>%2F2018%2F09%2F03%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89AOP%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[实例分析，AOP的静态代理和动态代理 源码获取github [TOC] 1.什么是AOP？Aspect Oriented Programming with Spring 面向切面（方面）编程 面向切面编程是面向对象编程的一个补充而已 白话：我的理解—-&gt;在不改变原来的代码的基础上增强（增加）新的功能 2.代码结构 3.情景描述引发静态代理如果现在让你完成一个2个数的四则运算 核心业务完成 1234567891011121314package com.hs.service;/** * 对外提供的核心业务，完成了加法/减法/乘法/除法运算 */public interface ArithmeticService &#123; int add(int x, int y); int sub(int x, int y); int mul(int x, int y); int div(int x, int y);&#125; 12345678910111213141516171819202122232425262728293031package com.hs.service;/** * 核心代码 */public class ArithmeticServiceImpl implements ArithmeticService &#123; @Override public int add(int x, int y) &#123; //核心代码 int result = x + y; return result; &#125; @Override public int sub(int x, int y) &#123; int result = x - y; return result; &#125; @Override public int mul(int x, int y) &#123; int result = x * y; return result; &#125; @Override public int div(int x, int y) &#123; int result = x / y; return result; &#125;&#125; 完成了，和尚—&gt;技术经理—&gt;定义接口，悟空程序员—&gt;接口实现类 交工客户龙王，龙王需要显示传递数据的信息功能—&gt;和尚—&gt;悟空完成客户需求，但是万一如果又不要这个功能呢，现在引出静态代理，在核心代码的基础上增加新的功能 123456789101112131415161718192021222324252627282930313233343536package com.hs.service;/** * 新增加的功能,采用静态代理 */public class ArithmeticServiceLogImpl implements ArithmeticService &#123; //声明一个核心代码类的变量，为了后面方便调用核心代码的功能 private ArithmeticServiceImpl asc = new ArithmeticServiceImpl(); @Override public int add(int x, int y) &#123; //后增加的某个功能 System.out.println("加法传递的参数===&gt;x="+x+",y="+y);// 然后调用核心代码的功能 return asc.add(2, 3); &#125; @Override public int sub(int x, int y) &#123; System.out.println("减法传递的参数===&gt;x="+x+",y="+y); return asc.sub(2, 3); &#125; @Override public int mul(int x, int y) &#123; System.out.println("乘法传递的参数===&gt;x="+x+",y="+y); return asc.mul(2, 3); &#125; @Override public int div(int x, int y) &#123; System.out.println("除法传递的参数===&gt;x="+x+",y="+y); return asc.mul(2, 3); &#125;&#125; 测试： 12345678910111213141516171819202122232425package com.hs.test;import com.hs.proxy.ArithmeticServiceProxy;import com.hs.service.ArithmeticService;import com.hs.service.ArithmeticServiceImpl;import org.junit.Before;import org.junit.Test;import java.lang.reflect.Proxy;public class ArithmeticServiceTest &#123; private ArithmeticService arithmeticService; @Before //在每个单元测试运行之前都要进行这个方法 public void init() &#123; this.arithmeticService = new ArithmeticServiceLogImpl();//new ArithmeticServiceImpl(); //想用哪个功能就实例化哪个类 &#125; @Test public void testAddMethod() &#123; int result = this.arithmeticService.add(2, 3); System.out.println(result); &#125;&#125; 4.动态代理接口和核心代码不变， 代理类： 123456789101112131415161718192021222324252627282930313233343536373839package com.hs.proxy;import com.hs.service.ArithmeticService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;/** * 代理类 */public class ArithmeticServiceProxy implements InvocationHandler &#123; //定义一个接口变量 private ArithmeticService arithmeticService; public ArithmeticServiceProxy(ArithmeticService arithmeticService) &#123; this.arithmeticService = arithmeticService; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //写了某个功能，不管程序有没有错误都执行 System.out.println("在运行方法[" + method.getName() + "]之前执行，传递的参数为" + Arrays.asList(args)); Object result = null; try &#123; result = method.invoke(this.arithmeticService, args); //写了某个功能，只有程序没有错误才执行 System.out.println("运行方法成功，结果为："+result); &#125; catch (Exception e) &#123; e.printStackTrace(); //写了某个功能，程序有错误的时候才执行 System.out.println("执行的方法错误"); &#125; //写了某个功能，不管程序有没有错误都执行 System.out.println("在运行方法之后执行"); return result; &#125;&#125; 测试 1234567891011121314151617181920212223242526272829303132package com.hs.test;import com.hs.proxy.ArithmeticServiceProxy;import com.hs.service.ArithmeticService;import com.hs.service.ArithmeticServiceImpl;import org.junit.Before;import org.junit.Test;import java.lang.reflect.Proxy;public class ArithmeticServiceTest &#123; private ArithmeticService arithmeticService; @Before //再每个单元测试运行之前都要进行这个方法 public void init() &#123; this.arithmeticService = new ArithmeticServiceImpl(); //想用哪个功能就实例化哪个 &#125; /** * 动态代理 */ @Test public void test01() &#123; //实例化代理类 ArithmeticServiceProxy asp = new ArithmeticServiceProxy(this.arithmeticService);// 固定写法 ArithmeticService as = (ArithmeticService) Proxy.newProxyInstance(ArithmeticServiceImpl.class.getClassLoader(), ArithmeticServiceImpl.class.getInterfaces(), asp); int result = as.div(10, 1); System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（九）模拟实际开发过程的调用过程注解版-官方推荐版]]></title>
    <url>%2F2018%2F09%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%B3%A8%E8%A7%A3%E7%89%88-%E5%AE%98%E6%96%B9%E6%8E%A8%E8%8D%90%E7%89%88%2F</url>
    <content type="text"><![CDATA[用@Repository、@Service 和 @Constroller，代替@Component，知名见意，知道是哪一层，@Autowired代替@Resource。 源码获取github [TOC] 1.@Repository、@Service 和 @Constroller代替@Component @Repository：持久化层、数据访问层、也就是dao层，写在这上面，功能跟@Component，只是为了知名见意 @Service：写在Service层，业务逻辑层 @Controller：写在控制层，也就是SpringMvc那层 2.@Autowired代替@Resource @Autowired是Spring自己的，@Resource不是Spring的 面试题：@Resource和@Autowired的区别： @Resource先按名称再按照类型查找 @Autowired先按类型再按照名称查找 @Qualifier(“bookDaoImpl”)//指明ID的名字 3.项目结构(jar包一样) 4.核心配置文件beans.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:util="http://www.springframework.org/schema/util" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt; &lt;!--1.启动Spring注解--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--2.扫描--&gt; &lt;context:component-scan base-package="com.hs"/&gt;&lt;/beans&gt; 5.dao层UserDao.java 12345package com.hs.dao;public interface UserDao &#123; void add();&#125; UserDaoImpl.java 1234567891011121314package com.hs.dao.impl;import com.hs.dao.UserDao;import org.springframework.stereotype.Repository;//@Component//(value = "userDao") //相当于&lt;bean id="userDaoImpl" class="com.hs.dao.impl.UserDaoImpl"/&gt;@Repository //跟上面意思一样，只是为了知名见意public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("UserDao层的实现类---&gt;ADD"); &#125;&#125; 6.Service层UserService.java 123456package com.hs.service;public interface UserService &#123; void add();&#125; UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334package com.hs.service.impl;import com.hs.dao.UserDao;import com.hs.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;//@Component //相当于&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt;@Service //跟上面意思一样，只是为了知名见意public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; //面试题：Resource和Autowired的区别 //@Resource先按名称再按照类型查找 //@Autowired先按类型再按照名称查找 @Autowired //指明id名字 @Qualifier(value = "userDaoImpl") public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void add() &#123; System.out.println("UserService层的实现类---&gt;ADD"); this.userDao.add(); &#125;&#125; 7.Controller层UserController.java 1234567891011121314151617181920212223package com.hs.web;import com.hs.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;//@Component //相当于&lt;bean id="userController" class="com.hs.web.UserController"/&gt;@Controller //跟上面意思一样，只是为了知名见意public class UserController &#123; @Autowired private UserService userService; public UserService getUserService() &#123; return userService; &#125; public void add() &#123; System.out.println("UserController层---&gt;ADD"); this.userService.add(); &#125;&#125; 8.测试123456789101112131415package com.hs.test;import com.hs.web.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MethodTest &#123; @Test public void test01() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml"); UserController controller = applicationContext.getBean("userController", UserController.class); controller.add(); &#125;&#125; 控制台输出： UserController层—&gt;ADDUserService层的实现类—&gt;ADDUserDao层的实现类—&gt;ADD]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（八）模拟实际开发过程的调用过程注解版-传统方式]]></title>
    <url>%2F2018%2F09%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%B3%A8%E8%A7%A3%E7%89%88-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[传统的@Component和@Resource(等价于XML版setter注入)使用说明 @Component是个泛化概念，可以用在任何层次 源码获取github [TOC] 1.项目结构(jar同上) 2.核心配置文件beans.xml12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:util="http://www.springframework.org/schema/util" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd"&gt; &lt;!--1.启动Spring注解--&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt; &lt;!--2.扫描--&gt; &lt;context:component-scan base-package="com.hs"/&gt;&lt;/beans&gt; 3.dao层userDao.java 12345package com.hs.dao;public interface UserDao &#123; void add();&#125; UserDaoImpl.java 12345678910111213package com.hs.dao.impl;import com.hs.dao.UserDao;import org.springframework.stereotype.Component;@Component//(value = "userDao") //相当于&lt;bean id="userDaoImpl" class="com.hs.dao.impl.UserDaoImpl"/&gt;public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("UserDao层的实现类---&gt;ADD"); &#125;&#125; 4.Service层UserService.java 1234567package com.hs.service;public interface UserService &#123; void add();&#125; UserServiceImpl.java 123456789101112131415161718192021222324252627282930313233package com.hs.service.impl;import com.hs.dao.UserDao;import com.hs.service.UserService;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component //相当于&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserDao getUserDao() &#123; return userDao; &#125; /*相当于&lt;property name="userDao"&gt; &lt;ref bean="userDaoImpl"/&gt; &lt;/property&gt;*/ @Resource(name = "userDaoImpl") //下面的查找顺序 先按照名字进行搜索(没有写名字默认就是set后面那个名字) 再按照类型进行搜索(UserDao的实现类) //@Resource public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void add() &#123; System.out.println("UserService层的实现类---&gt;ADD"); this.userDao.add(); &#125;&#125; 知识点：@Resource注解 先按名称搜索，再按照类型搜索 是javax下的，不是Spring自带的 后面会有Spring自带的注解@Autowired推荐 5.Controller层UserController.java 12345678910111213141516171819202122232425262728package com.hs.web;import com.hs.service.UserService;import org.springframework.stereotype.Component;import javax.annotation.Resource;@Component //相当于&lt;bean id="userController" class="com.hs.web.UserController"/&gt;public class UserController &#123; //简写方式，写个就不用写set方法了 //如果你所在的公司用了测试框架(不是我现在用的单元测试框架)，那么不建议使用简写方式，对测试有影响 //@Resource(name = "userServiceImpl") private UserService userService; public UserService getUserService() &#123; return userService; &#125; @Resource(name = "userServiceImpl") //相当于p:userService-ref="userServiceImpl" public void setUserService(UserService userService) &#123; this.userService = userService; &#125; public void add() &#123; System.out.println("UserController层---&gt;ADD"); this.userService.add(); &#125;&#125; 6.测试123456789101112131415package com.hs.test;import com.hs.web.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MethodTest &#123; @Test public void test01() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml"); UserController controller = applicationContext.getBean("userController", UserController.class); controller.add(); &#125;&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（七）模拟实际开发过程的调用过程XML版-Setter方式注入]]></title>
    <url>%2F2018%2F09%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8BXML%E7%89%88-Setter%E6%96%B9%E5%BC%8F%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[模拟实际开发过程的调用过程XML版-Setter方式注入 源码获取github [TOC] 1.项目结构 2.jar包跟上个一样3.重写set方法UserServiceImpl.java 12345private UserDao userDao;public void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; beans.xml 1234567&lt;bean id="userDaoImpl" class="com.hs.dao.impl.UserDaoImpl"/&gt;&lt;!--相当于userDao = new userDaoImpl()--&gt;&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt; &lt;property name="userDao"&gt; &lt;ref bean="userDaoImpl"/&gt; &lt;/property&gt;&lt;/bean&gt; 在set方法里代替完成了，private UserDao userDao = new userDaoImpl(); UserController.java 12345private UserService userService;public void setUserService(UserService userService) &#123; this.userService = userService;&#125; beans.xml 1234567891011&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt; &lt;property name="userDao"&gt; &lt;ref bean="userDaoImpl"/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--先UserController = new UserController() 再userService = new userServiceImpl();--&gt;&lt;bean id="userController" class="com.hs.web.UserController" p:userService-ref="userServiceImpl"&gt; &lt;!--&lt;property name="userService" ref="userServiceImpl"/&gt;--&gt;&lt;/bean&gt; 在set方法里代替完成了private UserService userService = new userServiceImpl(); 4.测试123456789101112131415package com.hs.test;import com.hs.web.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MethodTest &#123; @Test public void test01() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml"); UserController controller = applicationContext.getBean("userController", UserController.class); controller.add(); &#125;&#125; 控制台输出： UserController层—&gt;ADDUserService层的实现类—&gt;ADDUserDao层的实现类—&gt;ADD]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（六）模拟实际开发过程的调用过程XML版_构造函数注入]]></title>
    <url>%2F2018%2F09%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8BXML%E7%89%88-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[用Spring的XML版的构造函数注入完成这个过程 源码获取github [TOC] 1.项目结构 2.jar包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.代替private UserDao userDao = new userDaoImpl();UserServiceImpl.java 12345678910111213141516171819202122package com.hs.service.impl;import com.hs.dao.UserDao;import com.hs.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public UserServiceImpl() &#123; &#125; public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void add() &#123; System.out.println("UserService层的实现类---&gt;ADD"); userDao.add(); &#125;&#125; beans.xml 1234567&lt;!--实例化--&gt;&lt;bean id="userDaoImpl" class="com.hs.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;!--通过构造函数实例化--&gt;&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="userDao" ref="userDaoImpl"/&gt;&lt;/bean&gt; 这两段代码相当于，完成了private UserDao userDao = new userDaoImpl(); 4.代替private UserService userService = new userServiceImpl();UserController.java 1234567891011121314151617181920package com.hs.web;import com.hs.service.UserService;public class UserController &#123; private UserService userService; public UserController() &#123; &#125; public UserController(UserService userService) &#123; this.userService = userService; &#125; public void add() &#123; System.out.println("UserController层---&gt;ADD"); userService.add(); &#125;&#125; beans.xml 12345678&lt;bean id="userServiceImpl" class="com.hs.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="userDao" ref="userDaoImpl"/&gt;&lt;/bean&gt;&lt;bean id="userController" class="com.hs.web.UserController"&gt; &lt;constructor-arg name="userService"&gt; &lt;ref bean="userServiceImpl"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 这两段代码相当于，完成了private UserService userService = new userServiceImpl(); 5.代替UserController userController = new UserController();测试 12345678910111213141516171819package com.hs.test;import com.hs.web.UserController;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MethodTest &#123; @Test public void test01() &#123; // 1.读取配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml"); //获取xml版本里的UserController userController = new UserController(); UserController userController = applicationContext.getBean("userController", UserController.class); userController.add(); &#125;&#125; 控制台输出： UserController层—&gt;ADDUserService层的实现类—&gt;ADDUserDao层的实现类—&gt;ADD]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（五）模拟实际开发的调用过程]]></title>
    <url>%2F2018%2F09%2F02%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[用传统方式(以前的知识)来模拟实际开发的调用过程。 源码获取github [TOC] 1.项目结构 2.jar包12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.dao层UserDao.java 12345package com.hs.dao;public interface UserDao &#123; void add();&#125; UserDaoImpl.java 1234567891011package com.hs.dao.impl;import com.hs.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("UserDao层的实现类---&gt;ADD"); &#125;&#125; 4.Service层UserService.java 123456package com.hs.service;public interface UserService &#123; void add();&#125; UserServiceImpl.java 12345678910111213141516package com.hs.service.impl;import com.hs.dao.UserDao;import com.hs.dao.impl.UserDaoImpl;import com.hs.service.UserService;public class UserServiceImpl implements UserService &#123; //建立联系（一共有三种方式） private UserDao userDao = new UserDaoImpl(); @Override public void add() &#123; System.out.println("UserService层的实现类---&gt;ADD"); this.userDao.add(); &#125;&#125; 5.Controller层UserController.java 123456789101112131415package com.hs.web;import com.hs.service.UserService;import com.hs.service.impl.UserServiceImpl;public class UserController &#123; //建立联系 private UserService userService = new UserServiceImpl(); public void add() &#123; System.out.println("UserController层---&gt;ADD"); this.userService.add(); &#125;&#125; 6.测试12345678910111213141516package com.hs.test;import com.hs.web.UserController;import org.junit.Test;public class MethodTest &#123; /** * 测试传统调用过程 */ @Test public void test01() &#123; UserController userController = new UserController(); userController.add(); &#125;&#125; 控制台输出： UserController层—&gt;ADDUserService层的实现类—&gt;ADDUserDao层的实现类—&gt;ADD 程序就是一层一层调用，先调用Controller层—&gt;Service层—&gt;Dao层]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（四）Spring的注入方式-Setter方式推荐]]></title>
    <url>%2F2018%2F08%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89Spring%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F-Setter%E6%96%B9%E5%BC%8F%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[Setter注入的3种方式，读取属性文件取值，赋值：普通值、数组，list，set、Map和Properties、自定义类型、接口实现类(接口回调) 源码获取github [TOC] 1.项目结构model里的内容跟上篇一样，再写get、set方法、toString方法即可，pom.xml见前几篇 2.Setter注入的3种方式Setter注入方式，必须要提供setter方法，并且有三种方式:标准方式，缩写，p方式(也有p方式引用) 3.普通值赋值beans.xml 12345678&lt;!--Setter注入方式，必须要提供setter方法，并且有三种方式:标准方式，缩写，p方式(也有p方式引用)--&gt;&lt;bean id="user01" class="com.hs.model.User" p:user_name="八戒"&gt; &lt;!--这个name的值不是属性值，是setter方法后面的值首字母小写--&gt; &lt;property name="user_id"&gt; &lt;value&gt;100&lt;/value&gt; &lt;/property&gt; &lt;!--&lt;property name="user_name" value="悟空"/&gt;--&gt;&lt;/bean&gt; 4.加载属性文件jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mssjdbc.mysql.username=rootjdbc.mysql.password=root beans.xml 12&lt;!--3.读取属性文件！！$&#123;key&#125;获取值--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 5.数组、list、map、set、propertiesbeans.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;bean id="user01" class="com.hs.model.User" p:hobbySet-ref="hobbySetRef"&gt; &lt;property name="hobbyArray"&gt; &lt;!--这里面的标签，赋值跟构造函数初始化一样的--&gt; &lt;array&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt; &lt;/array&gt;&lt;/property&gt;&lt;!--可以采用构造函数初始化一样，也可以引用util:list--&gt;&lt;property name="hobbyList" ref="hobbyListRef"/&gt;&lt;property name="map" ref="mapRef"/&gt;&lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="class"&gt;$&#123;jdbc.mysql.driver&#125;&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--这些util，不会咋用可以百度，util:xxx,list-class可以不用写--&gt;&lt;util:list id="hobbyListRef" list-class="java.util.ArrayList"&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt;&lt;/util:list&gt;&lt;util:set id="hobbySetRef"&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt;&lt;/util:set&gt;&lt;util:map id="mapRef"&gt; &lt;entry key="class" value="计算机"/&gt; &lt;entry key="name"&gt; &lt;value&gt;和尚&lt;/value&gt; &lt;/entry&gt;&lt;/util:map&gt; 6.自定义类型beans.xml 1234567&lt;bean id="user01" class="com.hs.model.User"&gt; &lt;property name="hsRole" ref="role"/&gt;&lt;/bean&gt;&lt;bean id="role" class="com.hs.model.Role"&gt; &lt;property name="role_name" value="超级管理员"/&gt;&lt;/bean&gt; 7.接口实现类(接口回调)(以后经常用！！)12&lt;bean id="user01" class="com.hs.model.User" p:hsTest-ref="testImpl"&gt;&lt;/bean&gt;&lt;bean id="testImpl" class="com.hs.model.ITestImpl"/&gt; 8.测试1234567891011/** * 测试 */@Testpublic void test01() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user01",User.class); System.out.println(user); user.getHsTest().print();&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（三）Spring的注入方式-构造函数注入]]></title>
    <url>%2F2018%2F08%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89Spring%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[在类名前面加@Component进行实例化类、在beans.xml中用构造函数实例化对象——普通值、数组，list，set、Map和Properties、自定义类型实例化、给自定义类型初始化数据、给自定义类型初始化数据——推荐引用方式、接口注入实现类(实现接口回调)重点啊！！！ SpringMvcSSM框架源码获取github[TOC]### 1.目录结构(需要的jar包均在环境搭建中有)### 2.在类名前面加@Component进行实例化类@Component//(value = “hsUser”) //相当于 (value = “hsUser”)就是id=hsUserbeans.xml123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!--1.启动Spring注解--&gt; &lt;context:annotation-config/&gt; &lt;!--2.扫描注解--&gt; &lt;context:component-scan base-package="com.hs"/&gt; &lt;/beans&gt; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.hs.model;import org.springframework.stereotype.Component;import java.util.*;@Component//(value = "hsUser") //相当于&lt;bean class="com.hs.model.User" id="user"/&gt; (value = "hsUser")就是id=hsUserpublic class User &#123; private String user_name; private Integer user_id; private String[] hobbyArray; private List&lt;String&gt; hobbyList; private Set&lt;String&gt; hobbySet; private Map&lt;String, Object&gt; map; private Properties properties; //Map&lt;string,string&gt; private Role hsRole; //这是自定义类型 private ITest hsTest; //定义接口变量 /** * 这里通过bean.xml构造函数初始化 * 1.ITestImpl testImpl = new ITestImpl(); * 2.hsTest = testImpl * 3.ITest hsTest = new ITestImpl(); * 典型的接口回调嘛 * @param hsTest */ public User(ITest hsTest) &#123; this.hsTest = hsTest; &#125; public User(Role hsRole) &#123; this.hsRole = hsRole; &#125; private User() &#123; &#125; public User(Map&lt;String, Object&gt; map, Properties properties) &#123; this.map = map; this.properties = properties; &#125; public User(Integer user_id, String user_name) &#123; this.user_name = user_name; this.user_id = user_id; &#125; public User(String user_name, Integer user_id, String[] hobbyArray, List&lt;String&gt; hobbyList, Set&lt;String&gt; hobbySet) &#123; this.user_name = user_name; this.user_id = user_id; this.hobbyArray = hobbyArray; this.hobbyList = hobbyList; this.hobbySet = hobbySet; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String[] getHobbyArray() &#123; return hobbyArray; &#125; public void setHobbyArray(String[] hobbyArray) &#123; this.hobbyArray = hobbyArray; &#125; public List&lt;String&gt; getHobbyList() &#123; return hobbyList; &#125; public void setHobbyList(List&lt;String&gt; hobbyList) &#123; this.hobbyList = hobbyList; &#125; public Set&lt;String&gt; getHobbySet() &#123; return hobbySet; &#125; public void setHobbySet(Set&lt;String&gt; hobbySet) &#123; this.hobbySet = hobbySet; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public Role getHsRole() &#123; return hsRole; &#125; public void setHsRole(Role hsRole) &#123; this.hsRole = hsRole; &#125; public ITest getHsTest() &#123; return hsTest; &#125; public void setHsTest(ITest hsTest) &#123; this.hsTest = hsTest; &#125; @Override public String toString() &#123; return "User&#123;" + "user_name='" + user_name + '\'' + ", user_id=" + user_id + ", hobbyArray=" + Arrays.toString(hobbyArray) + ", hobbyList=" + hobbyList + ", hobbySet=" + hobbySet + ", map=" + map + ", properties=" + properties + ", hsRole=" + hsRole + ", hsTest=" + hsTest + '&#125;'; &#125;&#125; ConstructorObjectTest.java 12345678910/** * 测试在类名前面加@Component进行实例化类 */@Testpublic void test01() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user",User.class); System.out.println(user);&#125; 3.在beans.xml中用构造函数实例化对象——普通值在spring中实例化对象，把类的构造函数设置成private，依然可以被实例化，在java中就不能被实例化 只要见到标签就是实例化。。。 User.java 1234public User(Integer user_id, String user_name) &#123; this.user_name = user_name; this.user_id = user_id; &#125; beans.xml 123456789101112&lt;!--User 类通过构造函数实例化--&gt;&lt;bean id="user01" class="com.hs.model.User"&gt; &lt;!--index=""(可以省略)是设置参数的索引(0开始)，是第几个 type可以不用写 name就是构造函数的参数值，value就是赋的值--&gt; &lt;!--翻译constructor：构造函数--&gt; &lt;constructor-arg name="user_id" value="100" index="0" type="java.lang.Integer"/&gt; &lt;constructor-arg name="user_name" index="1"&gt; &lt;value&gt;悟空&lt;/value&gt; &lt;!--上面是简写--&gt; &lt;!--设置空是&lt;null/&gt;--&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; ConstructorObjectTest.java 12345678910/** * 测试在beans.xml中用构造函数实例化对象——普通值 */@Testpublic void test02() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user01",User.class); System.out.println(user);&#125; 4.构造函数实例化数组，list，setUser.java 1234567public User(String user_name, Integer user_id, String[] hobbyArray, List&lt;String&gt; hobbyList, Set&lt;String&gt; hobbySet) &#123; this.user_name = user_name; this.user_id = user_id; this.hobbyArray = hobbyArray; this.hobbyList = hobbyList; this.hobbySet = hobbySet;&#125; beans.xml 1234567891011121314151617181920212223242526272829&lt;!--构造函数实例化数组，list，set--&gt;&lt;bean id="user02" class="com.hs.model.User"&gt; &lt;constructor-arg name="user_name" value="八戒" index="0"/&gt; &lt;constructor-arg name="user_id" value="200" index="1"/&gt; &lt;constructor-arg name="hobbyArray" index="2"&gt; &lt;array&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="hobbyList"&gt; &lt;list&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="hobbySet"&gt; &lt;set&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;足球&lt;/value&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;音乐&lt;/value&gt; &lt;/set&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; ConstructorObjectTest.java 12345678910/** * 测试在beans.xml中用构造函数实例化对象——数组，list，set */@Testpublic void test03() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user02",User.class); System.out.println(user);&#125; 5.构造函数实例化Map和PropertiesUser.java 1234public User(Map&lt;String, Object&gt; map, Properties properties) &#123; this.map = map; this.properties = properties;&#125; beans.xml 12345678910111213141516171819&lt;!--构造函数实例化Map，Properties--&gt;&lt;bean id="user03" class="com.hs.model.User"&gt; &lt;constructor-arg name="map"&gt; &lt;map&gt; &lt;entry key="hs"&gt; &lt;value&gt;和尚&lt;/value&gt; &lt;/entry&gt; &lt;!--缩写--&gt; &lt;entry key="name" value="悟空"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg name="properties"&gt; &lt;props&gt; &lt;!--给Properties赋值--&gt; &lt;prop key="age"&gt;100&lt;/prop&gt; &lt;prop key="RuntimeExceiption"&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 测试 12345678910/** * 测试在beans.xml中用构造函数实例化对象——Map和Properties */@Testpublic void test04() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user03",User.class); System.out.println(user);&#125; 6.初始化自定义类型Role.java 12345678910111213141516171819202122232425262728package com.hs.model;public class Role &#123; private String role_name; public Role() &#123; &#125; public Role(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_name='" + role_name + '\'' + '&#125;'; &#125;&#125; User.java 1private Role hsRole; //这是自定义类型 beans.xml 123456&lt;!--构造函数初始化自定义类型--&gt;&lt;bean id="user04" class="com.hs.model.User"&gt; &lt;constructor-arg name="hsRole"&gt; &lt;bean id="role1" class="com.hs.model.Role"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 测试 12345678910111213/** * 自定义类型实例化，给User类中的Role类的变量，进行实例化操作 */@Testpublic void test05() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user04",User.class); System.out.println(user); //下面这个证明User类的那个bean Role role,范围只能在User里 /*Role role1 = ac.getBean("role1", Role.class); System.out.println(role1);*/&#125; 7.构造函数实例化自定义类型Role.java 123public Role(String role_name) &#123; this.role_name = role_name;&#125; User.java 123public User(Role hsRole) &#123; this.hsRole = hsRole;&#125; beans.xml 12345678&lt;!--构造函数实例化自定义类型--&gt;&lt;bean id="user05" class="com.hs.model.User"&gt; &lt;constructor-arg name="hsRole"&gt; &lt;bean class="com.hs.model.Role"&gt; &lt;constructor-arg name="role_name" value="超级管理员"/&gt; &lt;/bean&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 测试 12345678910/** * 给自定义类型初始化数据 */ @Test public void test06() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user05",User.class); System.out.println(user); &#125; 8.推荐引用方式——构造函数实例化自定义类型beans.xml 1234567891011&lt;!--构造函数实例化自定义类型——推荐引用方式--&gt;&lt;bean id="user06" class="com.hs.model.User"&gt; &lt;!--&lt;constructor-arg name="hsRole"&gt; &amp;lt;!&amp;ndash;引用bean，下面简写&amp;ndash;&amp;gt; &lt;ref bean="role2"/&gt; &lt;/constructor-arg&gt;--&gt; &lt;constructor-arg name="hsRole" ref="role2"/&gt;&lt;/bean&gt;&lt;bean id="role2" class="com.hs.model.Role"&gt; &lt;constructor-arg name="role_name" value="引用方式推荐"/&gt;&lt;/bean&gt; 测试 123456789101112/** * 给自定义类型初始化数据——推荐引用方式 */@Testpublic void test07() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user06",User.class); System.out.println(user); Role role = ac.getBean("role2", Role.class); System.out.println(role);&#125; 9.构造函数实现接口回调，接口注入实现类（重点！！！）ITest.java 123456package com.hs.model;public interface ITest &#123; void print();&#125; ITestImpl.java 123456789package com.hs.model;public class ITestImpl implements ITest &#123; @Override public void print() &#123; System.out.println("Hello Word!!"); &#125;&#125; User.java 1234567891011121314private ITest hsTest; //定义接口变量/** * 这里通过bean.xml构造函数初始化 * 1.ITestImpl testImpl = new ITestImpl(); * 2.hsTest = testImpl * 3.ITest hsTest = new ITestImpl(); * 典型的接口回调嘛 * @param hsTest */public User(ITest hsTest) &#123; this.hsTest = hsTest;&#125; beans.xml 1234567891011&lt;!--实现接口回调，接口注入实现类--&gt;&lt;!-- 这里通过bean.xml构造函数初始化 1.ITestImpl testImpl = new ITestImpl(); 2.hsTest = testImpl --&gt;&lt;bean id="user07" class="com.hs.model.User"&gt; &lt;constructor-arg name="hsTest"&gt; &lt;ref bean="testImpl"/&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--ITestImpl testImpl = new ITestImpl();--&gt;&lt;bean id="testImpl" class="com.hs.model.ITestImpl"/&gt; 测试 12345678910/** * 接口注入实现类，实现接口回调 */@Testpublic void test08() &#123; ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user = ac.getBean("user07",User.class); user.getHsTest().print();&#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（二）Spring的环境搭建]]></title>
    <url>%2F2018%2F08%2F23%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89Spring%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring个人概述，核心配置文件(.xml)里的bean标签什么时候被实例化，获取对象的两种方式，Bean的范围说明，beans.xml就是spring框架提供的容器(管理Bean Bean就是对象 必须通过类 类必须可能进行实例化) 源码获取github [TOC] 1.Spring个人概述 Spring是轻量级别开源的框架(重量级别EJB)，解决并发也比较优秀 重点：Spring是一个 IoC(DI) 和 AOP 的 容器框架（JAVAEE框架的集合）:它主要是管理Bean的生命周期使用 XML完成对Bean的实例化 注解也是完成对Bean的实例化操作 Spring是一站式服务 什么是IoC？ 控制反转：控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 注入方式：https://zhidao.baidu.com/question/489516951.html 举例子说明控制反转 | 和尚是一个编剧写剧本，当我写该剧本的时候，我并不需要考虑谁合适演，但是我应该有权利决定谁来演 || ———————————————————— || 导演出现，编剧将选人物的权利移交出去，控制权移交出去 || 出品人出现，导演将选人物的权利移交出去，控制权移交出去 || 点餐 || 最开始：自己去食堂，自己去打菜，自己吃 || 外卖出现：只是需要发送一个请求告知外卖小哥，我想吃什么，那么外卖小哥为我们服务，将需要的菜取回来给我们品尝 || java体现 || 容器框架(Bean的生命周期创建 使用 销毁) || 管理Bean，也就是创建对象(也就是注入)(就不用我们自己new创建对象了) | 2.项目结构 3.Spring环境搭建框架流程都是：先找jar包=&gt;入口文件(核心配置文件beans.xml官方推荐的名字是applicationContext.xml)=&gt;使用API调用过程=&gt;测试 4.jar包pom.xml加入依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context-support --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-expression --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-tx --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 5.核心配置文件(入口)User.java 123456789101112131415161718192021222324package com.hs.model;public class User &#123; private String user_name; private Integer user_id; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125;&#125; beans.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--beans.xml就是spring框架提供的容器--&gt; &lt;!--管理Bean Bean就是对象 必须通过类 类必须可能进行实例化--&gt; &lt;!--下面那个代码相当于 java代码 HashMap map1 = new HashMap(); HashMapjava内置的类 --&gt; &lt;!--&lt;bean id="map1" class="java.util.HashMap"&gt;&lt;/bean&gt;--&gt; &lt;!--static User u1 = new User();只有一个new对象，Bean的范围说明——scope="singleton"默认为单例模式,scope可以不用写--&gt; &lt;bean id="u1" class="com.hs.model.User" scope="singleton"/&gt; &lt;!--User u2 = new User(); prototype多例模式，需要对象就new一个，每个不同--&gt; &lt;bean id="u2" class="com.hs.model.User" scope="prototype"/&gt;&lt;/beans&gt; 6.使用API调用过程获取对象两种方式： 12User user = (User) ac.getBean("u1");User user = ac.getBean("u1", User.class); ObjectTest.java 读取核心配置文件 == 发现了Bean标签就会对class对应的类进行实例化操作 ApplicationContext ac = new ClassPathXmlApplicationContext(“beans.xml”); 123456789101112131415/** * 同一个类的实例化对象比较 */ @Test public void test01() &#123;// 1.读取核心配置文件 == 发现了Bean标签就会对class对应的类进行实例化操作 ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml");// u1就是bean标签里的id的名字 User user1 = ac.getBean("u1", User.class); User user2 = ac.getBean("u2", User.class); System.out.println(user1); System.out.println(user2); System.out.println(user1==user2); //false System.out.println(user1.equals(user2)); //false &#125; 7.bean的范围说明ObjectTest.java 12345678910111213141516171819202122232425262728293031/** * Bean的范围说明——默认为单例模式 */ @Test public void test02() &#123;// 1.读取核心配置文件 == 发现了Bean标签就会对class对应的类进行实例化操作 ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user1 = ac.getBean("u1", User.class); User user2 = ac.getBean("u1", User.class); System.out.println(user1); System.out.println(user2); System.out.println(user1==user2); //true System.out.println(user1.equals(user2)); //true &#125; /** * Bean的范围说明——设置多例模式 */ @Test public void test03() &#123;// 1.读取核心配置文件 == 发现了Bean标签就会对class对应的类进行实例化操作 ApplicationContext ac = new ClassPathXmlApplicationContext("beans.xml"); User user1 = ac.getBean("u2", User.class); User user2 = ac.getBean("u2", User.class); System.out.println(user1); System.out.println(user2); System.out.println(user1==user2); //false System.out.println(user1.equals(user2)); //false &#125;]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea创建maven项目]]></title>
    <url>%2F2018%2F08%2F22%2Fidea%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[为什么要用maven呢，一方面jar包方便，另一方面以后工作中肯定要用到，现在就先学习学习，然后自己也在网上找了很多的教程，每个教程都各有特点，然后我自己就给自己总结了一个教程，做一个记录。 1.用模板快速创建Java SE工程 然后出现GroupID和ArtifactID填写，这两个是什么呢？ GroupID和ArtifactID的意思 转载：https://blog.csdn.net/qq_30137611/article/details/76762070 GroupId和ArtifactId被统称为“坐标”是为了保证项目唯一性而提出的，如果你要把你项目弄到maven本地仓库去，你想要找到你的项目就必须根据这两个id去查找。 GroupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多，其中org为非营利组织，com为商业组织。举个apache公司的tomcat项目例子：这个项目的GroupId是org.apache，它的域是org（因为tomcat是非营利项目），公司名称是apache，ArtifactId是tomcat。 比如我创建一个项目，我一般会将GroupId设置为cn.mht，cn表示域为中国，mht是我个人姓名缩写，ArtifactId设置为testProj，表示你这个项目的名称是testProj，依照这个设置，在你创建Maven工程后，新建包的时候，包结构最好是cn.zr.testProj打头的，如果有个StudentDao[Dao层的]，它的全路径就是cn.zr.testProj.dao.StudentDao 然后我自己的，GroupId一般就写com.hs 然后next会出现这个，user setting file 就是你自己maven的配置文件路径，local repository就是你自己设置的本地仓库路径 新建好的目录结构都什么意思然后一直next，这里会一直加载你依赖的包资源，这里点箭头的地方 新建好的项目，结构就是这样，跟不用maven创建的目录结构完全不一样，有点难受，然后自己百度了一大堆教程吧，自己也记录一下，com.hs下的都是快速模板的测试代码，可以删了 src/main/java 项目的java源代码 src/main/resources 项目的资源，比如SSM框架的核心文件，property文件 src/test/java 项目的测试类， src/test/resources 测试使用的资源 pom.xml 就是你写依赖包的地方 然后你就会发现，创建好的结果没有resources目录，这个就需要自己创建了，首先自己在java同级层级，创建一个resources文件夹，test同理这样 2.用模板快速创建Java EE工程 然后会同样出现上面的几步 3.不用快速模板生成工程把生成的图里的，方框里的√，不要勾选就可以了。]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记（一）Java基础知识复习]]></title>
    <url>%2F2018%2F08%2F22%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[对象的创建方式、获取对象并且进行比较、==和equals的区别、单例模式(饿汉和懒汉)、对象的初始化数据操作、数组的数据初始化操作有几种、各个类型的初始值是什么，User u1 = new User();这句话包含的知识点、无参构造函数和有参构造函数 源码获取github 学习spring的时候，都是用的maven项目学习，idea如何创建maven项目教程，传送门 [TOC] 1.项目结构 2.需要的jar包123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 3.对象的创建方式 使用new关键字实例化对象 使用Class_forName实例化对象 User.java 123456789101112131415161718192021222324package com.hs.model;public class User &#123; private String user_name; private Integer user_id; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125;&#125; CreateObject.java 123456789101112131415161718192021222324252627282930313233package com.hs.test;import com.hs.model.User;import org.junit.Test;/** * 对象的创建方式 */public class CreateObject &#123; /** * 使用new关键字实例化对象 */ @Test public void test01() &#123; User u = new User(); System.out.println(u); &#125; /** * 使用Class_forName实例化对象 * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException */ @Test public void test02() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; User u = (User) Class.forName("com.hs.model.User").newInstance(); //com.hs.model.User为类的全路径，newInstance()实例化对象 System.out.println(u); u.setUser_name("悟空"); System.out.println(u.getUser_name()); &#125;&#125; 4.获取对象并且进行比较 new 一次，就产生一个新的对象，两个对象都是不一样的，都是新的 对象每次都可以是一样的、同一个实例 GetObject.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.hs.test;import com.hs.model.User;import org.junit.Test;/** * 获取对象并且进行比较 */public class GetObject &#123; /** * 考查知识点，对象每次都可以是新的 */ @Test public void test01() &#123; User u1 = this.getUser(); User u2 = this.getUser(); System.out.println(u1); System.out.println(u2); System.out.println(u1 == u2); //结果是false System.out.println(u1.equals(u2)); //结果是false //百度==和equals比较的是什么？是内存地址，如果对象(都是继承了object(里面有equals方法))里重写equals，又是什么结果， &#125; public User getUser() &#123; //new 一次，就产生一个新的对象(内存地址不一样)，两个对象都是不一样的，都是新的 return new User(); &#125; /** * 考查知识点，对象每次都可以是一样的、同一个实例 */ @Test public void test02() &#123; User u1 = this.getUser02(); User u2 = this.getUser02(); System.out.println(u1); System.out.println(u2); System.out.println(u1 == u2); //结果是true System.out.println(u1.equals(u2)); //结果是true //百度==和equals比较的是什么？是内存地址，如果对象(都是继承了object(里面有equals方法))里重写equals，又是什么结果， u1.setUser_name("悟空"); System.out.println(u2.getUser_name()); //输出悟空，为什么会这样？设计到一个叫引用传递的 &#125; private static User u1 = new User(); //设计模式-单例的设计 饿汉(不管你用不用，我都先创建好),加了一个static，表示这是一个共享数据 public User getUser02() &#123; return this.u1; &#125; //懒汉(你用我才创建)---线程不安全 /*private static User u2; public User getUser002() &#123; if (u2 == null) &#123; u2 = new User(); &#125; return this.u2; &#125;*/&#125; 5.==和equals的区别 ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同 ==是指对内存地址进行比较 equals()是对字符串的内容进行比较 ==指引用是否相同 equals()指的是值是否相同 如果对象(都是继承了object(里面有equals方法))里重写equals了，又是不同结果 6.单例模式-设计模式 饿汉:不管你用不用，我都先创建好 1private static User u1 = new User(); //加了一个static，表示这是一个共享数据 懒汉：你用我才创建，线程不安全 1234567private static User u2; public User getUser002() &#123; if (u2 == null) &#123; u2 = new User(); &#125; return this.u2; &#125; 7.对象的初始化数据操作 构造函数—初始化数据 Setter方法 如果对象的属性不是private，可以实例化对象.属性=xx赋值 InitObject.java 12345678910111213141516171819202122232425262728293031/** * 构造函数—初始化数据 */@Testpublic void test01() &#123; User u1 = new User(); /*这一句话设计到的知识点： new 开辟一块堆内存空间 User(); 构造函数 1.创建对象 2.对数据进行初始化操作 u1: 在栈内存中定义了一个变量指向了堆内存空间 * */ /*构造函数知识点： 1.默认有一个无参构造函数 2.若写了一个有参构造函数，覆盖了默认的无参，直接new User()报错 3.第2点解决办法就是，再写一次无参构造函数 4.每个构造函数默认一个super(),不写也有，并且得在首行 * */ System.out.println(u1.getUser_name()); //初始化的数据为空&#125;/** * setter方法初始化数据，其实如果属性不private，可以直接对象的变量.属性赋值 */@Testpublic void test02() &#123; User u1 = new User(); u1.setUser_id(200); u1.setUser_name("八戒");&#125; 8.数组的初始化操作有几种 动态初始化 静态初始化 InitObject.java 12345678910Testpublic void test03() &#123; //动态初始化 int[] arr = new int[3]; //char[] arr = new char[3]; System.out.println(arr[2]); //静态初始化 boolean[] arr2 = &#123;false, true, true&#125;; //下面的那种简写 boolean[] arr3 = new boolean[]&#123;false, true, true&#125;;&#125; 9.数组各个类型的初始值(默认值) 类型 默认值 int 0 short 0 byte 0 float 0.0f double 0.0d long 0L boolean false char ‘/uoooo’(就是一个空白的) String null 10.User u1 = new User();这句话包含的知识点 new 开辟一块堆内存空间 User(); 构造函数1.创建对象 2.对数据进行初始化操作 u1: 在栈内存中定义了一个变量指向了堆内存空间 11.无参构造函数和有参构造函数 默认有一个无参构造函数 若写了一个有参构造函数，覆盖了默认的无参，直接new User()报错 第2点解决办法就是，再写一次无参构造函数 每个构造函数默认一个super(),不写也有，并且得在首行]]></content>
      <categories>
        <category>Spring学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（十二）踩过的坑（400、500异常）]]></title>
    <url>%2F2018%2F08%2F21%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%88400%E3%80%81500%E5%BC%82%E5%B8%B8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一些经常遇见的报400、500的错误，如果要用到HttpServletRequest这些包的，idea中springmvc文件上传的文件会在out里路径有，修改项目名字，运行报错 1.400异常1.当你不传递要去数据的时候,那么会报400错误，没有传递hs=tomcat的数据 2.后台接收数据，数据类型转换失败接收的数据类型是Integer，但是传过去的是字符串 2.500异常当你修改一个项目的名字，然后运行的时候会报这个错误，只需要把out里的缓存删掉，然后从新运行即可 3.映射路径相同的 模棱两可错误，controller里有两个相同的映射路径，/cy42/test03存在在两个方法里 4.cannot resolve symbol ‘HttpServletRequest’IDEA异常 cannot resolve symbol ‘HttpServletRequest’,找不到HttpServletRequest这些包，在idea中需要添加tomcat的Libraries，eclipse不需用 5.tomcat控制台 localhost log 等意思 6.部署项目到tomcat的时候，发现没有你的项目复制了一个module，发现部署项目到tomcat，然后没有你的项目，这样解决 部署项目的区别 7.项目命名的时候不能用点导入项目的时候会出现这个情况，点代表层级文件]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（十一）拦截器专题]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[拦截器就是过滤器的一种, 拦截器有且只能拦截Controller层(Servlet) ，本文实现一个登录拦截器，没有登录就不能访问登录之后的页面。 源码获取github 1.项目结构 2.拦截器Java Web阶段学习过滤器 实现javax.servlet.Filter接口 过滤器是在服务器启动的时候就对齐进行实例化操作,如果你的过滤器错误,那么服务将无法启动,所以整个程序无法运行 init 初始化数据 doFilter(ServletRequest req , ServletResponse resp, ChainFilter chain) 强制类型转换 HttpServletRequest request = (HttpServletRequest)req; 关键的代码 chain.doFilter(req,resp); 访问下一个过滤器或者资源 destroy 服务器关闭 在web.xml中配置 123456789&lt;filter&gt; &lt;filter-name&gt; &lt;filter-class&gt; &lt;init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;url-patterns&gt;过滤的路径,我们自己可以设置规则 *.jsp *.html /*&lt;/url-patterns&gt; &lt;servlet-name&gt;servlet过滤器名字&lt;/servlet-name&gt;&lt;/filter-mapping&gt; 拦截器 : 理解为 拦截器就是过滤器的一种, 拦截器有且只能拦截Controller层(Servlet) @Controller的注解层次 3.如何建立拦截器1.新建一个类MyInterceptor.java 1234567891011121314151617181920212223242526package com.hs.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;///一般情况下,我们只是关心preHandle方法即可public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println("preHandle:访问Controller之前执行");// return false; //阻止访问下一个 return true; //访问下一个拦截器或资源 &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println("postHandle:访问到正确的视图之前"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println("afterCompletion:JSP页面加载完毕之后执行"); &#125;&#125; 2.配置文件在springmvc.xml中加入 12345678910111213&lt;!--7.配置自定义的拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--下面这个可以有多个--&gt; &lt;mvc:interceptor&gt; &lt;!--拦截的路径，类似url-patterns--&gt; &lt;mvc:mapping path="/sys/**"/&gt; &lt;mvc:mapping path="/vip/**"/&gt; &lt;!--排除路径，以下路径不经过拦截器处理--&gt; &lt;mvc:exclude-mapping path="/vip/test02/"/&gt; &lt;!--使用哪个拦截器处理--&gt; &lt;bean class="com.hs.interceptor.MyInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 3.新建controllerDemoController.java 123456789101112131415161718192021package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class DemoController &#123; @GetMapping("/sys/test01") public String test01() &#123; System.out.println("Controller层test01方法"); return "jsp/result01"; &#125; @GetMapping("/vip/test02") public String test02() &#123; System.out.println("Controller层test02方法"); return "jsp/result02"; &#125;&#125; 4.页面代码result01.jsp 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println("JSP-result01页面");%&gt;&lt;h2&gt;resulet01.jsp&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; result02.jsp 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println("JSP-result02页面");%&gt;&lt;h2&gt;resulet02.jsp&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 测试，在浏览器网址栏依次输入/sys/test01，/vip/test02，查看控制台输出 4.实现一个登录拦截器配置springmvc.xml123456&lt;!--登录设置的拦截器--&gt;&lt;mvc:interceptor&gt; &lt;mvc:mapping path="/sys/**"/&gt; &lt;mvc:exclude-mapping path="/sys/login"/&gt; &lt;bean class="com.hs.interceptor.LoginInterceptor"/&gt;&lt;/mvc:interceptor&gt; LoginController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;@Controller@RequestMapping("/sys")public class LoginController &#123; /** * 在地址栏输入/sys/login 进行请求转发跳转页面 * * @return */ @GetMapping("/login") public String login() &#123; return "jsp/login"; &#125; /** * 表单提交验证，存入session * * @param account * @param request * @return */ @PostMapping("/login") public String login(String account,HttpServletRequest request)&#123; System.out.println(account); HttpSession session = request.getSession(); if("admin".equals(account))&#123; session.setAttribute("session_user", account); //redirect重定向跳到另外一个controller里 return "redirect:/sys/main"; &#125; return "jsp/login"; &#125; /** * 登录成功重定向到这个controller，然后这个controller请求转发到一个页面 * @return */ @GetMapping("/main") public String main()&#123; return "jsp/result01"; &#125;&#125; login.jsp1234&lt;form action="login" method="post"&gt; &lt;input type="text" name="account"&gt; &lt;button&gt;登录&lt;/button&gt;&lt;/form&gt; 这里有一个很大的坑，自己纠结了很久，action的路径问题！！！ 如果写sys/login是绝对路径，login相对路径，因为请求转发到login.jsp,但是网址栏还是在sys这层，表单提交要到login那个，要不然就用相对路径，要不然就是绝对路径，相对直接login就行，绝对路径就是要这样写 123456789101112131415161718192021222324252627282930313233&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;% //项目的发布路径，例如: /rabc String path = request.getContextPath(); /* 全路径，形式如下: http://127.0.0.1:8001/rbac/ request.getScheme() ——&gt; http 获取协议 request.getServerName() --&gt; 127.0.0.1 获取服务名 request.getServerPort() --&gt; 8001 获取端口号 path --&gt; /rbac 获取访问的路径 路 */ String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";%&gt;&lt;%-- &lt;base/&gt;标签解决路径问题 参考文章:http://www.cnblogs.com/muqianying/archive/2012/03/16/2400280.html--%&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;登录&lt;/h2&gt;&lt;%--action的路径问题，sys/login绝对路径，login相对路径，因为请求转发到login.jsp,但是网址栏还是在sys这层，表单提交要到login那个，要不然就用相对路径，要不然就是绝对路径，相对直接login就行，绝对就是这样上面那一大堆--%&gt;&lt;form action="sys/login" method="post"&gt; &lt;input type="text" name="account"&gt; &lt;button&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; LoginInterceptor.java，登录拦截器1234567891011121314151617181920212223242526272829303132333435package com.hs.interceptor;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.PrintWriter;/** * 登录拦截器 */public class LoginInterceptor extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //1.获取HttpSession HttpSession session = request.getSession(); //2.判断是否登录 if (session.getAttribute("session_user") == null) &#123; //3.防止浏览器的后退功能 response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); out.write("&lt;script&gt;"); out.write("alert('您还没有登录过该系统，请登录！！！');"); out.write("window.top.location.href='"+request.getContextPath()+"/sys/login'"); out.write("&lt;/script&gt;"); out.flush(); out.close(); return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（十）异常处理专题]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[遇见异常跳转到自己设置的页面，注解方式处理局部异常，监听Controller类的全局异常处理，springmvc配置统一的简单异常处理，监听所有的页面异常 源码获取github 1.项目结构 2.局部异常处理ExceptionDemoController.java 1234567891011121314151617181920212223242526272829303132333435package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;/** * 经典异常处理_注解方式 */@Controllerpublic class ExceptionDemoController &#123; @GetMapping("/ex01") public String test01() &#123; int i = 10 / 0; //会报这个错误Request processing failed; nested exception is java.lang.ArithmeticException: / by zero return "jsp/result"; &#125; /** * 注解方式，处理异常，程序遇见这个异常，就会执行注解里的内容， *作用范围只有本类有效！！！ * @return */ //里面可以写多个异常，用,隔开，，，其实也可以总的写一个异常Exception,class @ExceptionHandler(value = &#123;ArithmeticException.class&#125;) public ModelAndView exception01(ArithmeticException ex) &#123; ModelAndView mav = new ModelAndView(); mav.addObject("ex", ex); mav.setViewName("jsp/error"); return mav; &#125;&#125; error.jsp 1234567891011121314151617181920&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;$&#123;requestScope.message&#125;&lt;/h2&gt;&lt;a href="javascript:void(0)" id="debug"&gt;[DEBUG]&lt;/a&gt;&lt;p id="error" style="display: none"&gt; $&#123;requestScope.ex&#125;&lt;/p&gt;&lt;script&gt; window.onload = function () &#123; document.getElementById("debug").onclick = function () &#123; document.getElementById("error").style.display = "block"; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.@ControllerAdvice监听所有Controller类的异常ExceptionAllController.java 1234567891011121314151617181920212223242526272829303132package com.hs.web;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import java.util.HashMap;import java.util.Map;/** * ControllerAdvice这个表示监听只要有Controller的类的异常，同样如果自身类有注解监听，满足谁近就运行谁的原则 */@ControllerAdvicepublic class ExceptionAllController &#123; /** * 监听Controller类的异常方式一 * * @param ex * @return */ @ExceptionHandler(value = &#123;Exception.class&#125;) public ModelAndView exception01(Exception ex) &#123; ModelAndView mav = new ModelAndView(); mav.addObject("ex", ex); mav.setViewName("jsp/error02"); return mav; &#125;&#125; ExceptionDemoController.java把上面那个局部处理异常注释就行， error02.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;本页是全局的异常监听跳转页面，本次监听到的异常是$&#123;requestScope.ex&#125;&lt;/body&gt;&lt;/html&gt; 4.springmvc.xml配置简单处理异常springmvc.xml加入 12345678910111213141516&lt;!--6.统一的简单异常处理，监听所有的页面异常--&gt;&lt;bean id="simpleMappingExceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt; &lt;!--出现异常，默认跳转的页面--&gt; &lt;property name="defaultErrorView" value="jsp/error"/&gt; &lt;!--类似于这个mav.addObject("ex", ex);--&gt; &lt;property name="exceptionAttribute" value="ex"/&gt; &lt;!--异常映射，若出现下列异常，就跳转相应的页面，不跳默认的--&gt; &lt;property name="exceptionMappings"&gt; &lt;props&gt; &lt;prop key="ArithmeticException"&gt;jsp/error&lt;/prop&gt; &lt;prop key="ArrayIndexOutOfBoundsException"&gt;jsp/error&lt;/prop&gt; &lt;prop key="RuntimeException"&gt;jsp/error&lt;/prop&gt; &lt;prop key="Exception"&gt;jsp/error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 5.自定义处理异常ExceptionAllController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 监听Controller类的异常方式二自定义异常 * @param ex * @param model * @return */ @ExceptionHandler(value = &#123;Exception.class&#125;) public String exception02(Exception ex, Model model) &#123; //判断类的类型 if (ex instanceof ArrayIndexOutOfBoundsException) &#123; model.addAttribute("message", "数组越界异常");//给客户看的 model.addAttribute("ex", ex);// return "jsp/error"; &#125; if (ex instanceof ArithmeticException) &#123; model.addAttribute("message", "运算异常"); //给客户看的 model.addAttribute("ex", ex);// return "jsp/error"; &#125; //处理自定义异常 return "jsp/error"; &#125; /** * 监听Controller类的异常方式二自定义异常____返回json格式 * @param ex * @return */ @ExceptionHandler(value = &#123;Exception.class&#125;) @ResponseBody public Map&lt;String,Object&gt; exception03(Exception ex) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;(); //判断类的类型 if (ex instanceof ArrayIndexOutOfBoundsException) &#123; map.put("message", "数组越界异常");//给客户看的 map.put("ex", ex);// return "jsp/error"; &#125; if (ex instanceof ArithmeticException) &#123; map.put("message", "运算异常"); //给客户看的 map.put("ex", ex);// return "jsp/error"; &#125; //处理自定义异常 return map; &#125; result.jsp 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;没有遇见注解里的异常，成功跳转&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（九）文件上传和下载]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件上传和下载，在上传的操作之后，跳转到下载页面 源码获取github 1.项目结构 2.上传操作单文件的上传 form表单传递数据 请求必须为POST请求 使用二进制流的方式传递数据 enctype=”multipart/form-data” 文件域 &lt;input type=”file” name=”myfile”/&gt; 上传的工具有两种： Servlet3.0 Commons-FileUpload commons-fileupload.jar commons-io.jar 第一步：配置解析器springmvc.xml加入 1234567891011121314&lt;!--5.使用上传的解析器，如果发现是上传操作，会自动使用该解析器帮我们完成相应的操作--&gt;&lt;!--该ID为固定值--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!--设置上传文件编码--&gt; &lt;!--简写方式 标签p c注入 p:defaultEncoding = "UTF-8"--&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;!--设置文件上传最大值024*200即200K--&gt; &lt;property name="maxUploadSize" value="20971520"/&gt; &lt;!--缓存，读取文件到内存中最大的字节数，可以不设置--&gt; &lt;property name="maxInMemorySize" value="2048"/&gt; &lt;!--延时提高上传效率，一个类似懒加载的属性--&gt; &lt;property name="resolveLazily" value="true"/&gt;&lt;/bean&gt; 如果是图片资源，还要配置静态资源排除，见之前的笔记 第二步：前端页面表单和前台验证file.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;单文件上传&lt;/h2&gt;&lt;form action="upload01" method="post" enctype="multipart/form-data" id="uploadForm"&gt; 标题：&lt;input type="text" name="title"&gt; 文件：&lt;input type="file" name="myfile" id="myfile"&gt;&lt;br&gt; &lt;button&gt;文件上传&lt;/button&gt;&lt;/form&gt;&lt;script type="text/javascript" src="resource/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; //元素选择器 $("button").click(function () &#123; //1.获取上传文件的对象，是数组，获取的第一个 var myfile = $("#myfile").prop("files")[0]; //2.判断文件是否有 if (myfile) &#123; //3.获取文件名称 var fileName = myfile.name; //4.获取文件的后缀名称 var ext = fileName.substring(fileName.lastIndexOf(".") + 1); //5.设置允许上传的文件后缀名称 var allowFileTypes = ["jpg", "png", "gif", "jpeg", "dmp", "rar"]; //6.设置一个标识，用来做判断 var flag = false; //循环判断上传格式是否正确 for (var i = 0; i &lt; allowFileTypes.length; i++) &#123; if (ext == allowFileTypes[i]) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; alert("您上传的文件格式不正确，允许的格式为：" + allowFileTypes.join(" | ")); return false; &#125; //7.判断文件的大小 if (myfile.size &gt; 20 * 1024 * 1024) &#123; alert("您上传的文件过大，请重新选择") &#125; return false; //8.表单提交 $&#123;"#uploadForm"&#125;.submit(); &#125; else &#123; alert("请选择您要上传的文件"); return false; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第三步：后台处理UploadDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.hs.web;import org.apache.commons.io.FilenameUtils;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.Date;import java.util.Random;/** * 文件上传操作 */@Controllerpublic class UploadDemoController &#123; /** * 单文件上传_标准写法 * * @param title * @param myfile * @param request * @return */ @PostMapping("/upload01") public ModelAndView test01(String title, MultipartFile myfile, HttpServletRequest request) throws IOException &#123; ModelAndView mav = new ModelAndView();// System.out.println(title); //1.获取上传文件的名称 String fileName = myfile.getOriginalFilename(); mav.addObject("fileName", fileName); //2.判断文件名称是否有值,isEmpty是这个字符串的length=0为true if (!fileName.isEmpty()) &#123; //3.获取服务器的绝对路径 String path = request.getServletContext().getRealPath("/upload"); //4.建立联系 File folder = new File(path); //5.判断该文件是否存在，不存在则创建文件夹 if (!folder.exists()) &#123; folder.mkdirs(); //创建文件夹 &#125; //6,获取上传文件的后缀名称 String ext = FilenameUtils.getExtension(fileName); //7.创建新的文件名称 //String newFileName = UUID.randomUUID().toString() + "." + ext; //或者用时间戳创建名称 String newFileName = new Date().getTime() + "_" + new Random().nextInt(100000) + "." + ext; mav.addObject("newFileName", newFileName);// System.out.println(newFileName); //8.文件上传，File.separator为斜线 myfile.transferTo(new File(path + File.separator + newFileName)); &#125; mav.addObject("hs", "和尚"); mav.setViewName("jsp/result"); /*System.out.println("测试是否可以获取正常的数据:"+title); System.out.println("====="); System.out.println("文件的MIME类型 :"+myfile.getContentType()); System.out.println("文件NAME属性对应的值 :"+myfile.getName()); System.out.println("上传文件的名称 :"+myfile.getOriginalFilename()); System.out.println("上传文件的大小 :"+myfile.getSize());*/ return mav; &#125;&#125; 3.下载操作方式一：直接超链接方式显示result.jsp 12&lt;h2&gt;直接超链接方式显示&lt;/h2&gt;&lt;a href="upload/$&#123;newFileName &#125;"&gt;$&#123;fileName &#125;&lt;/a&gt; 方式二：HTML5 中的download属性12&lt;h2&gt;HTML5 中的download属性&lt;/h2&gt;&lt;a href="upload/$&#123;newFileName &#125;" download="$&#123;fileName &#125;"&gt;$&#123;fileName &#125;&lt;/a&gt; 方式三：使用流的方法–到控制层处理12&lt;h2&gt;使用流的方法--到控制层处理，发送请求到控制器，download&lt;/h2&gt;&lt;a href="download?newFileName=$&#123;newFileName&#125;&amp;fileName=$&#123;fileName&#125;"&gt;$&#123;fileName &#125;下载&lt;/a&gt; 在springmvc.xml声明处理byte数组，在解决@ResponseBody在IE浏览器的BUG问题上面 12&lt;!--解决下载的时候转换问题,声明处理byte数组--&gt;&lt;bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/&gt; DownloadDemoController.java处理流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.hs.web;import org.apache.commons.io.FileUtils;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;/** * 文件下载操作 */@Controllerpublic class DownloadDemoController &#123; /** * 文件下载，使用流的方法 * * @param newFileName * @param fileName * @param request * @return * @throws IOException */ @GetMapping("/download") public ResponseEntity&lt;byte[]&gt; test02(String newFileName, String fileName, HttpServletRequest request) throws IOException &#123; //获取服务端的绝对路径 String path = request.getServletContext().getRealPath("/upload/"); HttpHeaders headers = new HttpHeaders(); //设置相应的内容为流 headers.setContentType(MediaType.TEXT_EVENT_STREAM); //设置下载的名称--和中文乱码的问题 headers.setContentDispositionFormData("attachment", new String(fileName.getBytes("UTF-8"), "ISO8859-1") ); //找到文件 File file = new File(path + File.separator + newFileName); return new ResponseEntity&lt;byte[]&gt;(FileUtils.readFileToByteArray(file),/*将文件转换为byte数组*/ headers, HttpStatus.CREATED); &#125;&#125;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（八）服务端数据传递客户端显示--后台传数据到前台]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%BE%E7%A4%BA-%E5%90%8E%E5%8F%B0%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E5%89%8D%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[JavaWeb阶段传递数据，ModelAndView传递数据，其他方式传递数据,通过读取ModelAndView的源码分析，ResponseEntiy返回JSON数据 - IE和谷歌浏览器正常，JSON返回日期处理方式 源码获取github 1.项目结构 2.JavaWeb阶段传递数据ModelAndViewDemoController.java 123456789101112131415161718/** * JavaWeb阶段传递数据 * * @param request * @param response * @throws ServletException * @throws IOException */@GetMapping("/server01")@ResponseBody //不处理public void test01(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute("hs", "和尚"); request.setAttribute("class", "计算机"); request.setAttribute("number", 8); //请求转发传递数据---这个没有通过视图解析器 request.getRequestDispatcher("/WEB-INF/jsp/result01.jsp").forward(request, response);&#125; result01.jsp 123456789101112&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;数据获取方式&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope.hs&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope["class"]&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;number&#125; ---默认情况下是从pageContext-&gt;request-&gt;session-&gt;application下开始寻找&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 3.ModelAndView传递数据—指明了key值ModelAndViewDemoController.java 123456789101112131415161718/** * 通过ModelAndView传递数据 * * @return */ @GetMapping("/server02") public ModelAndView test02() &#123; ModelAndView mav = new ModelAndView();// mav.addObject() 没有指明KEY //一步一步的追源码，发现一个ModelMap的类实例化对象.用它的addAttribute方法添加，ModelMap又是继承了HashMap mav.addObject("title", "通过ModelAndView传递数据"); mav.addObject("hs", "中国和尚"); mav.addObject("class", "计算机计科"); mav.addObject("number", 11); mav.setViewName("jsp/result02"); //请求转发，通过视图解析器 return mav; &#125; result02.jsp 123456789101112&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;$&#123;title&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope.hs&#125; --指明范围了的&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope["class"]&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;number&#125; ---默认情况下是从pageContext-&gt;request-&gt;session-&gt;application下开始寻找&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 4.ModelAndView传递数据—没有指明key值ModelAndViewDemoController.java 123456789101112131415161718192021222324252627/** * 传递数据没有指明KEY_默认KEY的规则 * * @return */ @GetMapping("/server03") public ModelAndView test03() &#123; ModelAndView mav = new ModelAndView(); mav.addObject("integer", 100); mav.addObject(200); mav.addObject("string", "字符串"); mav.addObject("悟空");// 规则：客户端获取没有加key的数据，默认key正常是数据对应的类型的首字母小写 Integer---integer String---string// 两个key一样的,只认最后一个// double是关键字，不能$&#123;double&#125;,只能$&#123;requestScope["double"] &#125; double a = 123.123; mav.addObject(a); User user = new User(); user.setMydate(new Date()); mav.addObject(user); mav.setViewName("jsp/result03"); //请求转发，通过视图解析器 return mav; &#125; result03.jsp 12345678910111213141516&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jstl/fmt_rt" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;$&#123;requestScope.integer &#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope.string &#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope["double"] &#125;-----因为double是关键字，所以不能.double&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope.user.mydate &#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope["user"]["mydate"] &#125;&lt;/h2&gt;日期格式化&lt;fmt:formatDate value="$&#123;user.mydate &#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/body&gt;&lt;/html&gt; 5.其他方式传递数据,通过读取ModelAndView的源码分析OtherDemoController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.GetMapping;import java.util.Map;/** * 其他的方式传递数据 */@Controllerpublic class OtherDemoController &#123; /** *其他1--通过Map在形参中实例化 * @param map * @return */ @GetMapping("/server04") public String test01(Map&lt;String,Object&gt; map) &#123; map.put("title", "Map在形参中定义，可以传递数据"); map.put("hs", "123"); map.put("class", "12222"); map.put("number", 1111); return "jsp/result04"; //通过请求转发视图解析器 &#125; /** * 其他2--通过ModelMap在形参中实例化 * @param modelMap * @return */ @GetMapping("/server05") public String test02(ModelMap modelMap) &#123; modelMap.addAttribute("title", "ModelMap进行传递数据"); modelMap.addAttribute("hs", "123"); modelMap.addAttribute("class", "12222"); modelMap.addAttribute("number", 1111); return "jsp/result04"; //通过请求转发视图解析器 &#125; /** * 其他3--通过Model接口传递数据 * @param model * @return */ @GetMapping("/server06") public String test03(Model model) &#123; model.addAttribute("title", "Model接口进行传递数据"); model.addAttribute("hs", "123"); model.addAttribute("class", "12222"); model.addAttribute("number", 1111); return "jsp/result04"; //通过请求转发视图解析器 &#125;&#125; result04.jsp 123456789101112&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;$&#123;title&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope.hs&#125; --指明范围了的&lt;/h2&gt;&lt;h2&gt;$&#123;requestScope["class"]&#125;&lt;/h2&gt;&lt;h2&gt;$&#123;number&#125; ---默认情况下是从pageContext-&gt;request-&gt;session-&gt;application下开始寻找&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 6.ResponseEntiy返回JSON数据 - IE和谷歌浏览器正常JsonDemoController.java 1234567891011121314151617181920212223242526272829303132333435363738/** * JSON格式1：ResponseEntity返回JSON数据格式 * * @return */@GetMapping("/json01")public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; test01() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name", "马老板"); map.put("sex", "男"); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_HTML); //设置响应方式,在HTML页面上显示 return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, headers, HttpStatus.CREATED);&#125;/** * JSON格式1：用List存多条JSON数据 * * @return */@GetMapping("/json02")public ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; test02() &#123; List&lt;Map&lt;String,Object&gt;&gt; tempList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "马老板"); map.put("sex", "男"); tempList.add(map); map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟空"); map.put("sex", "男"); tempList.add(map); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_HTML); return new ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;(tempList, headers, HttpStatus.CREATED);&#125; 7.@ResponseBody推荐方式返回json数据JsonDemoController.java 123456789101112131415161718192021222324252627282930313233/** * JSON格式3：简写方式 * * @return */@GetMapping("/json03")@ResponseBody //把java数据转换为JSON的字符串 存在BUG(IE浏览器不好使，解决办法在springmvc.xml配置)public Map&lt;String, Object&gt; test03() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name", "马老板"); map.put("sex", "男"); return map;&#125;/** * JSON格式4：简写方式 * * @return */@GetMapping("/json04")public @ResponseBody List&lt;Map&lt;String, Object&gt;&gt; test04() &#123; List&lt;Map&lt;String,Object&gt;&gt; tempList = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "马老板"); map.put("sex", "男"); tempList.add(map); map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟空"); map.put("sex", "男"); tempList.add(map); return tempList;&#125; 解决BUG问题在springmvc.xml配置 1234567891011121314151617&lt;!--1.启动SpringMVC注解--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;!--解决@ResponseBody在IE浏览器的BUG问题--&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="prettyPrint" value="true"/&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/plan;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; 8.JSON返回日期处理方式JsonDemoController.java 1234567891011/** * 处理日期格式，需要在user的date属性下加注解,或者springmvc配置全局日期处理 * @return */@GetMapping("/json05")@ResponseBodypublic User test05() &#123; User user = new User(); user.setMydate(new Date()); return user;&#125; User.java下设置 1234567891011121314151617181920212223242526package com.hs.model;import java.util.Date;public class User &#123; // 相放哪里就放哪里，pattern:格式，timezone:时区，这是设置东八区// @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date mydate; // @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss",timezone = "GMT+8")// @JsonFormat(pattern = "yyyy-MM-dd",timezone = "GMT+8") public Date getMydate() &#123; return mydate; &#125; public void setMydate(Date mydate) &#123; this.mydate = mydate; &#125; @Override public String toString() &#123; return "User&#123;" + "mydate=" + mydate + '&#125;'; &#125;&#125; springmvc.xml中配置全局的 12345678910111213141516171819202122232425262728293031&lt;!--1.启动SpringMVC注解--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;!--解决@ResponseBody在IE浏览器的BUG问题--&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="prettyPrint" value="true"/&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/plan;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--解决Jackson转换的日期问题，一劳永逸的办法，全局设置，但是和持久化类中的注解比，谁近更选择谁--&gt; &lt;property name="objectMapper"&gt; &lt;!--property：xxx属性--&gt; &lt;bean class="com.fasterxml.jackson.databind.ObjectMapper"&gt; &lt;!--bean：xx实例化了--&gt; &lt;property name="dateFormat"&gt; &lt;bean class="java.text.SimpleDateFormat"&gt; &lt;!--yyyy-MM-dd HH:mm:ss只能这么写，如果不显示小时，就需要在持久化类中注解设置--&gt; &lt;constructor-arg type="java.lang.String" value="yyyy-MM-dd HH:mm:ss"/&gt; &lt;!--constructor-arg：xx构造函数--&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（七）客户端数据传递中文乱码的解决方式]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[tomcat7中get和post请求中文乱码解决方案，tomcat8中get请求中文不会乱码，post请求会乱码 源码获取github 1.项目结构 2.tomcat7 get请求中文乱码—传统方式demo01.jsp 12345&lt;h2&gt;GET请求中文乱码-传统方式解决方案&lt;/h2&gt;&lt;form action="client01" method="get"&gt; &lt;input type="text" name="user_name"&gt; &lt;button&gt;GET请求&lt;/button&gt;&lt;/form&gt; UTFDemoController.java 12345678910111213141516171819 /** * Tomcat7中GET请求方式中文乱码-传统方式解决方案 * @param user_name * @return * @throws UnsupportedEncodingException */// @PostMapping("/client01") @GetMapping("/client01") public ModelAndView test01(String user_name) throws UnsupportedEncodingException &#123; //验证编码格式 //boolean equals = user_name.equals(new String(user_name.getBytes("UTF-8"), "UTF-8")); byte[] a = user_name.getBytes("ISO8859-1"); //用给定的编码，把字符串编码到byte序列 String b = new String(a,"UTF-8"); //通过使用指定的编码解码指定的 byte 数组，构造一个新的 String。 System.out.println(b); //简写// user_name = new String(user_name.getBytes("ISO8859-1"),"UTF-8"); //tomcat8 get请求默认为UTF-8 return null; &#125; 3.tomcat7 get请求中文乱码—修改tomcat服务里的sever.xml文件(全局修改，推荐)修改该文件后，传统的方式无法转换成功了，在你的tomcat服务里的sever.xml文件找到这个 1&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt; 加入 URIEncoding=”UTF-8” 4.post请求修改web.xml配置编码过滤器 12345678910111213141516171819202122&lt;!--1.解决POST请求的中文乱码问题--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--设置过滤器的一些变量的值--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; demo01.jsp 12345&lt;h2&gt;POST请求中文乱码-在web.xml中配置过滤器&lt;/h2&gt;&lt;form action="client03" method="post"&gt; &lt;input type="text" name="user_name"&gt; &lt;button&gt;post请求&lt;/button&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（六）客户端数据的类型转换]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[后台接收前台传来的日期类型，@DateTimeFormat注解简单使用，认识注解InitBinde，对要转换的字符串类型进行处理， 源码获取github 1.项目结构 2.@DateTimeFormat注解简单使用demo01.jsp 12345678910111213&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;传递日期的字符串&lt;/h2&gt;&lt;form action="client01" method="get"&gt; &lt;input type="text" name="mydate"&gt; &lt;button&gt;日期字符串&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; DateDemoController.java 12345678910111213141516/** * 接收日期类型的客户端传递数据，简写方式 * 没有写注解，就写 2018/8/14 15:31:20 * 写了注解就按照他的格式来，如果没有写时间，你输入了时间也不会认 * 如果一个类中也有这样的属性，同时接收这个时间，注解里也要写格式 * * @return */@GetMapping(&quot;/client01&quot;)public ModelAndView test01( @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) Date mydate, User user) &#123; System.out.println(mydate); System.out.println(user); return null;&#125; User.java 123456789101112131415161718192021222324252627package com.hs.model;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;public class User &#123;//注解放哪，根据公司要求// @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") Date mydate; public Date getMydate() &#123; return mydate; &#125; @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") public void setMydate(Date mydate) &#123; this.mydate = mydate; &#125; @Override public String toString() &#123; return "User&#123;" + "mydate=" + mydate + '&#125;'; &#125;&#125; 3.认识注解InitBindeInitBinderDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hs.web;import com.hs.model.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;/** * 认识注解InitBinder */@Controllerpublic class InitBinderDemoController &#123; @GetMapping("/test01") public ModelAndView test01() &#123; System.out.println("test01"); return null; &#125; @GetMapping("/test02") public ModelAndView test02(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println("test02"); return null; &#125; @GetMapping("/test03") public ModelAndView test03(Map&lt;String, Object&gt; map) &#123; System.out.println("test03"); return null; &#125; @GetMapping("/test04") public ModelAndView test04(Integer user_id) &#123; System.out.println("test04"); return null; &#125; @GetMapping("/test05") public ModelAndView test05(String name, Integer user_id) &#123; System.out.println("test05"); return null; &#125; @GetMapping("/test06") public ModelAndView test06(User user) &#123; System.out.println("test06"); return null; &#125; @GetMapping("/test07") public ModelAndView test07(User user, String name) &#123; System.out.println("test07"); return null; &#125; @InitBinder public void init01() &#123; System.out.println("需要知道什么情况下执行？"); &#125;&#125; 运行之后发现，04，06都是调用了1次，05,07调用了两次，因为这些的形参，被传递过来，都要进行转换，所以就调用了@InitBinder注解：当传递过来的数据要进行转换的时候才调用。 4.对要转换的字符串类型进行处理StringDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.WebDataBinder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.InitBinder;import org.springframework.web.servlet.ModelAndView;import java.beans.PropertyEditorSupport;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * 对要转换的字符串类型进行处理 */@Controllerpublic class StringDemoController &#123; @GetMapping("hs01") public ModelAndView test01(Integer user_id) &#123; System.out.println(user_id); return null; &#125; @GetMapping("hs02") public ModelAndView test02(String user_name) &#123; System.out.println(user_name); return null; &#125; @GetMapping("hs03") public ModelAndView test03(String user_name, Integer user_id) &#123; System.out.println(user_name); System.out.println(user_id); return null; &#125; /** * 时间格式的转换 * * @param date1 * @return */ @GetMapping("hs04") public ModelAndView test04(Date date1) &#123; System.out.println("日期为" + date1); return null; &#125; @InitBinder public void init01(WebDataBinder binder) &#123; //监控要转换(String)的数据类型 binder.registerCustomEditor(String.class, /*匿名对象*/new PropertyEditorSupport() &#123; //重写了setAsText方法 @Override public void setAsText(String text) throws IllegalArgumentException &#123; System.out.println("之前接收的值----" + text); //对数据重新处理赋值，赋值给形参user_name this.setValue("对数据处理之后的值----" + text + "悟空"); &#125; &#125;); //监控Integer类型 binder.registerCustomEditor(Integer.class, new PropertyEditorSupport() &#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; System.out.println(text); this.setValue("999"); &#125; &#125;); &#125; @InitBinder public void init02(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new PropertyEditorSupport() &#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); try &#123; Date date = df.parse(text); this.setValue(date); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 5.用别人封装好的工具类实现各种日期类型都可以转换需要commons-lang3-3.4.jar这个包 DateHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329package com.hs.util;import java.text.ParseException;import java.util.Calendar;import java.util.Date;import org.apache.commons.lang3.time.DateFormatUtils;import org.apache.commons.lang3.time.DateUtils;/** * 扩展DateUtils的基础上扩展属于自己的工具类 *造轮子 * @author 刘文铭 * @see com.shxt.commons.helper.DateHelper * @since 1.0 */public final class DateHelper extends DateUtils &#123; private final static String[] parsePatterns = &#123;"yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", "yyyy-MM", "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", "yyyy/MM", "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm", "yyyy.MM"&#125;; private final static String DEFAULT_DATE_TIME = "yyyy-MM-dd HH:mm:dd"; private final static String DEFAULT_DATE = "yyyy-MM-dd"; private final static String DEFAULT_TIME = "HH:mm:dd"; private final static String DEFAULT_YEAR = "yyyy"; private final static String DEFAULT_MONTH = "MM"; private final static String DEFAULT_DAY = "dd"; private final static String DEFAULT_E = "E"; private static Date nowDate = new Date(); private static Calendar calendar = Calendar.getInstance(); /** * java.util.Date转换格式（yyyy-MM-dd） * * @return String */ public static String getCurrentDate() &#123; return DateHelper.getDefDateTime(DEFAULT_DATE); &#125; /** * java.util.Date转换格式（HH:mm:ss） * * @return String */ public static String getCurrentTime() &#123; return DateHelper.getDefDateTime(DEFAULT_TIME); &#125; /** * java.util.Date转换格式（yyyy-MM-dd HH:mm:ss） * * @return String */ public static String getCurrentDateTime() &#123; return DateHelper.getDefDateTime(DEFAULT_DATE_TIME); &#125; /** * 获取自定义格式的当前日期 * &lt;p&gt; * 获取特定格式的日期 * &lt;/p&gt; * * @param pattern 默认格式（yyyy-MM-dd） 可以为："yyyy-MM-dd" "HH:mm:ss" "E" * @return String */ public static String getDefDateTime(String pattern) &#123; return DateFormatUtils.format(nowDate, pattern); &#125; /** * 得到当前年份字符串 格式（yyyy） * * @return String */ public static String getYear() &#123; return DateHelper.getDefDateTime(DEFAULT_YEAR); &#125; /** * 得到当前月份字符串 格式（MM） * * @return String */ public static String getMonth() &#123; return DateHelper.getDefDateTime(DEFAULT_MONTH); &#125; /** * 得到当天字符串 格式（dd） * * @return String */ public static String getDay() &#123; return DateHelper.getDefDateTime(DEFAULT_DAY); &#125; /** * 得到当前星期字符串 格式（E）星期几 * * @return String */ public static String getWeek() &#123; return DateHelper.getDefDateTime(DEFAULT_E); &#125; /** * 获取日期字符串,java.util.Date转化为字符串 * &lt;p&gt; * 使用格式化数据, * &lt;/p&gt; * * @param date * @param pattern 默认格式（yyyy-MM-dd） 可以为："yyyy-MM-dd" "HH:mm:ss" "E" * @return String */ public static String formatDate(Date date, String... pattern) &#123; String formatDate = null; if (pattern != null &amp;&amp; pattern.length &gt; 0) &#123; formatDate = DateFormatUtils.format(date, pattern[0].toString().trim()); &#125; else &#123; formatDate = DateFormatUtils.format(date, DEFAULT_DATE); &#125; return formatDate; &#125; /** * 日期型字符串转化为日期 格式 * &#123; "yyyy-MM-dd", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd HH:mm", * "yyyy/MM/dd", "yyyy/MM/dd HH:mm:ss", "yyyy/MM/dd HH:mm", * "yyyy.MM.dd", "yyyy.MM.dd HH:mm:ss", "yyyy.MM.dd HH:mm" &#125; */ public static Date parseDate(Object date_str) &#123; try &#123; if (date_str == null || String.valueOf(date_str).trim().length() == 0) &#123; return null; &#125; return DateUtils.parseDate(String.valueOf(date_str).trim(), parsePatterns); &#125; catch (ParseException pe) &#123; System.out.println("DateHelper--&gt;parseDate方法格式化错误"); return null; &#125; &#125; /** * 获取过去的天数 * * @param date * @return */ public static long pastDays(Date date) &#123; long t = new Date().getTime() - date.getTime(); return t / (24 * 60 * 60 * 1000); &#125; /** * 获取过去的小时 * * @param date * @return */ public static long pastHour(Date date) &#123; long t = new Date().getTime() - date.getTime(); return t / (60 * 60 * 1000); &#125; /** * 获取过去的分钟 * * @param date * @return */ public static long pastMinutes(Date date) &#123; long t = new Date().getTime() - date.getTime(); return t / (60 * 1000); &#125; /** * 转换为时间（天,时:分:秒.毫秒） * * @param timeMillis * @return */ public static String formatDateTime(long timeMillis) &#123; long day = timeMillis / (24 * 60 * 60 * 1000); long hour = timeMillis / (60 * 60 * 1000) - day * 24; long min = timeMillis / (60 * 1000) - day * 24 * 60 - hour * 60; long s = timeMillis / 1000 - day * 24 * 60 * 60 - hour * 60 * 60 - min * 60; long sss = timeMillis - day * 24 * 60 * 60 * 1000 - hour * 60 * 60 * 1000 - min * 60 * 1000 - s * 1000; return (day &gt; 0 ? day + "," : "") + hour + ":" + min + ":" + s + "." + sss; &#125; /** * 获取两个日期之间的天数 * * @param before * @param after * @return */ public static double getDistanceOfTwoDate(Date before, Date after) &#123; long beforeTime = before.getTime(); long afterTime = after.getTime(); return (afterTime - beforeTime) / (1000 * 60 * 60 * 24); &#125; /** * 获取当前日期,一周前的日期字符串 * * @return String */ public static String getLastWeek() &#123; long rightnow = calendar.getTimeInMillis(); long aweekbefore = 6 * 24 * 60 * 60 * 1000; return DateFormatUtils.format(rightnow - aweekbefore, DEFAULT_DATE); &#125; /** * 获取格式化当前月第一天的表达式 * * @return String */ public static String getFirstDayInMonth() &#123; calendar.set(DateHelper.getYearNUM(), DateHelper.getMonthNUM() - 1, 1);// 设为当前月的1号 ，月从0开始 return DateFormatUtils.format(calendar.getTime(), DEFAULT_DATE); &#125; /** * 获取格式化给定月(参数：逻辑月)第一天的表达式，重载方法 * * @param month * @return String */ public static String getFirstDayInMonth(int month) &#123; calendar.set(DateHelper.getYearNUM(), month - 1, 1);// 设为当前月的1号 ，月从0开始 return DateFormatUtils.format(calendar.getTime(), DEFAULT_DATE); &#125; /** * 获取格式化给定月(参数：逻辑月)最后一天的表达式 * * @param month * @return String */ public static String getLastDayInMonth(int month) &#123; calendar.set(DateHelper.getYearNUM(), month, 1); // 设成下个月的一号，往前减一天的时间 return DateFormatUtils.format(calendar.getTimeInMillis() - 24 * 60 * 60 * 1000, DEFAULT_DATE); &#125; /** * 获取格式化当前季度第一天的表达式 * * @return String */ public static String getFirstDayInQuart() &#123; int month = DateHelper.getMonthNUM(); if (month &gt;= 1 &amp;&amp; month &lt;= 3) &#123; month = 1; &#125; if (month &gt;= 4 &amp;&amp; month &lt;= 6) &#123; month = 4; &#125; if (month &gt;= 7 &amp;&amp; month &lt;= 9) &#123; month = 7; &#125; if (month &gt;= 10 &amp;&amp; month &lt;= 12) &#123; month = 10; &#125; calendar.set(DateHelper.getYearNUM(), month - 1, 1); // 当年当季一号，月从0开始 return DateFormatUtils.format(calendar.getTime(), DEFAULT_DATE); &#125; /** * @return String 获取格式化一年第一天的表达式 */ public static String getFirstDayInYear() &#123; /** 获取格式化一年第一天的表达式 **/ calendar.set(calendar.get(Calendar.YEAR), 0, 1); // 当年第一个月一号，月从0开始 return DateFormatUtils.format(calendar.getTime(), DEFAULT_DATE); &#125; /** * @return int 获得当前年份 */ public static int getYearNUM() &#123; /** 获得当前年份 */ return calendar.get(Calendar.YEAR); &#125; /** * @return int 获得当前月份 */ public static int getMonthNUM() &#123; /*** 获得当前月份 **/ return calendar.get(Calendar.MONTH) + 1; &#125; /** * @return int 获得当前周数 */ public static int getWeekNUM() &#123; /*** 获得当前周数 **/ return calendar.get(Calendar.DAY_OF_WEEK); &#125; /** * @return int 取到一天中的小时数 */ public static int getHoursofDay() &#123; return Calendar.HOUR_OF_DAY; &#125; /** * 获取最近ndays天(含今天)的日期，返回日期表达式数组 * * @param ndays * @return String[] */ public static String[] getDaysBackward(int ndays) &#123; String[] daysBackward = new String[ndays]; Calendar lastDate; for (int i = 0; i &lt; ndays; i++) &#123; lastDate = Calendar.getInstance(); lastDate.add(Calendar.DATE, -1 * i); // 减去一天，变为上月最后一天 daysBackward[ndays - 1 - i] = DateFormatUtils.format(lastDate.getTimeInMillis(), DEFAULT_DATE); &#125; return daysBackward; &#125;&#125; DateDemoController.java 12345678910111213141516171819202122/** * 用别人封装好的时间类型转换类，造轮子 * * @param mydate * @return */@GetMapping("/client01")public ModelAndView test01(Date mydate) &#123; System.out.println(mydate); return null;&#125;@InitBinderpublic void initDate(WebDataBinder binder) &#123; binder.registerCustomEditor(Date.class, new PropertyEditorSupport()&#123; @Override public void setAsText(String text) throws IllegalArgumentException &#123; this.setValue(DateHelper.parseDate(text)); &#125; &#125;);&#125; 页面还是那个demo01.jsp页面]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（五）客户端数据传递的专题(前台传数据到后台)]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%93%E9%A2%98(%E5%89%8D%E5%8F%B0%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E5%90%8E%E5%8F%B0)%2F</url>
    <content type="text"><![CDATA[简单的数据类型获取，数组的获取方式，对象专题，占位符传递简单数据，前台传来JSON格式字符串处理，两个对象和关联对象，不同对象的同属性解决方案，Map的写法(一般分页查询)，List的获取(一般批量添加)，json传给前台的解决方案，JavaScript对象和JSON格式字符串互转，java对象(自定义对象，集合)和JSON格式字符串互转，Ajax传递JSON,@RequestBody作用 源码获取github 1.项目结构 2.简单数据类型获取java web阶段获取方式demo01.jsp 12345678910111213141516171819&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;JAVA WEB阶段 服务端如何获取客户端的数据&lt;/h2&gt;&lt;form action="client01" method="get"&gt; &lt;input type="text" name="user_name"&gt;&lt;br&gt; &lt;input type="checkbox" name="hobby" value="basketball"&gt;篮球 &lt;input type="checkbox" name="hobby" value="football"&gt;足球 &lt;input type="checkbox" name="hobby" value="book"&gt;看书 &lt;br&gt; &lt;button&gt;传统模式&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; SimpleTypeDemoController.java 123456789101112131415/** * javaweb形式获取 * * @return */@RequestMapping("/client01")public ModelAndView test01(HttpServletRequest request) &#123; String user_name = request.getParameter("user_name"); String[] hobby = request.getParameterValues("hobby"); System.out.println("姓名" + user_name); for (String s : hobby) &#123; System.out.print(s + "--"); &#125; return null;&#125; @RequestParam获取数据demo02.jsp 12345678910111213141516&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;@RequestParam获取数据&lt;/h2&gt;&lt;form action="client02" method="get"&gt; &lt;%--&lt;input type="text" name="user_name"&gt;&lt;br&gt;--%&gt; &lt;input type="number" name="user_id"&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 获取数据写法,可以自动完成类型转换，name和value属性是等价的 SimpleTypeDemoController.java 123456789101112131415/** * 通过@RequestParam注解获取数据，注解还自动转换类型,value和name一样 * required是否必须要接受到这个值，默认true * defaultValue默认设置，如果没有接收到值，则默认设置值 * * @param request * @return */@RequestMapping("/client02")public ModelAndView test02(@RequestParam(value = "user_name", required = false) String name, @RequestParam(name = "user_id", required = false, defaultValue = "1111") Integer id) &#123; System.out.println("姓名" + name); System.out.println("ID" + id); return null;&#125; @RequestParam获取数据简写方式 只要传递的名称和形参的名称两者保持一致即可,并且默认情况下required=false demo03.jsp 1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;简写方式&lt;/h2&gt;&lt;form action="client03" method="get"&gt; &lt;input type="text" name="user_name"&gt;&lt;br&gt; &lt;input type="number" name="user_id"&gt;&lt;br&gt; &lt;br&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; SimpleTypeDemoController.java 123456789101112/** * 简写方式，传递的名称和接收的形参名字一样就可以，required默认为false * @param name * @param id * @return */@RequestMapping("/client03")public ModelAndView test03(String user_name,Integer user_id) &#123; System.out.println("姓名" + user_name); System.out.println("ID" + user_id); return null;&#125; 3.传递数组专题超链接传递数组、复选框传递数组、文本框传递数组、多选列表 demo04.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;超链接传递数组&lt;/h2&gt;&lt;a href="client04?role_id=100&amp;role_id=200&amp;role_id=300"&gt;传递数组&lt;/a&gt;&lt;h2&gt;复选框传递数组&lt;/h2&gt;&lt;form action="client05"&gt; &lt;input type="checkbox" name="hobby" value="basketball"&gt;篮球 &lt;input type="checkbox" name="hobby" value="football"&gt;足球 &lt;input type="checkbox" name="hobby" value="book"&gt;看书 &lt;button&gt;简写方式&lt;/button&gt;&lt;/form&gt;&lt;h2&gt;文本框传递数组&lt;/h2&gt;&lt;form action="client06"&gt; &lt;input type="text" name="hobby"&gt; &lt;input type="text" name="hobby"&gt; &lt;button&gt;简写方式&lt;/button&gt;&lt;/form&gt;&lt;h2&gt;多选列表&lt;/h2&gt;&lt;form action="client07"&gt; &lt;select name="hobby" multiple="multiple"&gt; &lt;option value="music"&gt;音乐&lt;/option&gt; &lt;option value="book"&gt;看书&lt;/option&gt; &lt;option value="football"&gt;足球&lt;/option&gt; &lt;/select&gt; &lt;button&gt;简写方式&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ArrayTypeDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import java.util.Arrays;/** * 数组的获取方式 */@Controllerpublic class ArrayTypeDemoController &#123; /** * 超链接获取数组 * * @return */ @GetMapping("/client04") public ModelAndView test01(@RequestParam(name = "role_id") Integer[] roles) &#123; System.out.println(Arrays.asList(roles)); return null; &#125; /** * 复选框传递数组 * * @param roles * @return */ @GetMapping("/client05") public ModelAndView test02(String[] hobby) &#123; if (hobby != null) &#123; System.out.println(Arrays.asList(hobby)); &#125; else &#123; System.out.println("您没有爱好！"); &#125; return null; &#125; /** * 文本框传递数据 * * @param hobby * @return */ @GetMapping("/client06") public ModelAndView test03(String[] hobby) &#123; System.out.println(Arrays.asList(hobby)); return null; &#125; /** * 多选列表传递数组 * * @param hobby * @return */ @GetMapping("/client07") public ModelAndView test04(String[] hobby) &#123; if (hobby != null) &#123; System.out.println(Arrays.asList(hobby)); &#125; else &#123; System.out.println("您没有爱好！！"); &#125; return null; &#125;&#125; 4.对象专题User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hs.model;public class User &#123; private Integer user_id; private String user_name; private String sex; private Role role; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", user_name='" + user_name + '\'' + ", sex='" + sex + '\'' + ", role=" + role + '&#125;'; &#125;&#125; Role.java 123456789101112131415161718192021package com.hs.model;public class Role &#123; private String role_name; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_name='" + role_name + '\'' + '&#125;'; &#125;&#125; Student.java 1234567891011121314151617181920212223242526272829303132333435363738394041package com.hs.model;public class Student &#123; private Integer user_id; private String user_name; private String sex; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return "Student&#123;" + "user_id=" + user_id + ", user_name='" + user_name + '\'' + ", sex='" + sex + '\'' + '&#125;'; &#125;&#125; 简单对象属性名和传递名称一致传递的名称和类中属性保持一致即可,如果传递的数据类型转换失败会报400错误 页面内容都是在demo05.jsp，java代码都在ModelTypeDemoController.java demo05.jsp 123456&lt;h2&gt;简单对象数据传递：传递的名称(name)为类中的属性名字一样即可&lt;/h2&gt;&lt;form action=&quot;client08&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; ModelTypeDemoController.java 12345678910111213/** * 简单对象传递 * * @return */@GetMapping("/client08")public ModelAndView test01(User user, String user_name, String sex) &#123; System.out.println(user); System.out.println("-----依然可以使用简单方式----"); System.out.println(user_name); System.out.println(sex); return null;&#125; 多个对象一个表单有两个对象[对象中的属性名称不一致 1234567&lt;h2&gt;多个对象&lt;/h2&gt;&lt;form action=&quot;client09&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;user_name&quot;&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt; 角色名称：&lt;input type=&quot;text&quot; name=&quot;role_name&quot;&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; 1234567891011121314/** * 多个对象传递 * * @param user * @param role * @return */@GetMapping("/client09")public ModelAndView test02(User user, Role role) &#123; System.out.println(user); System.out.println("-----角色----"); System.out.println(role); return null;&#125; 关联对象方式一：后台处理1234567&lt;h2&gt;多个对象进行关联方式一:后台处理&lt;/h2&gt;&lt;form action="client10"&gt; 姓名：&lt;input type="text" name="user_name"&gt; 性别：&lt;input type="text" name="sex"&gt; 角色名称：&lt;input type="text" name="role_name"&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; 1234567891011121314/** * 关联对象_方式一:后台处理 * * @param user * @param role * @return */@GetMapping("/client10")public ModelAndView test03(User user, Role role) &#123; //设置关联关系 user.setRole(role); System.out.println(user); return null;&#125; 方式二：前台处理（重点掌握）1234567&lt;h2&gt;多个对象进行关联方式二：前台处理&lt;/h2&gt;&lt;form action="client11"&gt; 姓名：&lt;input type="text" name="user_name"&gt; 性别：&lt;input type="text" name="sex"&gt; 角色名称：&lt;input type="text" name="role.role_name"&gt;&lt;%--name=类中.属性--%&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; 1234567891011/** * 关联对象_方式二：前台处理 * * @param user * @return */@GetMapping("/client11")public ModelAndView test04(User user) &#123; System.out.println(user); return null;&#125; 不同对象同属性传递借助第三方类1234567891011&lt;h2&gt;不同对象同属性传递借助第三方类&lt;/h2&gt;&lt;form action="client12"&gt; &lt;h3&gt;用户&lt;/h3&gt; 姓名：&lt;input type="text" name="user.user_name"&gt; 性别：&lt;input type="text" name="user.sex"&gt; 角色信息：&lt;input type="text" name="user.role.role_name"&gt; &lt;h3&gt;学生&lt;/h3&gt; 姓名：&lt;input type="text" name="student.user_name"&gt; 性别：&lt;input type="text" name="student.sex"&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; 1234567891011/** * 不同对象，同属性问题，借助第三方类解决问题 * * @return */@GetMapping("/client12")public ModelAndView test05(HsModel hsModel) &#123; System.out.println(hsModel.getStudent()); System.out.println(hsModel.getUser()); return null;&#125; 第三方类HsModel.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.hs.model;import java.util.List;import java.util.Map;public class HsModel &#123; private User user; private Student student; private Map&lt;String,Object&gt; query; private List&lt;Student&gt; studentList; public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125; public Map&lt;String, Object&gt; getQuery() &#123; return query; &#125; public void setQuery(Map&lt;String, Object&gt; query) &#123; this.query = query; &#125; public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public void setStudentList(List&lt;Student&gt; studentList) &#123; this.studentList = studentList; &#125; @Override public String toString() &#123; return "HsModel&#123;" + "user=" + user + ", student=" + student + ", query=" + query + ", studentList=" + studentList + '&#125;'; &#125;&#125; 5.Map的写法demo05.jsp 123456&lt;h2&gt;如果是Map属性也是借助第三方类&lt;/h2&gt;&lt;form action="client13"&gt; 姓名：&lt;input type="text" name="query['user_name']"&lt;%--属性['需要设置的key值']--%&gt;&gt; 性别：&lt;input type="text" name="query['sex']"&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; MapTypeDemoController.java 123456789101112131415161718192021222324package com.hs.web;import com.hs.model.HsModel;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;/** * Map_分页保存查询 */@Controllerpublic class MapTypeDemoController &#123; /** * map接收数据，通过第三方类 * @param hsModel * @return */ @GetMapping(&quot;/client13&quot;) public ModelAndView test01(HsModel hsModel) &#123; System.out.println(hsModel.getQuery()); return null; &#125;&#125; 6.List的写法demo05.jsp 123456789101112&lt;h2&gt;传递List也是借助第三方类&lt;/h2&gt;&lt;form action="client14"&gt; 姓名：&lt;input type="text" name="studentList[0].user_name"&gt; &lt;%--设置第1条数据的user_name--%&gt; 性别：&lt;input type="text" name="studentList[0].sex"&gt;&lt;%--设置第1条数据的sex--%&gt; &lt;hr/&gt; 姓名：&lt;input type="text" name="studentList[1].user_name"&gt; &lt;%--设置第2条数据的user_name--%&gt; 性别：&lt;input type="text" name="studentList[1].sex"&gt; &lt;hr/&gt; 姓名：&lt;input type="text" name="studentList[5].user_name"&gt; &lt;%--设置第6条数据的user_name,同时也设置了这个list长度是6--%&gt; 性别：&lt;input type="text" name="studentList[5].sex"&gt; &lt;button&gt;提交数据&lt;/button&gt;&lt;/form&gt; studentList[1].user_name 类中属性 [ 索引 ]. 属性名 ListTypeDemoController.java 123456789101112131415161718package com.hs.web;import com.hs.model.HsModel;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.servlet.ModelAndView;/** * List数据_一般做批量添加 */@Controllerpublic class ListTypeDemoController &#123; @GetMapping("/client14") public ModelAndView test01(HsModel hsModel) &#123; System.out.println(hsModel.getStudentList()); return null; &#125;&#125; 7.占位符传递数据demo05.jsp 1234&lt;h2&gt;占位符传递数据&lt;/h2&gt;&lt;a href="client15/11110/tomcat?sex=man"&gt;占位符传递数据&lt;/a&gt;&lt;h2&gt;占位符传递数据——可以直接使用Map来接收数据&lt;/h2&gt;&lt;a href="client16/123/tomcat?sex=man"&gt;使用Map接收数据&lt;/a&gt; PlaceholderTypeDemoController.java 1234567891011121314151617181920212223242526272829303132333435package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.servlet.ModelAndView;import java.util.Map;/** * 占位符传递简单数据 */@Controllerpublic class PlaceholderTypeDemoController &#123; @GetMapping("/client15/&#123;id&#125;/&#123;name&#125;") public ModelAndView test01( @PathVariable("id") int user_id,/*占位符的名字和形参不一样，在PathVariable中需要写占位符的名字*/ @PathVariable String name,/*一样则可以省略*/ String sex /*@RequestParam的简写方式*/ ) &#123; System.out.println(user_id); System.out.println(name); System.out.println(sex); return null; &#125; @GetMapping("/client16/&#123;id&#125;/&#123;name&#125;") public ModelAndView test01( @PathVariable Map&lt;String,Object&gt; map,/*占位符的名字作为key值*/ String sex /*@RequestParam的简写方式*/ ) &#123; System.out.println(map); System.out.println(sex); return null; &#125;&#125; 8.JavaScript对象和JSON互转需要Jackson的三个jar包：jackson-annotations-2.8.1.jar，jackson-core-2.8.1.jar，jackson-databind-2.8.1.jar demo06.jsp(在浏览器F12，看console输出) 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //给对象赋值的几种方 式 var obj = &#123; user_name: &quot;悟空&quot;, sex: &quot;男&quot;, hobby: [&quot;basktball&quot;, &quot;football&quot;], classInfo: &#123; class_name: &quot;计算机&quot;, number:8 &#125; &#125;; obj.nickname = &quot;齐天大圣&quot;; obj[&quot;age&quot;] = 500; console.log(obj); //1.将JavaScript对象转换为JSON格式的字符串 var jsonStr = JSON.stringify(obj); console.log(jsonStr); //2.将JSON格式的字符串转换为JavaScript对象 var hs = JSON.parse(jsonStr); console.log(hs);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 9.java对象和json互转JSON2JavaTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.test;import com.fasterxml.jackson.databind.JavaType;import com.fasterxml.jackson.databind.ObjectMapper;import com.hs.model.Role;import com.hs.model.User;import org.junit.Test;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class JSON2JavaTest &#123; /** * Java对象和JSON字符串的互相转换 */ @Test public void test01() throws IOException &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("user_name","悟空"); map.put("age", 500); map.put("hobby",/*静态初始化数据*/ new String[]&#123;"music","book"&#125;); System.out.println("转换之前的Map:"+map); //1.java对象转JSON格式的字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(map); System.out.println("java对象转JSON格式的字符串:"+jsonString); //2.JSON字符串转换为java对象 Map&lt;String, Object&gt; hsMap = objectMapper.readValue(jsonString, Map.class); System.out.println("JSON字符串转换为java对象:"+hsMap); &#125; /** * java对象转json字符串__自定义对象互相转换 * @throws Exception */ @Test public void test02() throws Exception &#123; User user = new User(); user.setUser_id(100); user.setUser_name("八戒"); user.setSex("男"); Role role = new Role(); role.setRole_name("超级管理员"); //建立联系 user.setRole(role); System.out.println("转换之前的User:"+user); //1.java对象转json字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(user); System.out.println("java对象转json字符串:"+jsonString); //2.json字符串转java对象 User hsUser = objectMapper.readValue(jsonString, User.class); System.out.println("json字符串转java对象:"+hsUser); &#125; /** * java对象转json字符串__集合 * @throws Exception */ @Test public void test03() throws Exception &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User user = new User(); user.setUser_id(100); user.setUser_name("八戒"); user.setSex("男"); Role role = new Role(); role.setRole_name("超级管理员"); user.setRole(role); userList.add(user); user = new User(); user.setUser_id(100); user.setUser_name("悟空"); user.setSex("男"); role = new Role(); role.setRole_name("管理员"); user.setRole(role); userList.add(user); System.out.println("转换之前的List&lt;User&gt;:"+userList); //1.java对象转json字符串 ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(userList); System.out.println("java对象转json字符串:"+jsonString); //2.json字符串转java对象 System.out.println("组成的List&lt;Map&gt;:"+objectMapper.readValue(jsonString, List.class)); //组成的是List&lt;Map&gt; JavaType t = objectMapper.getTypeFactory().constructParametricType(List.class, User.class); List&lt;User&gt; tempList = objectMapper.readValue(jsonString, t); System.out.println("json字符串转java对象:"+tempList); &#125;&#125; 10.前台传给后台json，然后返回给前台jsondemo07.jsp 1234567891011121314151617181920212223242526272829303132333435&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="resource/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; var obj = &#123; user_id:888, user_name:"悟空", sex:"男", role:&#123; role_name:"超级管理员" &#125; &#125;; //1.JavaScript对象转换json格式字符串 var jsonStr = JSON.stringify(obj); //2.将该字符串传递到controller /*$.get("json01",&#123;hs:jsonStr&#125;,function (data) &#123; //date是后台返回了一个JSON格式的字符串 alert(data); //alert(data)弹出这个字符串全部，下面那个是把json对象转换为JavaScript字符串好取值 &#125;)*/ $.get("json01",&#123;hs:jsonStr&#125;,function (data) &#123; //data转换一、或者加"json" // alert(JSON.parse(data); alert(data); //取这个JavaScript字符串的某个值 alert(data.role.role_name); &#125;,"json") &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSONTypeDemoController.java 1234567891011121314151617181920public class JSONTypeDemoController &#123; /** * 整个流程是，前台JavaScript转换json，把json传给后台，后台再转换为java对象，进行修改等操作， * 然后这个对象再通过注解@ResponseBody转换为前台data接收到的JSON格式的字符串 * @param hs * @return * @throws IOException */ @GetMapping("json01") @ResponseBody public User json01(String hs) throws IOException &#123; System.out.println(hs); //将前台传过来的json格式对象转换为java对象 ObjectMapper objectMapper = new ObjectMapper(); User user = objectMapper.readValue(hs, User.class); user.setSex("女"); return user; &#125; 如何只是单纯的写了上面代码，运行，会发现alert，不会出现数据，这是一个bug问题，需要解决，往前台传入json的，都需要配置这个，在springmvc.xml中加入 123456789101112131415161718192021&lt;!--1.启动SpringMVC注解--&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults="true"&gt; &lt;!--解决下载的时候转换问题--&gt; &lt;bean class="org.springframework.http.converter.ByteArrayHttpMessageConverter"/&gt; &lt;!--解决@ResponseBody在IE浏览器的BUG问题--&gt; &lt;bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"&gt; &lt;property name="prettyPrint" value="true"/&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/plan;charset=UTF-8&lt;/value&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; 11.Ajax传递JSON和@RequestBody的作用（强烈推荐使用这种）demo08.jsp 12345678910111213141516171819202122232425262728293031323334353637&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="resource/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function () &#123; var obj = &#123; user_id:888, user_name:"悟空", sex:"男", role:&#123; role_name:"超级管理员" &#125; &#125;; //1.JavaScript对象转换json格式字符串 var jsonStr = JSON.stringify(obj); //2.使用原生的方式 $.ajax(&#123; type:"POST",//必须为POST请求，如果你要传递JSON字符串 url:"json02", data:jsonStr, dataType:"json", //解析返回来的data数据的类型 contentType: "application/json;charset=UTF-8", processData:false, success:function (data) &#123; alert(data); &#125; &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSONTypeDemoController.java 1234567891011121314/** * 通过ajax传递过来数据，@RequestBody相当于完成了上面的 * ObjectMapper objectMapper = new ObjectMapper(); * User user = objectMapper.readValue(hs, User.class); * 这两步，但是前提是传过来的字段名和user类的属性名一样，才能正常转换 * @param user * @return */@PostMapping("/json02")@ResponseBodypublic User json02(@RequestBody User user) &#123; user.setUser_name("八戒"); return user;&#125;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（四）控制器形参和返回类型]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[控制器里形参的说明：类可以被实例化。关于返回值类型说明：ModelAndView 官方使用方式(传值，跳转页面)，void类型(直接输出页面)，String类型(也可以跳转页面)，任意数据类型(主要JSON数据处理) 源码获取github 1.项目结构 需要添加tomcat的依赖，要不然没有HttpServletRequest等类，eclipse不用 2.User.java12345678910111213141516171819202122232425262728293031package com.hs.model;public class User &#123; private Integer role_id; private String name; public Integer getRole_id() &#123; return role_id; &#125; public void setRole_id(Integer role_id) &#123; this.role_id = role_id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "User&#123;" + "role_id=" + role_id + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 3.形参的说明:可以被实例化FormalDemoController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.hs.web;import com.hs.model.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.ArrayList;import java.util.Map;/** * 控制器中的形参测试 */@Controllerpublic class FormalDemoController &#123; /** * 查看ServletAPI * 在形参中的类默认情况下是可以进行实例化的 * @return */ @RequestMapping(path = "/test01", method = RequestMethod.GET) public ModelAndView test01(HttpServletRequest request, HttpServletResponse response) &#123; //放在形参被实例化了 System.out.println(request); System.out.println(response); return null; &#125; @RequestMapping(path = "/test02", method = RequestMethod.GET) public ModelAndView test02(Map&lt;String, Object&gt; map) &#123; //默认实例化的HashMap System.out.println(map); return null; &#125; @RequestMapping(path = "/test03", method = RequestMethod.GET) public ModelAndView test03(String[] hobby) &#123; //没有实例化 System.out.println(hobby); return null; &#125; @RequestMapping(path = "/test04", method = RequestMethod.GET) public ModelAndView test04(User user) &#123; //实例化了 System.out.println(user); return null; &#125; @RequestMapping(path = "/test05", method = RequestMethod.GET) public ModelAndView test05(ArrayList&lt;String&gt; list) &#123; //List默认不会被实例化 System.out.println(list); return null; &#125; //什么时候使用基本数据类型和包装类 //1.当你确定数据一定存在的时候，请使用基本数据类型 //2.如果数据可能不存在，推荐使用包装类，推荐实体Bean持久化类名尽量使用包装类 @RequestMapping(path = "/test06", method = RequestMethod.GET) public ModelAndView test06(int role_id) &#123; //报错是因为role_id为null,int不能有null System.out.println(role_id); return null; &#125; @RequestMapping(path = "/test07", method = RequestMethod.GET) public ModelAndView test07(Integer role_id) &#123; System.out.println(role_id); return null; &#125;&#125; 4.result.jsp123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;测试&lt;/body&gt;&lt;/html&gt; 5.控制器中的数据返回类型 任意数据类型说明 JSON格式 FastJSON,但是SpringMVC是支持该FastJSON的,但是我们需要额外配置信息 SpringMVC默认支持的JSON数据的转发第三库为Jackson FastJSON/Jackson/Gson/JSON等库,目的都是 将JSON数据转换为Java对象 Java对象转换为JSON格式字符串 ReturnTypeDemoController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package com.hs.web;import com.fasterxml.jackson.databind.ObjectMapper;import com.hs.model.User;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.util.HashMap;import java.util.Map;/** * 控制器中的数据返回类型 */@Controllerpublic class ReturnTypeDemoController &#123; // @RequestMapping(path = "/hs01",method = &#123;RequestMethod.GET,RequestMethod.POST&#125;)// 简写 @GetMapping("/hs01")// @PostMapping// @PutMapping................ public ModelAndView test01() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName("jsp/result"); return mav; &#125; @GetMapping("/hs02") public void test02() &#123; System.out.println("void情况一：默认情况下是按照路径进行请求转发的的查找页面访问的是hs02.jsp"); &#125; /** * 通过servlet的跳转方式_个人不推荐 */ @GetMapping("/hs03") public void test03(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher("/WEB-INF/jsp/result.jsp").forward(request, response); &#125; /** * 直接输出页面 */ @GetMapping("/hs04") public void test04(HttpServletResponse response) throws IOException &#123; response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); out.write("&lt;h1 style='color:blue'&gt;和尚&lt;/h1&gt;"); out.flush(); out.close(); &#125; /** * 默认情况下就是请求转发查找页面 * 先jsp请求转发解析器，再找jsp/result页面 * * @return */ @GetMapping("/hs05") public String test05() &#123; return "jsp/result"; &#125; /** * 也可以设置重定向 */ @GetMapping("/hs06") public String test06() &#123; return "redirect:/hs05"; &#125; /** * 输出内容_如何处理,需要设置编码通过过滤器 */ @GetMapping("/hs07") public ResponseEntity&lt;String&gt; test07() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_HTML); //设置响应的内容格式 String content = "&lt;h1 style='color:blue'&gt;沙僧222&lt;/h1&gt;"; return new ResponseEntity&lt;String&gt;(content, headers, HttpStatus.CREATED); &#125; /** * 输出内容_简写方式 */ @GetMapping(path = "/hs08",produces = "text/html;charset=UTF-8") //设置响应的内容格式和编码，后面配置过滤器就可以不写该代码了 @ResponseBody //针对于你返回的数据的类型进行转换，可以转换任意类型，但是需要第三方库的支持 public String test08() &#123; return "&lt;h1 style='color:blue'&gt;沙僧222&lt;/h1&gt;"; &#125; ///=================返回任意数据类型[服务端返回数据]======================= /** * 传统模式直接输出JSON数据 */ @GetMapping("/hs09") public void test09(HttpServletResponse response) throws IOException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("hs","和尚"); map.put("class", "计算机"); map.put("flag", true); response.setContentType("text/html;charset=UTF-8"); PrintWriter out = response.getWriter(); ObjectMapper objectMapper = new ObjectMapper(); String jsonStr = objectMapper.writeValueAsString(map); out.write(jsonStr); out.flush(); out.close(); &#125; /** * 通过JackJson返回Json数据 * @return */ @RequestMapping("/hs10") public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; test10() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("hs","111"); map.put("class", "2222"); map.put("flag", true); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.TEXT_HTML); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(map, headers, HttpStatus.CREATED); &#125; /** * 通过ResponseBody处理数据 * @return */ @RequestMapping("/hs11") @ResponseBody //对返回的数据进行处理，如果不是字符串，通过Jackson转换成json格式字符串 //遗留问题：在IE浏览器该注解有BUG public Map&lt;String, Object&gt; test11() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("hs","和尚"); map.put("class", "计算机"); map.put("flag", true); return map; &#125; /** * 通过ResponseBody处理数据 * 自定义的类型 * @return */ @RequestMapping("/hs12") @ResponseBody //对返回的数据进行处理，如果不是字符串，通过Jackson转换成json格式字符串 public User test12() &#123; User user = new User(); user.setRole_id(19999); user.setName("和尚"); return user; &#125;&#125; 个人觉得，hs01、hs05、hs11、hs12比较常用，@ResponseBody 真的很强大]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（三）静态资源排除方案]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%8E%92%E9%99%A4%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[对于静态资源(图片，css，js)这些请求，让他们不经过DispatcherServlet(这个再去找相应的控制器) 源码获取github 1.项目结构那哥test.jpg,随意自己找一张图片 2.解决方式一：推荐方式demo01.jsp 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;显示图片&lt;/h2&gt;&lt;img src="test.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt; 此时为了访问同路径下的test.jsp图片，但是如果直接访问，图片不会出来，那是因为请求会经过DispatcherServlet处理，找到一个控制器，现在为了让静态资源不经过DispatcherServlet。这样就能显示出来 在web.xml中加入 123&lt;!--4.静态资源(图片、js、css之类的)(让这些资源不经过DispatcherServlet处理)的处理方式一 推荐方式--&gt;&lt;mvc:default-servlet-handler default-servlet-name=&quot;default&quot;/&gt; 3.解决方式二：映射方式demo01.jsp 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;显示图片&lt;/h2&gt;&lt;%--&lt;img src="test.jpg" alt=""&gt;--%&gt;&lt;img src="image/test.jpg" alt=""&gt;&lt;/body&gt;&lt;/html&gt; 在web.xml中加入 123456&lt;!--4.静态资源(图片、js、css之类的)(让这些资源不经过DispatcherServlet处理)的处理方式一 推荐方式--&gt;&lt;!--&lt;mvc:default-servlet-handler default-servlet-name="default"/&gt;--&gt;&lt;!--4.静态资源的处理方式二(可以写多个，从上而下找，找到就不再找) 映射方式(mapping中/image/后面的数据，默认会追加到WEB-INF/后面，去/WEB-INF/下面去找资源加载出来)--&gt;&lt;mvc:resources mapping="/image/**" location="/WEB-INF/"/&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（二）@RequestMapping专题]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-RequestMapping%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于映射路径的定义方式(多路径，通配符，占位符传递数据)，控制传递的参数，请求方式(get,post,delete,put,patch) 源码获取github 1.项目结构 2.读取自定义核心配置文件的名称和位置web.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--自定义的核心配置文件的名字和位置--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.映射文件的@RequestMapping路径方式多路径访问，一个路径访问，使用通配符，占位符传递数据 PathDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * 映射路径的定义方式 */@Controller//(value = "hsController") //这就是给controller取的名字，默认是类名首字母小写@RequestMapping("/cy42") //这个是设置本类总的路径,比如你访问这个类的test01，网址栏就要写localhost:8080/mvc/cy42/test01public class PathDemoController &#123; @RequestMapping(path = &#123;"/test01","/test02"&#125;) public ModelAndView test01() &#123; System.out.println("多路径访问，用数组这样设置"); return null; &#125; @RequestMapping(path = "/test03") public ModelAndView test03() &#123; System.out.println("一个路径"); return null; &#125; @RequestMapping("/test04") public ModelAndView test04() &#123; System.out.println("只有一个路径属性的值，可以省略"); return null; &#125; //1.在映射路径中可以适应通配符 * //A.谁描述的清楚就找谁 eg:/test01 找/test01 //B.通配符使用的很少 @RequestMapping("/*") public ModelAndView test05() &#123; System.out.println("可以使用通配符"); return null; &#125; @RequestMapping("/**") public ModelAndView test06() &#123; System.out.println("任意层次"); return null; &#125; //使用占位符，一般只是传递主键和简单的字符串 // 完成REST风格的路径，优先级比通配符高 @RequestMapping("/&#123;user_id&#125;") //user_id接收输入的路径值 public ModelAndView test06(@PathVariable("user_id") String id) &#123; //使用注解，把user_id接收到的值赋给id System.out.println("使用占位符,"+id); System.out.println(id); return null; &#125;&#125; 在浏览器网址栏输入localhost:8080/mvc/cy42/xx访问这些路径，占位符访问就是localhost:8080/mvc/xxx,然后user_id就接收到了你的xxx值 4.在网址栏传递参数(params属性)ParamsDemoController.java 12345678910111213141516171819202122232425package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/**控制传递的参数 * 如果没有传递参数会报400的错误 */@Controller@RequestMapping("/vip")public class ParamsDemoController &#123; @RequestMapping(path = "/param01",params = "hs=tomcat") public ModelAndView test01() &#123; System.out.println("你必须要传递一下形式的数据里满足params里的数据，eg:param01?hs=tomcat&amp;id=100"); return null; &#125; @RequestMapping(path = "/param02",params = &#123;"hs!=tomcat","method=add"&#125;) public ModelAndView test02() &#123; System.out.println("!=,hs!=tomcat是指，只要不输入hs=tomcat，其他的都满足"); return null; &#125;&#125; 5.请求方式web.xml 在HTML页面,请求方式有几种? GET: GET在地址栏能看到数据 POST: 在地址栏不能看到数据 有且只有这两种请求！！ 但是SpirngMvc支持有8种请求方式 官方文档： HTTP Method Conversion A key principle of REST is the use of the Uniform Interface. This means that all resources (URLs) can be manipulated using the same four HTTP methods: GET, PUT, POST, and DELETE. For each method, the HTTP specification defines the exact semantics. For instance, a GET should always be a safe operation, meaning that is has no side effects, and a PUT or DELETE should be idempotent, meaning that you can repeat these operations over and over again, but the end result should be the same. While HTTP defines these four methods,HTML only supports two: GET and POST.Fortunately, there are two possible workarounds: 第一种: you can either use JavaScript to do your PUT or DELETE,[不推荐,因为有一些浏览器不不支持PUT/DELETE IE6/7/8] 第二种方式步骤如下： 第一步: 需要使用POST请求为真正的请求方式or simply do a POST with the ‘real’ method第二步: 表单当中需要自己设置一个隐藏的&lt;input&gt;标签as an additional parameter (modeled as a hidden input field in an HTML form).第三步: web.xml中配置过滤器 This latter trick is what Spring’s HiddenHttpMethodFilter does. This filter is a plain Servlet Filter (Servlet过滤器) /* 路径过滤器 名字Servlet过滤器and therefore it can be used in combination with any web framework (not just Spring MVC). Simply add this filter to your web.xml, and a POST with第四步: 你的&lt;input name=”_method” value=”GET|POST|DELETE|PUT”(不区分大小写)&gt;a hidden _method parameter will be converted into the corresponding HTTP method request. 下面代码加在 web.xml 123456789101112&lt;!--http的请求转换过滤器过滤器使html中支持除了get、post，的其他请求put，delete，patch--&gt;&lt;filter&gt; &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt; &lt;!--设置需要过滤的Servlet的名字，就是下面那个servlet--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;/filter-mapping&gt; 6.请求方式controllerMethodDemoController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;/** * 请求方式 */@Controller@RequestMapping("/http")public class MethodDemoController &#123; @RequestMapping(path = "/user", method = RequestMethod.GET) public ModelAndView GET() &#123; System.out.println("GET请求：只能做查询操作"); return null; &#125; @RequestMapping(path = "/user", method = RequestMethod.POST) public ModelAndView POST() &#123; System.out.println("POST请求：添加操作"); return null; &#125; @RequestMapping(path = "/user", method = RequestMethod.DELETE) public ModelAndView DELETE() &#123; System.out.println("DELETE请求：删除操作"); return null; &#125; @RequestMapping(path = "/user", method = RequestMethod.PUT) public ModelAndView PUT() &#123; System.out.println("PUT请求：更新操作[等幂(也就是全部更新)]"); return null; &#125; @RequestMapping(path = "/user", method = RequestMethod.PATCH) public ModelAndView PATCH() &#123; System.out.println("PATCH请求：更新操作[不等幂]"); return null; &#125;&#125; 7.请求方式页面代码request.jsp 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 为了支持其他的请求方式，把method都改为post，然后加入一个 &lt;input type="hidden" name="_method" value="get|post|put|delete|patch"&gt; value不分大小写，name=xxx固定--%&gt; &lt;h2&gt;get请求&lt;/h2&gt; &lt;form action="http/user" method="post"&gt; &lt;button&gt;get请求&lt;/button&gt; &lt;input type="hidden" name="_method" value="get"&gt; &lt;/form&gt; &lt;h2&gt;post请求&lt;/h2&gt; &lt;form action="http/user" method="post"&gt; &lt;button&gt;post请求&lt;/button&gt; &lt;input type="hidden" name="_method" value="post"&gt; &lt;/form&gt; &lt;h2&gt;delete请求&lt;/h2&gt; &lt;form action="http/user" method="post"&gt; &lt;button&gt;delete请求&lt;/button&gt; &lt;input type="hidden" name="_method" value="delete"&gt; &lt;/form&gt; &lt;h2&gt;put请求&lt;/h2&gt; &lt;form action="http/user" method="post"&gt; &lt;button&gt;put请求&lt;/button&gt; &lt;input type="hidden" name="_method" value="put"&gt; &lt;/form&gt; &lt;h2&gt;patch请求&lt;/h2&gt; &lt;form action="http/user" method="post"&gt; &lt;button&gt;patch请求&lt;/button&gt; &lt;input type="hidden" name="_method" value="patch"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMvc学习笔记（一）SpringMvc环境搭建]]></title>
    <url>%2F2018%2F08%2F20%2FSpringMvc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89SpringMvc%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[讲述，springmvc概述，原理，环境的搭建，controller(请求转发/重定向)跳转到页面，controller跳到另外一个controller，配置核心的DispatcherServlet，配置默认的核心配置文件，jsp请求转发的视图解析器。 源码获取github 1.SpringMvc概述SpringMVC 是隶属于Spring框架中的一个模块而已 让控制层更加的简单 SpringMVC是WEB层框架 SpringMVC的概述(官方文档页面搜索the web) Introduction to Spring Web MVC framework The Spring Web model-view-controller (MVC) framework is designed around a DispatcherServlet (翻译：设计围绕着DispatcherServlet，意思是我需要配置一个Servlet)that dispatches requests to handlers, with configurable handler mappings(可以设置一个映射), view resolution, locale, time zone and theme resolution as well as support for uploading files(支持上传文件). The default handler is based on the @Controller and @RequestMapping annotations(默认情况下支持了@Controller和@RequestMapping两个注解),对比我之前学的servlet： 之前的：@WebServlet(“/sys/user”)通过我们设置的映射路径/sys/user会访问到Servlet @Controller 就相当于告知你的这个类为控制器 @RequestMapping是用来设置映射的路径 offering a wide range of flexible handling methods. With the introduction of Spring 3.0, the @Controller mechanism also allows you to create RESTful [百度，这是一个风格，豆瓣就是用的这种风格] Web sites and applications, through the @PathVariable annotation and other features. 所有的请求都要经过前端控制器处理，然后由它决定找到下一个controller是谁，然后这个controller又响应回去DispatcherServlet，视图解析器决定使用哪个模板，最终响应成HTML。 2.程序结构在idea中新建一个javaee项目，其中需要jar包，可以在maven仓库中下载 3.idea配置tomcat添加tomcat 找到你自己的tomcat路径，然后点ok添加好你的tomcat，然后点ok，把你需要部署到tomcat的web服务，添加进去，旁边那个Application context 是你访问这个项目的名字，比如/mvc，访问路径就是localhost:8080/mvc,下面http port是访问的端口号，然后有个是设置打开的浏览器，然后就ok了，最后点运行键，就可以运行 4.配置核心的DispatcherServlet在web.xml中加入 1234567891011121314151617181920&lt;servlet&gt; &lt;!--默认的核心配置文件--&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 服务器启动的时候就对DispatcherServlet进行实例化操作 --&gt; &lt;!-- 值越小，越被越优先实例化 --&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- / 所有的资源访问都需要经过 DispatcherServlet处理 路径 href src..... 区分 /* 和 / --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 5.配置默认的核心配置文件的所在位置和名称 Upon (init初始化)initialization of a DispatcherServlet, Spring MVC looks for a file named *[servlet-name]-servlet.xml*(DispatcherServlet初始化的时候，会找一个这个格式的文件) 在DispatcherServlet中，我们写了这个springmvc，就会找springmvc-servlet.xml这个文件，在WEB-INF下 in the WEB-INF directory of your web application and creates the beans defined there, overriding the definitions of any beans defined with the same name in the global scope. springmvc-servlet.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!--1.启动SpringMvc注解--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.扫描controller--&gt; &lt;!--可以使用通配符 * com.*.web 可以识别：com.hs.web com.sd.web com.sdsa.web 但是不能识别com.hs.sd.web 访问任意一层 com.**.web 可以识别com.web com.hs.web com.sad.asd.asd.web --&gt; &lt;context:component-scan base-package="com.hs.**.web"/&gt;&lt;/beans&gt; 6.Controller文件SkipDemoController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.hs.web;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.view.UrlBasedViewResolver;/** * 跳转专题：请求转发，重定向，一个controller跳到另外一个controller */@Controllerpublic class SkipDemoController &#123; //设置映射的路径 //当我在浏览器中输入 http://127.0.0.1:8080/mvc/hs01 @RequestMapping("/hs01") /*从Controller跳转到jsp_默认是请求转发 请求转发，页面不跳转，可以访问WEB-INF路径下的东西*/ public ModelAndView test01()&#123; ModelAndView nav = new ModelAndView(); nav.setViewName("/WEB-INF/jsp/result01.jsp"); return nav; &#125; /*从Controller跳转到jsp_默认是请求转发 请求转发，页面不跳转，可以访问WEB-INF路径下的东西*/ @RequestMapping("/hs011") public ModelAndView test011()&#123; ModelAndView nav = new ModelAndView(); nav.setViewName("jsp/result01"); //如果设置了jsp请求转发的视图解析器 return nav; &#125; @RequestMapping("/hs02") /*从Controller跳转到jsp_重定向 但是官方不推荐直接重定向到jsp页面 重定向，页面跳转，不可以访问WEB-INF路径下的东西*/ public ModelAndView test02()&#123; ModelAndView nav = new ModelAndView(); nav.setViewName("redirect:/test01.jsp"); return nav; &#125; /**从Controller跳转到Controller_请求转发 * 当配置了JSP的请求转发视图解析器后从Controller跳转到另外一个Controller， * 必须指明前缀：forward/redirect * @return */ @RequestMapping("/hs03") public ModelAndView test03() &#123; ModelAndView nav = new ModelAndView(); nav.setViewName("forward:/hs011"); //这个写forward的原因是，避免jsp请求转发视图解析器，把hs011解析成了jsp页面UrlBasedViewResolver.FORWARD_URL_PREFIX=forward// nav.setViewName("/hs01"); return nav; &#125; /*从Controller跳转到Controller_重定向*/ @RequestMapping("/hs04") public ModelAndView test04() &#123; ModelAndView nav = new ModelAndView(); nav.setViewName(UrlBasedViewResolver.REDIRECT_URL_PREFIX+"/hs01"); //UrlBasedViewResolver.REDIRECT_URL_PREFIX == redirect: return nav; &#125;&#125; 7.视图解析器在springmvc-servlet.xml的&lt;context:component-scan base-package=”com.hs.**.web”/&gt;后面加 12345678910111213 &lt;!--jsp请求转发视图解析器 请求转发jsp页面的时候，在路径上加入前缀和后缀--&gt;&lt;!--下面相当于 InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver()--&gt;&lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--前缀--&gt; &lt;!--相当于setPrefix("/WEB-INF/")--&gt; &lt;property name="prefix" value="/WEB-INF/"/&gt; &lt;!--后缀--&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;!--支持JSTL--&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;&lt;/bean&gt; 8.页面代码result01.jsp 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello word&lt;/body&gt;&lt;/html&gt; test01.jsp 123456789&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;测试&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>SpringMvc学习总结</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>框架</tag>
        <tag>SpringMvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea配置github并上传项目]]></title>
    <url>%2F2018%2F08%2F19%2Fidea%E9%85%8D%E7%BD%AEgithub%E5%B9%B6%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[感觉自己之前写的学习笔记，根本不叫笔记，只是为了把代码放上去而已，然后自己也学习了其他的很多学习博客的写法，写少量的代码进去，再配上相应的文字说明，然后把全部源码放在github上，我觉得我自己也借鉴这样写学习博客，然后今天学习了idea配置github，然后上传项目，自己也百度了许多教程，但是各种都不一样，自己就捅咕了一番，有了属于自己的教程，做个记录吧。 1.什么是git学习教程：廖雪峰的git教程—-https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 2.下载安装git下载链接：https://git-scm.com/ 3.注册一个githubgithub官网：https://github.com/ 4.github创建一个仓库 5.idea配置github 打开自己的项目 在setting里找到git安装的文件，然后点test，出现成功，注意是bin下的git.exe 设置自己的github账号密码， 6.idea上传项目到github 创建本地git仓库，然后选择你要上传的项目在控制台可以看见相应的git指令此时你选择的项目的内容名字全部变色 选择不上传到github的文件或者文件夹，第一个为文件，第二个为文件夹或者在commit的时候选择需要上传的东西或者不上传的东西 commit到本地仓库 这里就是commit选择控制台出现相应的git指令 push到远程仓库github上然后url输入刚才复制的github仓库地址，name是啥我也不知道这里箭头所指的是上床到哪个分支的名字，点击它，可以直接修改分支的名字，然后就push到相应的分支，控制台出现相应的git指令 push成功 github页面上显示 7.如果代码修改了再提交重复上面的第3步开始， 然后github页面就是这样的 8.关闭这个项目的版本控制 9.自己在网上看的一些不错教程 https://www.cnblogs.com/jinjiyese153/p/6796668.html https://www.cnblogs.com/jinjiyese153/p/6796668.html https://my.oschina.net/u/2608182/blog/745178]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（七）遇见的坑]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E9%81%87%E8%A7%81%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[在学习过程中，遇见数据库中中文乱码，mybatis常见的异常和如何调试，idea不知道如何创建xml文件，idea中project和module的关系，如何把一个module复制成另外一个module，每次一个新的mybatis项目，有很多地方记得要修改 源码获取github 1.解决数据库中文乱码问题 方法一(推荐)：把数据库的配置文件编码设置成UTF-8或utf8mb4，两者区别就是UTF-8最大三字节，后者最大四字节 操作： 之前自己在网上找了一些教程说在mysql的安装目录下一个配置文件里修改，结果自己找了半天了，都没有找到，然后用everything搜索，找到了配置文件，结果不是安装目录下…… 找到如下文件，如果没有找到，用everything搜索 在最后添加下面代码 若要设置成utf-8，把utf8mb4修改成utf-8即可 123456789[client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect=&apos;SET NAMES utf8mb4&apos; 保存文件，重启mysql服务 方法二：在每次连接数据库的url最后面加入 1?useUnicode=true&amp;characterEncoding=UTF-8 2.mybatis常见的异常 控制台或者其他位置报MyBatisUtils工具类的异常 95%以上：是映射文件你写错了 5%：是核心配置文件写错了 因为mybatis-config.xml是入口，会加载很多的映射文件，把他们融合在一起，如果其中有任何一个映射文件出错，所有的定制的SQL语句都将无法运行 如何调试？ 把自己的，，，这一行代码注释掉，然后再运行看控制台，错误从下往上看，Caused byxx 3.idea如何创建xml文件 1&lt;?xml version="1.0" encoding="UTF-8"?&gt; 4.idea中project和module的关系之前刚用idea，以为一个project，就是一个项目，结果并不是 5.如何把一个module复制成另外一个module直接像eclipse那样复制一个module，图标只会这样： 这不是一个module，要让他变成module，如下操作： 6.一个新的mybatis项目重点一些地方需要修改或者添加 核心配置文件的映射文件里 日志框架里写上你的命名空间 到此，目前的MyBatis小结到此结束，下一个学习SpringMvc，只希望自己能坚持下去，世界诱惑很多，只希望自己能一路走下去，加油！！！]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（六）一对多的关联查询和传递多个参数]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%92%8C%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[本文讲解一对多的关联查询，传递多个参数。 源码获取github 1.传递多个参数 当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 #{值}，默认为arg0，arg1…..或param1，param2，，， 若在接口中注解了@Param(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值 2.结构 3.数据库属性文件同之前 4.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;mapper resource="com/hs/model/RoleMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 5.持久化类Role.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.hs.model;import java.util.List;public class Role &#123; private Integer role_id; private String role_name; private String role_key; private Integer status; //关联对象,一对多，一个角色可以有多个用户 private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; public Integer getRole_id() &#123; return role_id; &#125; public void setRole_id(Integer role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_key() &#123; return role_key; &#125; public void setRole_key(String role_key) &#123; this.role_key = role_key; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_id=" + role_id + ", role_name='" + role_name + '\'' + ", role_key='" + role_key + '\'' + ", status=" + status + ", userList=" + userList + '&#125;'; &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.model;import java.util.Date;public class User &#123; private Integer user_id; private String account; private String password; private String user_name; private Integer status; private Date login_time; private String ip; private Integer fk_role_id; //关联对象 一对一或多对一 private Role role; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getLogin_time() &#123; return login_time; &#125; public void setLogin_time(Date login_time) &#123; this.login_time = login_time; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public Integer getFk_role_id() &#123; return fk_role_id; &#125; public void setFk_role_id(Integer fk_role_id) &#123; this.fk_role_id = fk_role_id; &#125; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", account='" + account + '\'' + ", password='" + password + '\'' + ", user_name='" + user_name + '\'' + ", status=" + status + ", login_time=" + login_time + ", ip='" + ip + '\'' + ", fk_role_id=" + fk_role_id + ", role=" + role + '&#125;'; &#125;&#125; 6.XML映射文件RoleMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.RoleDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;resultMap type="Role" id="BaseResultMapper"&gt; &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_role_columns"&gt; role_id,role_name,role_key,status &lt;/sql&gt; &lt;sql id="sys_role_columns_alias"&gt; $&#123;alias&#125;.role_id,$&#123;alias&#125;.role_name,$&#123;alias&#125;.role_key,$&#123;alias&#125;.status &lt;/sql&gt; &lt;resultMap id="SimpleResultMapper" type="Role" extends="BaseResultMapper"&gt; &lt;!--配置集合List&lt;User&gt;,javaType一般可以不写--&gt; &lt;!--在结果集中找到role_id这个字段，然后传给命名空间com.hs.dao.UserDao下id为getUserByFk的语句， 返回的结果集字段为userList，类型为java.util.List，里面装的类型是com.he.model.User这个类型 --&gt; &lt;collection property="userList" javaType="java.util.List" ofType="User" column="role_id" select="com.hs.dao.UserDao.getUserByFk"/&gt; &lt;/resultMap&gt; &lt;select id="getRoleByPk" parameterType="_int" resultMap="SimpleResultMapper"&gt; select &lt;include refid="sys_role_columns"/&gt; from sys_role where role_id = #&#123;role_id&#125; &lt;/select&gt; &lt;resultMap id="JoinResultMapper" type="Role" extends="BaseResultMapper"&gt; &lt;!--配置集合，查询出来的User里的结果集找com.hs.dao.UserDao.BaseResultMapper处理--&gt; &lt;collection property="userList" javaType="list" ofType="com.hs.model.User" resultMap="com.hs.dao.UserDao.BaseResultMapper"/&gt; &lt;!--&lt;id/&gt; &lt;result/&gt;--&gt; &lt;/resultMap&gt; &lt;select id="getRoleByLeftJoin" parameterType="_int" resultMap="JoinResultMapper"&gt; SELECT &lt;include refid="com.hs.dao.UserDao.sys_user_colums_alias"&gt; &lt;property name="alias" value="su"/&gt; &lt;/include&gt; , &lt;include refid="sys_role_columns_alias"&gt; &lt;property name="alias" value="sr"/&gt; &lt;/include&gt; FROM sys_role sr LEFT JOIN sys_user su ON sr.role_id = su.fk_role_id WHERE sr.role_id =#&#123;role_id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap id="BaseResultMapper" type="User"&gt; &lt;id column="user_id" property="user_id" /&gt; &lt;result column="account" property="account" /&gt; &lt;result column="passwrod" property="pasword" /&gt; &lt;result column="user_name" property="user_name" /&gt; &lt;result column="status" property="status" /&gt; &lt;result column="login_time" property="login_time" /&gt; &lt;result column="ip" property="ip" /&gt; &lt;result column="fk_role_id" property="fk_role_id" /&gt; &lt;/resultMap&gt; &lt;resultMap id="SimpleResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!-- extends继承了BaseResultMapper，同java继承一样 --&gt; &lt;!--关联对象--&gt; &lt;!--在结果集中找到fk_role_id字段，然后再传值给命名空间com.hs.dao.RoleDao下的getRoleByPk语句进行查询(找到要执行的SQL语句)，最后返回role，它的类型是com.hs.model.Role--&gt; &lt;association property="role" javaType="Role" column="fk_role_id" select="com.hs.dao.RoleDao.getRoleByPk"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_user_colums"&gt; user_id,account,password,user_name,status,login_time,ip,fk_role_id &lt;/sql&gt; &lt;sql id="sys_user_colums_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.account,$&#123;alias&#125;.password,$&#123;alias&#125;.user_name,$&#123;alias&#125;.status,$&#123;alias&#125;.login_time,$&#123;alias&#125;.ip,$&#123;alias&#125;.fk_role_id &lt;/sql&gt; &lt;select id="getUserByFk" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where fk_role_id = #&#123;role_id&#125; &lt;/select&gt; &lt;!--1.当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 2.#&#123;值&#125;，默认为arg0，arg1.....或param1，param2，，， 若在dao注解了@xxx(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值--&gt; &lt;select id="getUser" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where account=#&#123;account&#125; and password=#&#123;password&#125; &lt;/select&gt;&lt;/mapper&gt; 7.接口RoleDao.java 12345678910111213141516171819202122package com.hs.dao;import com.hs.model.Role;public interface RoleDao &#123; /** * select方式，先在role表查出主键，然后传给user表当做条件，查询出user的信息 * * @param role_id * @return */ Role getRoleByPk(int role_id); /** * 利用连接查询方式，查询结果集 * * @param role_id * @return */ Role getRoleByLeftJoin(int role_id);&#125; UserDao.java 123456789101112131415package com.hs.dao;import com.hs.model.User;import org.apache.ibatis.annotations.Param;public interface UserDao &#123; /** * 传递多个参数 * 1.当你的形参传递&gt;1个的时候，parameterType不写，让其自动处理 * 2.#&#123;值&#125;，默认为arg0，arg1.....或param1，param2，，， * 若在dao注解了@xxx(相当于指明了key值)，即也可以写xxx，默认的也可以写，相当于3个值 */ User getUser(@Param("account") String account, @Param("password") String password);&#125; 8.日志配置文件mybatis-config.xml 12345678910# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.UserDao=TRACElog4j.logger.com.hs.dao.RoleDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 9.测试类MyBatisTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hs.test;import com.hs.dao.RoleDao;import com.hs.dao.UserDao;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 利用select方式， */ @Test public void getUserByPk()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); RoleDao roleDao = sqlSession.getMapper(RoleDao.class); System.out.println(roleDao.getRoleByPk(-100)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 利用连接方式查询 */ @Test public void getUserByFk()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); RoleDao roleDao = sqlSession.getMapper(RoleDao.class); System.out.println(roleDao.getRoleByLeftJoin(-100)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递多个参数 */ @Test public void getUser()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); String account = "admin"; String password = "admin"; System.out.println(userDao.getUser(account,password)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（五）一对一或多对一的关联查询]]></title>
    <url>%2F2018%2F08%2F06%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E4%B8%80%E5%AF%B9%E4%B8%80%E6%88%96%E5%A4%9A%E5%AF%B9%E4%B8%80%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[本文讲解，mybatis中一对一、多对一的关联查询，类名的别名方式应用 源码获取github 1.关系型数据库中表和表之间的关系 一对一：外键唯一 一对多和多对一：只是站在角度不同而已，但是外键一定在多方 自身一对多和多对一 外键： 逻辑关联 物理关联 多对多：一定是通过中间表维护 2.java类中如何表示上述几种关系UML：依赖/关联/组合 eg：用户和角色的关系 一个用户对应一个角色，一个角色可以多个用户 用户ID 用户 角色ID 100 悟空 999 200 八戒 999 查询100的用户信息，那么它一定对 一个角色信息 List 1234public class User&#123;//关联对象 public Role role;//一对一,多对一 &#125; 123public class Role&#123; private List&lt;User&gt; userList; //一个角色里可以对应很多用户&#125; 3.三种方式 传统模式：两个SQL语句，先在一个表查出数据，然后把其中的id作为另外一个表的where，再查数据 select方式：在映射文件中，一个查出的结果集中，调用另外一个select语句实现查询 连接查询：也就是SQL语句连接查询(个人还是喜欢这种) 4.知识小点 配置关联对象用&lt;association&gt;这样查出来的就是一个对象 配置集合就用&lt;collection&gt; 5.目录结构 6.数据库属性文件jdbc.properties 1代码同上篇 7.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;mapper resource="com/hs/model/RoleMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 8.封装好的工具类MyBatisUtils.java 1同上篇 9.持久化类Role.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hs.model;public class Role &#123; private Integer role_id; private String role_name; private String role_key; private Integer status; public Integer getRole_id() &#123; return role_id; &#125; public void setRole_id(Integer role_id) &#123; this.role_id = role_id; &#125; public String getRole_name() &#123; return role_name; &#125; public void setRole_name(String role_name) &#123; this.role_name = role_name; &#125; public String getRole_key() &#123; return role_key; &#125; public void setRole_key(String role_key) &#123; this.role_key = role_key; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; @Override public String toString() &#123; return "Role&#123;" + "role_id=" + role_id + ", role_name='" + role_name + '\'' + ", role_key='" + role_key + '\'' + ", status=" + status + '&#125;'; &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.model;import java.util.Date;public class User &#123; private Integer user_id; private String account; private String password; private String user_name; private Integer status; private Date login_time; private String ip; private Integer fk_role_id; //关联对象 一对一或多对一，一个用户对应一个角色 private Role role; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getAccount() &#123; return account; &#125; public void setAccount(String account) &#123; this.account = account; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public Date getLogin_time() &#123; return login_time; &#125; public void setLogin_time(Date login_time) &#123; this.login_time = login_time; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public Integer getFk_role_id() &#123; return fk_role_id; &#125; public void setFk_role_id(Integer fk_role_id) &#123; this.fk_role_id = fk_role_id; &#125; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", account='" + account + '\'' + ", password='" + password + '\'' + ", user_name='" + user_name + '\'' + ", status=" + status + ", login_time=" + login_time + ", ip='" + ip + '\'' + ", fk_role_id=" + fk_role_id + ", role=" + role + '&#125;'; &#125;&#125; 10.XML映射文件RoleMapper.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.RoleDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的类名别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap type="Role" id="BaseResultMapper"&gt; &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; &lt;/resultMap&gt; &lt;sql id="sys_role_columns"&gt; role_id,role_name,role_key,status &lt;/sql&gt; &lt;sql id="sys_role_columns_alias"&gt; $&#123;alias&#125;.role_id,$&#123;alias&#125;.role_name,$&#123;alias&#125;.role_key,$&#123;alias&#125;.status &lt;/sql&gt; &lt;select id="getRoleByPk" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_role_columns"/&gt; from sys_role where role_id = #&#123;role_id&#125; &lt;/select&gt;&lt;/mapper&gt; UserMapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--type直接用的类名别名方式，在核心配置文件里设置了的--&gt; &lt;resultMap id="BaseResultMapper" type="User"&gt; &lt;id column="user_id" property="user_id" /&gt; &lt;result column="account" property="account" /&gt; &lt;result column="passwrod" property="pasword" /&gt; &lt;result column="user_name" property="user_name" /&gt; &lt;result column="status" property="status" /&gt; &lt;result column="login_time" property="login_time" /&gt; &lt;result column="ip" property="ip" /&gt; &lt;result column="fk_role_id" property="fk_role_id" /&gt; &lt;/resultMap&gt; &lt;resultMap id="SimpleResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!-- extends继承了BaseResultMapper，同java继承一样 --&gt; &lt;!--配置关联对象--&gt; &lt;!--在结果集中找到fk_role_id字段，然后再传值给命名空间com.hs.dao.RoleDao下的getRoleByPk语句进行查询(找到要执行的SQL语句)，最后返回role(对象的属性)，它的类型是com.hs.model.Role--&gt; &lt;association property="role" javaType="Role" column="fk_role_id" select="com.hs.dao.RoleDao.getRoleByPk"/&gt; &lt;collection property="" &lt;/resultMap&gt; &lt;sql id="sys_user_colums"&gt; user_id,account,password,user_name,status,login_time,ip,fk_role_id &lt;/sql&gt; &lt;sql id="sys_user_colums_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.account,$&#123;alias&#125;.password,$&#123;alias&#125;.user_name,$&#123;alias&#125;.status,$&#123;alias&#125;.login_time,$&#123;alias&#125;.ip,$&#123;alias&#125;.fk_role_id &lt;/sql&gt; &lt;select id="getUserByPk01" parameterType="_int" resultMap="BaseResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where user_id = #&#123;user_id&#125; &lt;/select&gt; &lt;select id="getUserByPk02" parameterType="_int" resultMap="SimpleResultMapper"&gt; select &lt;include refid="sys_user_colums"/&gt; from sys_user where user_id = #&#123;user_id&#125; &lt;/select&gt; &lt;resultMap id="JoinResultMapper" type="User" extends="BaseResultMapper"&gt; &lt;!--关联对象--&gt; &lt;!--resultMap引用别人的结果集(命名空间+"."+id)，或者自己在下面写结果集处理--&gt; &lt;association property="role" javaType="Role" resultMap="com.hs.dao.RoleDao.BaseResultMapper"&gt; &lt;!-- &lt;id column="role_id" property="role_id"/&gt; &lt;result column="role_name" property="role_name"/&gt; &lt;result column="role_key" property="role_key"/&gt; &lt;result column="status" property="status"/&gt; --&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="getUserByLeftJoin" parameterType="_int" resultMap="JoinResultMapper"&gt; select &lt;!-- 调用别名式的SQL代码，给alias赋值为u --&gt; &lt;include refid="sys_user_colums_alias"&gt; &lt;property name="alias" value="u"/&gt; &lt;/include&gt; , &lt;include refid="com.hs.dao.RoleDao.sys_role_columns_alias"&gt; &lt;property name="alias" value="r"/&gt; &lt;/include&gt; from sys_user u left join sys_role r on u.fk_role_id = r.role_id where u.user_id = #&#123;user_id&#125; &lt;/select&gt;&lt;/mapper&gt; 11.接口UserDao.java 123456789101112131415161718192021222324252627package com.hs.dao;import com.hs.model.User;public interface UserDao &#123; /** * 通过id查询user表的所有信息，再用它的外键传递给另外一个表进行查询数据 * @param user_id * @return */ User getUserByPk01(int user_id); /** * 用关联对象方式、select方式代取传统的模式 * @param user_id * @return */ User getUserByPk02(int user_id); /** * 在SQL语句写连接方式的查询 * @param user_id * @return */ User getUserByLeftJoin(int user_id);&#125; RoleDao.java 1234567891011121314package com.hs.dao;import com.hs.model.Role;public interface RoleDao &#123; /** * 通过role_id查询role表信息 * @param role_id * @return */ Role getRoleByPk(int role_id);&#125; 12.测试类MyBatisTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.hs.test;import com.hs.dao.RoleDao;import com.hs.dao.UserDao;import com.hs.model.Role;import com.hs.model.User;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 一对一的三种方式 */ /** * 方式一：利用两个SQL语句，先在user查出外键，然后再在role表进行查询 */ @Test public void getAllByFk01()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByPk01(-999);// 获取对应的外键信息 if (user.getFk_role_id()!=null) &#123; RoleDao roleDao = sqlSession.getMapper(RoleDao.class); Role role = roleDao.getRoleByPk(user.getFk_role_id()); //建立关系 user.setRole(role); &#125; System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 用关联对象方式、select方式代取传统的模式 */ @Test public void getAllBySelect()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByPk02(-999); System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * SQL语句连接方式查询 */ @Test public void getUserByLeftJoin()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = userDao.getUserByLeftJoin(-999); System.out.println(user); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（四）动态SQL语句专题]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E5%8A%A8%E6%80%81SQL%E8%AF%AD%E5%8F%A5%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文讲解动态的SQL操作，CRUD中，CUD都需要自己手动提交事务，动态的添加语句，批量删除的三种处理方式，提取公共的sql代码，if标签，where标签，trim标签，set标签，choose标签，foreach标签，批量添加 源码获取github 1.trim标签12345&lt;trim prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容"&gt; &lt;/trim&gt; 2.set标签当你发现有内容的时候,在内容的最前面加入 set 当你放下有内容的时候,检查内容的最后面是否有逗号”,” 如果将其抹掉 3.where标签 如果发现标签內有内容,那么会在内容的最前面加入关键字 where 如果有内容,会检查内容的最前面是否含有 AND空格 或者 OR空格 ,自动将其抹掉 4.foreach标签 如果只传了一个数组或者一个集合 collection=”array 或者 list” 如果传的是一个Map里装了list 就写map的key，如果是对象里setList，就写对象的list属性,这个属性就对应一个集合 item相当于，他的遍历的一个值，open=”开始加入” close=”最后加入” separator=”以什么间隔”–&gt; 4.choose标签类似java中的switch5.代码结构 6.数据库配置文件同前几天笔记 7.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/UserMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 8.持久化类User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.hs.model;import java.util.Date;public class User &#123; /*本字段名字跟数据库的字段一样*/ private Integer user_id; private String user_name; private String sex; private Double money; private Date birthday; public Integer getUser_id() &#123; return user_id; &#125; public void setUser_id(Integer user_id) &#123; this.user_id = user_id; &#125; public String getUser_name() &#123; return user_name; &#125; public void setUser_name(String user_name) &#123; this.user_name = user_name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "user_id=" + user_id + ", user_name='" + user_name + '\'' + ", sex='" + sex + '\'' + ", money=" + money + ", birthday=" + birthday + '&#125;'; &#125;&#125; 9.映射文件UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.UserDao"&gt;&lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径r--&gt; &lt;!--见帮助文档http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html--&gt; &lt;resultMap id="BaseResultMap" type="com.hs.model.User"&gt; &lt;id column="user_id" property="user_id"/&gt; &lt;result column="user_name" property="user_name"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="money" property="money"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;/resultMap&gt; &lt;!--提取公共的SQL代码--&gt; &lt;sql id="oa_user_columns"&gt; user_id,user_name,sex,money,birthday &lt;/sql&gt; &lt;!--别名方式的SQL代码--&gt; &lt;sql id="oa_user_columns_alias"&gt; $&#123;alias&#125;.user_id,$&#123;alias&#125;.user_name,$&#123;alias&#125;.sex,$&#123;alias&#125;.money,$&#123;alias&#125;.birthday &lt;/sql&gt; &lt;!-- A.通过恒等式完成动态SQL语句 --&gt; &lt;select id="getUserListIf01" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user where 1=1 &lt;!-- 恒等式 ，但是影响效率--&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/select&gt; &lt;!-- B.通过where标签完成动态SQL语句，没有1=1 --&gt; &lt;select id="getUserListIf02" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user &lt;where&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- C.trim标签实现&lt;trim prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容" --&gt; &lt;select id="getUserListIf03" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user &lt;trim prefix="where " prefixOverrides="and || or"&gt; &lt;if test="name != null &amp;amp;&amp;amp; name != ''"&gt; and user_name like concat('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;!-- 见xml转义字符 这个if里没有&amp;&amp;,只有&amp;amp;&amp;amp;或者and表示，||也只有or表示--&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!--利用set标签 当你发现有内容的时候,在内容的最前面加入 set 当你发现有内容的时候,检查内容的最后面是否有逗号"," 如果有将其抹掉 --&gt; &lt;update id="updateUser01ByPk" parameterType="com.hs.model.User"&gt; update oa_user &lt;set&gt; &lt;if test="user_name !=null and user_name != ''"&gt; user_name = #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex != ''"&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money != null"&gt; &lt;!--不是字符串就不要判断是否为空 ='' --&gt; money = #&#123;money&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;user_id&#125; &lt;/update&gt; &lt;!--利用trim标签，，，，但是不推荐 --&gt; &lt;update id="updateUser02ByPk" parameterType="com.hs.model.User"&gt; update oa_user &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name != ''"&gt; user_name = #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex != ''"&gt; sex = #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money != null"&gt; &lt;!--不是字符串就不要判断是否为空 ='' --&gt; money = #&#123;money&#125;, &lt;/if&gt; &lt;/trim&gt; where user_id = #&#123;user_id&#125; &lt;/update&gt; &lt;!--利用choose标签，类似switch--&gt; &lt;select id="getSkillByChoose" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="oa_user_columns"/&gt; from oa_user where &lt;choose&gt;&lt;!--注意单双引号,when里test='' --&gt; &lt;when test='sex!=null and sex=="男"'&gt; money &gt; 700 &lt;/when&gt; &lt;!--&lt;when test='sex!=null and sex=="女"'&gt; money &amp;lt;= 700 &amp;lt;!&amp;ndash;见xml转义字符 小于号(因为小于号&lt;是标签的开头)的解决问题，或者这样写 &amp;ndash;&amp;gt; &lt;/when&gt;--&gt; &lt;when test='sex!=null and sex="女"'&gt; &lt;![CDATA[ money &lt;= 700 ]]&gt; &lt;/when&gt; &lt;!--里面不能包含标签，把&lt;，不当做标签的开头 --&gt; &lt;otherwise&gt; &lt;!--switch中的default--&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; &lt;!--后面两个属性，前者可以不用写，后者是使用该属性，接收这个新添加的数据的主键--&gt; &lt;insert id="addSkill01" parameterType="com.hs.model.User" useGeneratedKeys="true" keyProperty="user_id"&gt; insert into oa_user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name!=''"&gt; user_name, &lt;/if&gt; &lt;if test="sex !=null and sex!=''"&gt; sex, &lt;/if&gt; &lt;if test="money !=null"&gt; money, &lt;/if&gt; &lt;if test="birthday !=null"&gt; birthday, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values(" suffix=")" suffixOverrides=","&gt; &lt;if test="user_name !=null and user_name!=''"&gt; #&#123;user_name&#125;, &lt;/if&gt; &lt;if test="sex !=null and sex!=''"&gt; #&#123;sex&#125;, &lt;/if&gt; &lt;if test="money !=null"&gt; #&#123;money&#125;, &lt;/if&gt; &lt;if test="birthday !=null"&gt; #&#123;birthday&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;!--数组删除，如果数组的话，请不要去设置parameterType,让其自动识别 --&gt; &lt;delete id="deleteSkillByArray" &gt; delete from oa_user where user_id in &lt;!--对数组进行遍历， 如果只传了一个数组或者一个集合 collection="array 或者 list 如果传的是一个Map里装了list 就写map的key，如果是对象里setList，就写对象的list属性,这个属性就对应一个集合 item相当于，他的遍历的一个值，open="开始加入" close="最后加入" separator="以什么间隔"--&gt; &lt;foreach collection="array" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!--List集合删除 --&gt; &lt;delete id="deleteSkillByList" parameterType="list"&gt; delete from oa_user where user_id in &lt;foreach collection="list" item="id" open="(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;delete id="deleteSkillByMap" parameterType="map"&gt; delete from oa_user where user_id in &lt;foreach collection="id_array" item="id" open="(" close=")" separator=","&gt; &lt;!-- 等于遍历，id_array对应一个list，item就是这个list里的值 --&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!--批量添加--&gt; &lt;insert id="addSkillByAll" parameterType="list"&gt; insert into oa_user(user_name,sex,money) values &lt;foreach collection="list" item="user" separator=","&gt; (#&#123;user.user_name&#125;,#&#123;user.sex&#125;,#&#123;user.money&#125;) &lt;/foreach&gt; &lt;/insert&gt;&lt;/mapper&gt; 10.封装好的工具类同之前的笔记 11.接口UserDao.java 12345678910111213141516171819202122232425262728293031package com.hs.dao;import com.hs.model.User;import java.util.List;import java.util.Map;public interface UserDao &#123; List&lt;User&gt; getUserListIf01(Map&lt;String, Object&gt; map); List&lt;User&gt; getUserListIf02(Map&lt;String, Object&gt; map); List&lt;User&gt; getUserListIf03(Map&lt;String, Object&gt; map); int updateUser01ByPk(User user); int updateUser02ByPk(User user); List&lt;User&gt; getSkillByChoose(Map&lt;String, Object&gt; map); int addSkill01(User user); int deleteSkillByArray(int[] array); int deleteSkillByList(List&lt;Integer&gt; list); int deleteSkillByMap(Map&lt;String, Object&gt; map); int addSkillByAll(List&lt;User&gt; list);&#125; 12.日志框架配置log4j.properties.xml 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.UserDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 13.测试类MyBatisTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package com.hs.test;import com.hs.dao.UserDao;import com.hs.model.User;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * if标签，进行两个姓名和性别的条件查询，通过恒等式完成动态SQL语句 */ @Test public void getUserListIf01() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf01(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * if标签，进行两个姓名和性别的条件查询，通过where标签（推荐！！！）： * 如果发现标签內有内容,那么会在内容的最前面加入关键字 where * 如果有内容,会检查内容的最前面是否含有 AND空格 或者 OR空格 ,自动将其抹 */ @Test public void getUserListIf02() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf02(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * if标签，进行两个姓名和性别的条件查询，通过trim标签： * &lt;trim * prefix="当发现有内容的时候,你在内容的最前面想加入什么内容" * prefixOverrides="当发现有内容的时候,你在内容的最前面想抹掉什么内容" * suffix="当发现有内容的时候,你在内容的最后面面想加入什么内容" * suffixOverrides="当发现有内容的时候,你在内容的最后面想抹掉什么内容" * &gt; &lt;/trim&gt; */ @Test public void getUserListIf03() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "悟"); map.put("sex", "男"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getUserListIf03(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 更新操作—变更数据库 * 利用set标签 * 当你发现有内容的时候,在内容的最前面加入 set * 当你发现有内容的时候,检查内容的最后面是否有逗号"," 如果有将其抹掉 */ @Test public void updateUser01ByPk() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); //数据 User user = new User(); user.setUser_id(3); user.setUser_name("天蓬元帅"); //日期的转换 String date = "2018-8-3"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.updateUser01ByPk(user)); //重点！！！，CRUD中，除了R（查询），不用提交事务，其余全的自己提交事务，传统和接口模式提交事务都是一样的 sqlSession.commit(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 更新操作—变更数据库 * 利用trim标签 * * @throws ParseException */ @Test public void updateUser02ByPk() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); //数据 User user = new User(); user.setUser_id(3); user.setUser_name("天蓬元帅"); user.setMoney(1000.0); //日期的转换 String date = "2018-8-3"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.updateUser02ByPk(user)); //重点！！！，CRUD中，除了R（查询），不用提交事务，其余全的自己提交事务，传统和接口模式提交事务都是一样的 sqlSession.commit(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 查询通过choose标签 * 解决小于号的问题 */ @Test public void getSkillByChoose() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("sex", "女"); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.getSkillByChoose(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 添加一个数据，然后返回这个数据自增长的主键信息 */ @Test public void addSkill01() throws ParseException &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); User user = new User(); user.setUser_name("沙僧"); user.setSex("男"); user.setMoney(455.0); String date = "2018-8-5"; DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); user.setBirthday(dateFormat.parse(date)); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println("影响行数"+userDao.addSkill01(user)); sqlSession.commit(); System.out.println("user_id:"+user.getUser_id()); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递传递数组删除规则 */ @Test public void deleteSkillByArray()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByArray(new int[]&#123;6,8&#125;)); //静态初始化 //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递List集合删除规则 */ @Test public void deleteSkillByList()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(9); list.add(11); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByList(list)); //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 传递Map里装list删除规则 */ @Test public void deleteSkillByMap()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(8); list.add(10); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("id_array",list); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.deleteSkillByMap(map)); //事务的手动提交 sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 通过list里装User实现批量添加 */ @Test public void addSkillByAll()&#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); User user1 = new User(); user1.setUser_name("嫦娥"); user1.setSex("女"); user1.setMoney(1213.0); User user2 = new User(); user2.setUser_name("月兔"); user2.setSex("女"); user2.setMoney(2113.0); list.add(user1); list.add(user2); UserDao userDao = sqlSession.getMapper(UserDao.class); System.out.println(userDao.addSkillByAll(list)); sqlSession.commit(); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三）模糊查询专题]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文讲解，用接口代理模式实现mybatis的模糊查询，讲解#{}和${}两个的区别，XML文件中五个特殊字符串不允许使用，小于号的解决问题。 源码获取github 1.关于接口代理模式和传统模式的区别 传统模式：在笔记（二）就是采用的这个模式： 需要写接口，接口实现类，测试类， 映射文件命名空间为持久化类的全路径 接口代理模式：本笔记之后所有采用这个模式： 只需要写接口，在测试类中调用，接口编程: 什么是接口? 简单理解:接口就是定义规范 接口返回类型跟你设置的resultMap或者resultType对应上即可,但是会根据你返回的类型完成selectone或者selectList操作 接口里方法如何写：sql语句返回的结果集类型 sql语句的id(要传的值); eg:List getSkillLike02(String name); List为SQL语句返回的结果集类型，getSkillLike02为映射文件中SQL语句的id，String name是传给映射文件的值 映射文件命名空间为接口的全路径 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是List，如果是List，也是List 2.MyBatis框架中获取数据的形式有两种方案 #{}和${}的区别? #{} 取值： 方案一： 如果你是一个简单的数据类型,那么我们使用#{任意标识符} 方案二: 对象或者Map #{属性或者KEY} 如果使用#{}那么它的模式方式为预处理模式 ${} 你需要必须指明KEY或者属性 对数据不会进行转义 直接拼接到SQL语句上 3.XML文件中有五个特殊字符串不允许使用 方法一：用了转义字符把&gt;和&lt;替换掉，然后就没有问题了。 附:XML转义字符 方法二： 因为这个是xml格式的，所以不允许出现类似“&gt;”这样的字符，但是都可以使用&lt;![CDATA[ 内容 ]]&gt;符号进行说明，将此类符号不进行解析 4.代码结构 5.数据库属性文件jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mssjdbc.mysql.username=rootjdbc.mysql.password=root 6.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 7.接口代码SkillDao.java 12345678910111213141516171819202122232425package com.hs.dao;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */import com.hs.model.Skill;import java.util.List;import java.util.Map;public interface SkillDao &#123; List&lt;Skill&gt; getSkillLike01(); List&lt;Skill&gt; getSkillLike02(String name); List&lt;Skill&gt; getSkillLike03(String name); List&lt;Skill&gt; getSkillLike04(Map&lt;String,Object&gt; map); List&lt;Skill&gt; getSkillLike05(Map&lt;String,Object&gt; map);&#125; 8.持久化类Skill.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.hs.model;public class Skill &#123; private Integer skillid; private String skillname; private Integer num; public Integer getSkillid() &#123; return skillid; &#125; public void setSkillid(Integer skillid) &#123; this.skillid = skillid; &#125; public String getSkillname() &#123; return skillname; &#125; public void setSkillname(String skillname) &#123; this.skillname = skillname; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public String toString() &#123; return "Skill&#123;" + "skillid=" + skillid + ", skillname='" + skillname + '\'' + ", num=" + num + '&#125;'; &#125;&#125; 9.映射文件SkillMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.dao.SkillDao"&gt; &lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径--&gt; &lt;resultMap id="BaseResultMap" type="com.hs.model.Skill"&gt; &lt;id column="skill_id" property="skillid"/&gt; &lt;!--若有主键，主键用id标签，其余用result标签--&gt; &lt;result column="skill_name" property="skillname"/&gt; &lt;result column="num" property="num"/&gt; &lt;/resultMap&gt; &lt;!--1.模糊条件查询是固定的，写死在sql语句里了--&gt; &lt;select id="getSkillLike01" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like '%s%' &lt;/select&gt; &lt;!--2.模糊条件是一个简单的数据类型 当你传递的为一个简单的数据类型，那么我们可以通过#&#123;任意写&#125;进行传值， #&#123;xx&#125;是一种预处理模式，先sql语句里是？ 然后接收到值了，再写进去,会给你默认加 '',即为'#&#123;&#125;' --&gt; &lt;!--A、通过java代码拼接字符串--&gt; &lt;select id="getSkillLike02" parameterType="string" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like #&#123;name&#125; &lt;/select&gt; &lt;!--B、通过SQL语句函数拼接字符串 concat函数指字符串拼接，--&gt; &lt;select id="getSkillLike03" parameterType="string" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like concat('%',#&#123;name&#125;,'%') &lt;/select&gt; &lt;!--C、通过$&#123;&#125;完成模糊查询！！！但是不太推荐，$&#123;&#125;不会默认加 '' ，也不是预处理模式，是直接在把值写在了sql语句中， 一般用于order by $&#123;key或者属性&#125;,一般只接受map或者对象 --&gt; &lt;select id="getSkillLike04" parameterType="map" resultMap="BaseResultMap"&gt; select skill_id,skill_name,num from skill where skill_name like concat('%','$&#123;name&#125;','%') &lt;/select&gt; &lt;!--$&#123;&#125;的应用，排序--&gt; &lt;select id="getSkillLike05" parameterType="map" resultMap="BaseResultMap"&gt; select * from skill order by skill_id $&#123;fs&#125; &lt;/select&gt;&lt;/mapper&gt; 10.封装好的工具类MyBatis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; inputStream = Resources.getResourceAsStream(PATH); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; public static SqlSession getSqlsession() &#123; return sqlSessionFactory.openSession(); &#125; public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 11.日志框架配置log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.dao.SkillDao=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 12.测试类MyBatis.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.hs.test;import com.hs.dao.SkillDao;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.HashMap;import java.util.Map;/** * 接口代理模式实现操作，在xxDao接口中，定义方法： sql语句返回的结果类型 sql语句的id(要传的值); * 不用写实现类，直接写测试类,具体实现见测试类 * sql的映射文件的命名空间跟接口的全路径一致 * 可以根据接口的返回类型自动判断使用selectOne还是selectList eg:返回的是一个对象的为one，返回的是list的就是list，如果是List&lt;Bean&gt;，也是list */public class MyBatisTest &#123; /** * 1.模糊条件查询是固定的，写死在sql语句里了 */ @Test public void getSkillLike01() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession();// 根据xml映射文件，接口创建实现类代理 有点类似传统模式的new UserMapperImpl() SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike01()); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 2.通过java代码拼接字符串进行模糊查询 */ @Test public void getSkillLike02() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); String name = "%a%"; SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike02(name)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 3.通过sql语句函数拼接字符串进行模糊查询 */ @Test public void getSkillLike03() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); String name = "s"; SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike03(name)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 4.通过$&#123;&#125;拼接字符串进行模糊查询 */ @Test public void getSkillLike04() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("name", "s"); SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike04(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; /** * 4.通过$&#123;&#125;进行排序操作 */ @Test public void getSkillLike05() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("fs", "DESC"); SkillDao skillDao = sqlSession.getMapper(SkillDao.class); System.out.println(skillDao.getSkillLike05(map)); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125;]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二）CRUD操作（查询操作基础）]]></title>
    <url>%2F2018%2F08%2F05%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89CRUD%E6%93%8D%E4%BD%9C%EF%BC%88%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇主要讲解查询操作的结果集处理、映射文件里命名空间设置，SQL语句中resultMap，resultType等属性意思、MyBatis的传统和接口代理模式。 源码获取github 1.整体结构目录 SkillDao.java接口含一些方法 SkillDaoImpl.java是SkillDao的实现类 Skill.java是持久化类（实体Bean） SkillMapper.xml是Skill持久化类的映射文件（含SQL语句操作等） MyBatisTest.java测试类 jdbc.properties数据库的属性文件 log4j.properties日志框架配置(在控制台显示sql语句等信息) mybatis-config.xml核心配置文件 2.数据库属性文件jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mssjdbc.mysql.username=rootjdbc.mysql.password=root 3.核心配置文件mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 --&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.封装好的工具类MyBatisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; //输入流 读文件 //1.读取核心配置文件 inputStream = Resources.getResourceAsStream(PATH); //2.创建SqlSession工厂(SqlSessionFactory)相当于Connection sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; /** * 获取sqlsession * @return */ public static SqlSession getSqlsession() &#123; //3.获取SqlSession 相当于执行SQL语句对象PreparedStament预处理对象 //***** SqlSession完成所有的持久化操作CRUD return sqlSessionFactory.openSession(); &#125; /** * 关闭资源 * @param sqlSession */ public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 5.持久化类为了讲出来一些知识点，持久化类的属性名没有和数据库的字段名一样，正常应该是一样的 Skill.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.hs.model;public class Skill &#123; private Integer skillid; private String skillname; private Integer num; public Integer getSkillid() &#123; return skillid; &#125; public void setSkillid(Integer skillid) &#123; this.skillid = skillid; &#125; public String getSkillname() &#123; return skillname; &#125; public void setSkillname(String skillname) &#123; this.skillname = skillname; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public String toString() &#123; return "Skill&#123;" + "skillid=" + skillid + ", skillname='" + skillname + '\'' + ", num=" + num + '&#125;'; &#125;&#125; 6.XML映射文件SQL映射文件经常含一些元素 parameterType—-接收的参数类型，简写方式见mybatis官方文档中，别名和映射的类型那块 parameterMap没有人用了！！！！！ resultType—-语句执行完毕返回的结果集类型 resultMap—-语句执行完毕返回的结果集，这是一个标签，找它对应的标签，对这个结果集进行处理，里面的type就是相应的返回类型 sql—-提取公共的SQL代码 insert—-映射插入语句 update—-映射更新语句 delete—-映射删除语句 select—-映射查询语句 SkillMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace=命名空间，唯一不重复--&gt;&lt;mapper namespace="com.hs.model.Skill"&gt; &lt;!--命名空间规则传统模式：（持久化类（实体化Bean）的类名全路径com.hs.Skill）接口代理模式：接口的全路径--&gt; &lt;!--查询的字段，并没有优化，下个专题进行优化--&gt; &lt;!--当你传递的是“一个”简单的数据类型的形参的时候，那么你的$&#123;任意名字&#125;,sql语句后面不要加 ; --&gt; &lt;select id="getMap01ByPk" parameterType="_int" resultType="map"&gt; select skill_id,skill_name,num from skill where skill_id = #&#123;sadsa&#125; &lt;/select&gt; &lt;select id="getMap02ByPk" parameterType="_int" resultType="map"&gt; select skill_id skillid,skill_name skill_name ,num number from skill where skill_id = #&#123;skill_id&#125; &lt;/select&gt; &lt;!--只能对结果集的结果操作进行处理，autoMapping="true"默认映射，默认为true，重写字段名会覆盖默认的，若false就不会映射默认字段（只映射出自己写的别名）--&gt; &lt;resultMap id="MapResultMapper" type="map" autoMapping="true"&gt; &lt;result column="skill_id" property="id"/&gt; &lt;!--column为结果集里的字段名，property为自己要映射(变成)的字段名--&gt; &lt;result column="skill_name" property="name"/&gt; &lt;result column="num" property="number"/&gt; &lt;/resultMap&gt; &lt;select id="getMap03ByPk" parameterType="_int" resultMap="MapResultMapper"&gt; select skill_id,skill_name ,num from skill where skill_id = #&#123;skill_id&#125; &lt;/select&gt; &lt;!--1.别名方法，属性和字段名一致，可以完成自动映射--&gt; &lt;select id="getSkill01ByPk" parameterType="int" resultType="com.hs.model.Skill"&gt; select skill_id skillid,skill_name skillname,num from skill where skill_id = #&#123;adsa&#125; &lt;/select&gt; &lt;!--2.resultMap标签找对应id的标签，利用结果集，进行转换，jdbcType和javaType可以不用写，名字见jdbc类型和Java 类型对应http://www.mybatis.org/mybatis-3/zh/configuration.html#typeAliases--&gt; &lt;resultMap id="SkillResultMapper" type="com.hs.model.Skill"&gt; &lt;id column="skill_id" jdbcType="INTEGER" property="skillid" javaType="java.lang.Integer"/&gt; &lt;result column="skill_name" jdbcType="VARCHAR" property="skillname" javaType="java.lang.String"/&gt; &lt;result column="num" property="num"/&gt; &lt;/resultMap&gt; &lt;select id="getSkill02ByPk" parameterType="int" resultMap="SkillResultMapper"&gt; select skill_id,skill_name,num from skill where skill_id = #&#123;adsa&#125; &lt;/select&gt; &lt;!--一条一条的为map--&gt; &lt;select id="getSkillList01ByAll" resultType="map"&gt; select skill_id,skill_name,num from skill &lt;/select&gt; &lt;select id="getSkillList02ByAll" resultMap="SkillResultMapper"&gt; select skill_id,skill_name,num from skill &lt;/select&gt;&lt;/mapper&gt; 7.接口SkillDao.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.dao;import com.hs.model.Skill;import java.util.List;import java.util.Map;public interface SkillDao &#123; /** * 处理结果集为Map类型 * @param skillid * @return */ Map&lt;String, Object&gt; getMap01ByPk(int skillid); /** * 处理结果集为Map类型—通过给字段取别名方式 * @param skillid * @return */ Map&lt;String, Object&gt; getMap02ByPk(int skillid); /** * 处理结果集为Map类型—通过resultMap标签处理 * @param skillid * @return */ Map&lt;String, Object&gt; getMap03ByPk(int skillid); /** * 处理结果集为自定义的类Skill—通过给字段取别名方式 * @param skillid * @return */ Skill getSkill01ByPk(int skillid); /** * 处理结果集为自定义的类Skill—resultMap标签处理 * @param skillid * @return */ Skill getSkill02ByPk(int skillid); /** * 处理结果集为集合（list） * @param skillid * @return */ List&lt;Map&lt;String, Object&gt;&gt; getSkillList01ByAll(); /** * 处理结果集为集合（list）—通过resultMap * @param skillid * @return */ List&lt;Map&lt;String, Object&gt;&gt; getSkillList02ByAll();&#125; 8.接口实现类SkillDaoImpl.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.hs.dao;import com.hs.model.Skill;import com.hs.util.MyBatisUtils;import org.apache.ibatis.session.SqlSession;import java.util.List;import java.util.Map;public class SkillDaoImpl implements SkillDao &#123; /* * 关键步骤：定位执行SQL语句***如何定位 (namespace+"."+id) * 因为命名空间是Bean的路径，所以下面的 命名空间.sql语句的id === 类.class.getName()+" ." +id * 后面就是要传过去的值 * */ @Override public Map&lt;String, Object&gt; getMap01ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); System.out.println(Skill.class.getName()+"----com.he.model.Skill"); //关键步骤 return sqlSession.selectOne(Skill.class.getName() + ".getMap01ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Map&lt;String, Object&gt; getMap02ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getMap02ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Map&lt;String, Object&gt; getMap03ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getMap03ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Skill getSkill01ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getSkill01ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public Skill getSkill02ByPk(int skillid) &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectOne(Skill.class.getName() + ".getSkill02ByPk",skillid); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; getSkillList01ByAll() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectList(Skill.class.getName() + ".getSkillList01ByAll"); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125; @Override public List&lt;Map&lt;String, Object&gt;&gt; getSkillList02ByAll() &#123; SqlSession sqlSession = null; try &#123; sqlSession = MyBatisUtils.getSqlsession(); return sqlSession.selectList(Skill.class.getName() + ".getSkillList02ByAll"); &#125; finally &#123; MyBatisUtils.closeSqlSession(sqlSession); &#125; &#125;&#125; 9.日志配置文件log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.model.Skill=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 10.测试类MyBatisTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.hs.test;/** * 本测试全是采用传统模式：dao层里dao接口写方法，daoImpl实现方法，然后写测试类 */import com.hs.dao.SkillDao;import com.hs.dao.SkillDaoImpl;import org.junit.Test;public class MyBatisTest &#123; /** * 处理结果集为Map类型 */ @Test public void getMap01ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap01ByPk(2)); &#125; /** * 处理结果集为Map类型—通过给字段取别名方式 */ @Test public void getMap02ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap02ByPk(2)); &#125; /** * 处理结果集为Map类型—通过resultMap标签处理 */ @Test public void getMap03ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getMap03ByPk(2)); &#125; /** * 处理结果集为自定义的类Skill—通过给字段取别名方式 */ @Test public void getSkill01ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkill01ByPk(2)); &#125; /** * 处理结果集为自定义的类Skill—resultMap标签处理 */ @Test public void getSkill02ByPk() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkill02ByPk(2)); &#125; /** * 处理结果集为集合（list） */ @Test public void getSkillList01ByAll() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkillList01ByAll()); &#125; /** * 处理结果集为集合（list）—通过resultMap */ @Test public void getSkillList02ByAll() &#123; SkillDao skillDao = new SkillDaoImpl(); //接口回调（个人理解，父类定义变量SkillDao skillDao，子类实例化） System.out.println(skillDao.getSkillList02ByAll()); &#125;&#125; 11.在测试类中运行相应的测试]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一）mybatis介绍、环境搭建]]></title>
    <url>%2F2018%2F08%2F04%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89mybatis%E4%BB%8B%E7%BB%8D%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文主要讲什么是框架、如何学习框架、mybatis介绍、如何用idea搭建mybatis的环境(非maven) 源码获取github 1.什么是框架？你可以理解为就是别人写好的工具类，为我们提供一种解决方案，最后为了提高开发效率 2.为什么学习框架？个人：对你底层开发无任何帮助意义，但是如果看源码，可以学到如何设计的 公司：效益，提高了开发效率 3.怎么去学习框架？需要遵循框架规则： 找到jar包 class文件（java文件） 入口：核心配置文件 通过官方给定的帮助文档，使用其提供API接口 测试 在这段时间里，我将学习ssm框架：MyBatis + SpringMvc + Spring 把它在我学jsp，servlet那段时间学的mvc模式，和我将要学的ssm框架，做一个小小的改动： 4.MyBatis框架是一个什么框架？MyBatis是一个持久层框架 什么是持久化： 狭义：把数据永久性的保存到数据库或者存储器都是持久化 广义：针对于数据库所有的操作，都是持久化操作 Create：增加 Read：读取查询 Update：更新 Delete：删除 MyBatis是一个ORM框架： Object：对象 java对象 Relationship：关系（关系型数据库） Mapping：映射 5.什么是MyBatis？MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。 MyBatis避免了几乎所有的JDBC代码(1.加载驱动2.获取连接3.执行语句对象4.处理结果集5.关闭资源)和手动设置参数以及获取结果集(ResultSet). 就是之前学习的时候，自己封装的数据Dao，需要自己处理数据转换成自己想要的对象 MyBatis可以对配置和原生Map使用简单的XML或注解，将接口和Java的POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 6.idea搭建MyBatis环境（非maven）1).所需要的jar包: mybatis-3.4.6.jar mybatis的包 mysql-connector-java-5.1.45-bin.jar 数据库访问 log4j-1.2.17.jar 日志框架包(在控制台显示sql语句信息等) junit-4.12.jar 单元测试框架 hamcrest-core-1.3.jar junit-4.12所依赖的包 都可以在maven仓库中搜索下载 2).创建一个javase project3).在项目目录下创建一个lib放jar包，然后导入jar包：教程4).idea中项目结构如下： lib放jar包 com.hs.dao放接口，和接口实现类(MyBatis又分为传统模式(需要写接口和接口实现类)和接口代理模式(只需要写接口)) com.hs.model放持久化类(实体Bean、数据库表对应的对象)、XML映射文件(含SQL语句) com.hs.test放测试类 com.hs.util放封装好的工具类 jdbc.properties放连接数据库的信息，在mybatis-config.xml中加载 log4j.properties这是日志框架配置 mybatis-config.xml核心配置文件 5).代码内容1.创建数据库(含后几篇文章的数据表)cy42_mss.sql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283DROP TABLE IF EXISTS `oa_user`;CREATE TABLE `oa_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `sex` varchar(255) DEFAULT NULL, `money` decimal(7,2) DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of oa_user-- ----------------------------INSERT INTO `oa_user` VALUES (&apos;1&apos;, &apos;悟空&apos;, &apos;男&apos;, &apos;888.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;2&apos;, &apos;八戒&apos;, &apos;男&apos;, &apos;999.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;3&apos;, &apos;天蓬元帅&apos;, &apos;女&apos;, &apos;1000.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;4&apos;, &apos;悟能&apos;, &apos;男&apos;, &apos;666.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;5&apos;, &apos;法悟法&apos;, &apos;女&apos;, &apos;544.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;6&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;7&apos;, &apos;悟&apos;, &apos;女&apos;, &apos;562.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;14&apos;, &apos;嫦娥&apos;, &apos;女&apos;, &apos;1213.00&apos;, null);INSERT INTO `oa_user` VALUES (&apos;15&apos;, &apos;月兔&apos;, &apos;女&apos;, &apos;2113.00&apos;, null);-- ------------------------------ Table structure for skill-- ----------------------------DROP TABLE IF EXISTS `skill`;CREATE TABLE `skill` ( `skill_id` int(11) NOT NULL AUTO_INCREMENT, `skill_name` varchar(255) DEFAULT NULL, `num` int(11) DEFAULT NULL, `fk_teacher_id` int(11) DEFAULT NULL, PRIMARY KEY (`skill_id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of skill-- ----------------------------INSERT INTO `skill` VALUES (&apos;2&apos;, &apos;JS&apos;, &apos;75&apos;, null);INSERT INTO `skill` VALUES (&apos;7&apos;, &apos;CSS&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;8&apos;, &apos;java&apos;, &apos;66&apos;, null);INSERT INTO `skill` VALUES (&apos;9&apos;, &apos;vue&apos;, &apos;56&apos;, &apos;9999&apos;);-- ------------------------------ Table structure for sys_role-- ----------------------------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` ( `role_id` int(11) NOT NULL AUTO_INCREMENT, `role_name` varchar(32) DEFAULT NULL, `role_key` varchar(32) DEFAULT NULL, `status` int(1) DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1禁用&apos;, PRIMARY KEY (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of sys_role-- ----------------------------INSERT INTO `sys_role` VALUES (&apos;-100&apos;, &apos;超级管理员&apos;, &apos;ADMIN&apos;, &apos;1&apos;);-- ------------------------------ Table structure for sys_user-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `account` varchar(32) NOT NULL, `password` varchar(128) NOT NULL, `user_name` varchar(32) DEFAULT &apos;&apos;, `status` int(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;1可用 -1删除 2禁用&apos;, `login_time` datetime DEFAULT CURRENT_TIMESTAMP, `ip` varchar(128) DEFAULT NULL, `fk_role_id` int(11) DEFAULT NULL, PRIMARY KEY (`user_id`), KEY `fk_role_id` (`fk_role_id`), CONSTRAINT `sys_user_ibfk_1` FOREIGN KEY (`fk_role_id`) REFERENCES `sys_role` (`role_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of sys_user-- ----------------------------INSERT INTO `sys_user` VALUES (&apos;-999&apos;, &apos;super&apos;, &apos;super&apos;, &apos;唐僧&apos;, &apos;1&apos;, &apos;2018-07-28 18:47:39&apos;, null, &apos;-100&apos;);INSERT INTO `sys_user` VALUES (&apos;-888&apos;, &apos;admin&apos;, &apos;admin&apos;, &apos;悟空&apos;, &apos;1&apos;, &apos;2018-07-03 18:48:21&apos;, null, &apos;-100&apos;); 2.数据库属性文件为了解决中文乱码问题： 自己的mysql编码要设置成utf-8或utf8mb4 如果mysql编码没有设置以上的，需要再url后面加?useUnicode=true&amp;characterEncoding=UTF-8 jdbc.properties 1234jdbc.mysql.driver=com.mysql.jdbc.Driverjdbc.mysql.url=jdbc:mysql://localhost:3306/cy42_mss?useUnicode=true&amp;characterEncoding=UTF-8jdbc.mysql.username=rootjdbc.mysql.password=root 3.核心配置文件mybatis-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--加载属性文件 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!--自定义设置类型的别名，也就是resultMap里的type，避免包名已修改，在映射文件里修改多处地方--&gt; &lt;typeAliases&gt; &lt;!-- 方式一、com.hs.model.Skill这个类设置了别名hs，之后要用这个的话，直接写hs --&gt; &lt;!--&lt;typeAlias type="com.hs.model.Skill" alias="hs"/&gt; --&gt; &lt;!-- 方式二、com.hs.model这个包下的类，要用的时候直接写类名，比如用com.hs.model.Skill，直接写Skill --&gt; &lt;package name="com.hs.model"/&gt; &lt;/typeAliases&gt; &lt;!--配置数据库的环境--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!--事务管理器:保证数据的完整性和一致性 关键信息 --&gt; &lt;!--框架：默认情况下CUD操作需要 手动提交事务 （如同在Navicat中表中输入了数据，没有点那个小√，就是没有提交事务， 但是输入insert语句，就自动提交事务了） --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!--使用的是连接池：百度java如何实行连接池的原理？ --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.mysql.driver&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="url" value="$&#123;jdbc.mysql.url&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="username" value="$&#123;jdbc.mysql.username&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;property name="password" value="$&#123;jdbc.mysql.password&#125;" /&gt; &lt;!--获取值，$&#123;属性文件里的变量名&#125;，也可以直接写值--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件 ，也就是含sql语句的文件--&gt; &lt;mappers&gt; &lt;!--告知映射文件方式1，一个一个的配置--&gt; &lt;mapper resource="com/hs/model/SkillMapper.xml"/&gt; &lt;!-- 告知映射文件方式2，自动扫描包内的Mapper接口与配置文件 --&gt; &lt;!--&lt;package name="com.hs.model"/&gt;--&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.dao层SkillDao.java 1具体代码见第二篇 SkillDaoImpl.java 1具体代码见第二篇 5.model层Skill.java(持久化类含对象的属性，get、set方法、toSting方法) 1具体代码见第二篇 SkillMapper.xml(映射文件) 1具体代码见第二篇 6.test层MyBatisTest.java(写测试方法) 12 7.util层(封装好的工具类、可以直接调用)MyBatisUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.hs.util;/** * 知识点： * final修饰类：不能被继承 * 修饰方法：不能被重写 * 修饰变量：常量不可用变，但如果是对象，对象里的值可以变 * */import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MyBatisUtils &#123; private MyBatisUtils() &#123; &#125; //不允许实例化 private static final String PATH = "mybatis-config.xml"; private static InputStream inputStream; private static SqlSessionFactory sqlSessionFactory; static &#123; //1.静态代码块，只是加载一次 try &#123; //输入流 读文件 //1.读取核心配置文件 inputStream = Resources.getResourceAsStream(PATH); //2.创建SqlSession工厂(SqlSessionFactory)相当于Connection sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException("加载核心配置文件失败"); &#125; &#125; /** * 获取sqlsession * @return */ public static SqlSession getSqlsession() &#123; //3.获取SqlSession 相当于执行SQL语句对象PreparedStament预处理对象 //***** SqlSession完成所有的持久化操作CRUD return sqlSessionFactory.openSession(); &#125; /** * 关闭资源 * @param sqlSession */ public static void closeSqlSession(SqlSession sqlSession) &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 8.日志框架配置log4j.properties 123456789# 日志配置文件Global logging configurationlog4j.rootLogger=ERROR, stdout# MyBatis logging configuration...# 如果要显示SQL语句，那么这个位置需要配置为命名空间log4j.logger.命名空间log4j.logger.com.hs.model.Skill=TRACE# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n]]></content>
      <categories>
        <category>MyBatis学习总结</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>SSM</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea导入/移除jar包方式（三种）]]></title>
    <url>%2F2018%2F08%2F04%2Fidea%E5%AF%BC%E5%85%A5-%E7%A7%BB%E9%99%A4jar%E5%8C%85%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%89%E7%A7%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[eclipse导入jar只需要简单的右键addxxx就可以，本篇关于idea导入jar的3种方式，用GIF展示 1.添加jar包 方法一：添加lib目录下的所有jar包 方法二：右键jar，选择addxxx 方法三：在方法一的基础上，点击lib下面的相应的jar包 2.删除jar包]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea的jar添加和删除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql忘记账号密码]]></title>
    <url>%2F2018%2F07%2F24%2Fmysql%E5%BF%98%E8%AE%B0%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如果突然忘记了mysql的账号密码，或者拿着别人的电脑忘记了mysql的账号密码该咋办？？？ 打开mysql.exe和mysqld.exe所在的文件夹,复制路径地址; 打开cmd命令提示符，进入上一步mysql.exe所在的文件夹; 输入命令 mysqld –skip-grant-tables 回车，此时就跳过了mysql的用户验证。注意输入此命令之后命令行就无法操作了，此时可以再打开一个新的命令行。 注意：在输入此命令之前先在任务管理器中结束mysqld.exe进程，确保mysql服务器端已结束运行; 同样也在步骤2之后，然后直接输入mysql，不需要带任何登录参数直接回车就可以登陆上数据库; 输入show databases; 可以看到所有数据库说明成功登陆; 其中mysql库就是保存用户名的地方。输入 use mysql; 选择mysql数据库; 输入show tables;查看所有表，会发现有个user表，这里存放的就是用户名，密码，权限等等账户信息; 输入select user,host,password from user; 来查看账户信息; 更改root密码，输入update user set password=password(‘root’) where user=’root’ and host=’localhost’; 再次查看账户信息，select user,host,password from user; 可以看到密码已被修改。]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea初体验和设置]]></title>
    <url>%2F2018%2F07%2F22%2Fidea%E5%88%9D%E4%BD%93%E9%AA%8C%E5%92%8C%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[换了电脑，idea也能跑起来了，软件也需要设置很多地方 设置有很多啊，比如字体，UTF-8，jdk，maven，git，javawebB站视频教程]]></content>
      <categories>
        <category>idea</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hero+Github搭建个人博客（加优化设置）]]></title>
    <url>%2F2018%2F07%2F21%2FHero-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BC%98%E5%8C%96%E8%AE%BE%E7%BD%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[哈哈哈哈，自己的博客终于搭好了！！还是写个博客记录一下自己如何搭建的吧 首先来首音乐压压惊吧 &emsp;&emsp;其实自己很久之前就想搭个博客，自己写点东西，但是可能就认为搭个博客很难，自己也懒，就没有搭建，结果今天周六，想给自己休息休息，然后找了教程，用Github+hero搭建了这个博客，一个小时就可以完成的，其实并没有那么难，傻瓜式操作，搭建完之后，发现一些优缺点： 重点是免费的，只需要你注册一个GitHub账号，自己一台电脑，然后就ojbk的事。 自带免费的域名，如果自己有其他需求，也可以购买其他的域名。 但是由于Github是国外的，搭建的博客服务器是在Github上，所有没有VPN访问，是很慢的 搭建的教程B站视频教程&emsp;&emsp;&emsp;&emsp;知乎文字教程&emsp;&emsp;&emsp;&emsp;简书文字教程 搭建成功后主题优化教程B站视频教程&emsp;&emsp;&emsp;&emsp;next主题官方文档&emsp;&emsp;&emsp;&emsp;CSDN个性化设置 写博客markdown语法CSDNmarkdown文字教程&emsp;&emsp;&emsp;&emsp;简书作者教程&emsp;&emsp;&emsp;&emsp;简书官方教程 发现一个比较详细的各种设置的博客博客链接 为了解决博客部署在GitHub，访问博客速度慢的问题，把博客同时部署在coding上简书教程 自己总结的一些点新建一个博客文章hexo n 文章名字tags: - 标签名 ##注意 -后面有空格，还有些markdown语句后也要有空格，修改主题文件时，:后面也有空格categories: ​ - 分类名字 ​ - 子分类名字 头像设置旋转找到本地博客目录下themes\next\source\css\common\components\sidebar\sidebar-author.styl加入：1234567891011121314.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; opacity: hexo-config('avatar.opacity') is a 'unit' ? hexo-config('avatar.opacity') : 1; border-radius: 50%; transition: 2s all;&#125;.site-author-image：hover &#123; transform: rotate(360deg);&#125; 侧栏的音乐设置在网易云音乐找到歌，然后点击生成外链播放器，复制代码到blog\themes\next\layout_macro的sidebar.swig文件，添加刚刚复制的外链代码 代码高亮在markdown中的三个点后加代码语言 页面右上角Github图标设置在这里找到想要的设置 http://tholman.com/github-corners/ 复制代码到themes\next\layout文件_layout.swig 修改文章内链接样式文件themes\next\source\css_common\components\post\post.styl下12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: blue; text-decoration: underline; &#125;&#125; next6.0以上文字字数和阅读时间统计见GitHub：https://github.com/theme-next/hexo-symbols-count-time 动态背景设置在主题文件中 搜素canvas 四个主题 next6.0以上版本，动画背景无效果，见Github：1.https://github.com/theme-next/theme-next-canvas-nest2.https://github.com/theme-next/theme-next-three在主题样式里有注释说明 每次本地写完博客，上传的代码hexo claenhexo ghexo d在博客的根目录下进行 大概就写这些吧，只希望自己博客搭建起来，自己要勤快的写东西！！！！！！]]></content>
      <categories>
        <category>hero</category>
      </categories>
      <tags>
        <tag>hero</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
